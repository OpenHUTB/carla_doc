<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Nav - 人车模拟</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Nav";
        var mkdocs_page_input_path = "modules/nav.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> 人车模拟
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">首页</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">人车模拟</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Nav</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/OpenHUTB/doc/edit/master/docs/modules/nav.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <p>@@ -0,0 +1,200 @@
 # CARLA 导航模块技术文档 (Navigation.cpp)</p>
<hr />
<p>## 目录<br />
 1. <a href="#模块概述">模块概述</a><br />
 2. <a href="#核心功能">核心功能</a><br />
 3. <a href="#类与方法详解">类与方法详解</a><br />
 4. <a href="#坐标系统与数据结构">坐标系统与数据结构</a><br />
 5. <a href="#关键流程">关键流程</a><br />
 6. <a href="#配置参数">配置参数</a><br />
 7. <a href="#注意事项">注意事项</a><br />
 8. <a href="#示例代码">示例代码</a><br />
 9. <a href="#附录">附录</a>  </p>
<hr />
<p>## 模块概述<br />
<code>Navigation</code> 是 CARLA 模拟器中实现智能体（行人、车辆）导航的核心模块，基于 <strong>Recast/Detour</strong> 库实现以下功能：<br />
 - <strong>导航网格加载</strong>：支持多瓦片（Tile）动态加载<br />
 - <strong>路径规划</strong>：基于区域类型（道路/草地）的路径搜索与优化<br />
 - <strong>人群模拟</strong>：支持500+代理的动态管理（避障、转向预测、分离行为）<br />
 - <strong>动态障碍物处理</strong>：车辆包围盒（OBB）的实时更新<br />
 - <strong>多线程安全</strong>：通过 <code>std::mutex</code> 保证关键操作原子性  </p>
<hr />
<p>## 核心功能<br />
 ### 1. 导航数据加载<br />
 - <strong>二进制文件解析</strong><br />
   <div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">Load</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">filename</span><span class="p">);</span><span class="w">  </span><span class="c1">// 从文件加载</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">Load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">content</span><span class="p">);</span><span class="w"> </span><span class="c1">// 从内存加载</span>
</code></pre></div>
   - 支持多瓦片动态加载（<code>NavMeshSetHeader</code> 结构体）<br />
   - 内存管理：使用 <code>dtAllocNavMesh</code> 和 <code>dtFreeNavMesh</code> 分配/释放资源  </p>
<p>### 2. 路径规划<br />
 - <strong>三步查询流程</strong><br />
   1. <strong>最近多边形查询</strong>：<code>findNearestPoly()</code><br />
   2. <strong>路径搜索</strong>：<code>findPath()</code> 获取多边形序列<br />
   3. <strong>路径优化</strong>：<code>findStraightPath()</code> 转换为直线路径点<br />
   <div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">GetPath</span><span class="p">(</span><span class="n">Location</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="n">Location</span><span class="w"> </span><span class="n">to</span><span class="p">,</span><span class="w"> </span><span class="n">dtQueryFilter</span><span class="o">*</span><span class="w"> </span><span class="n">filter</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Location</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">byte</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">area</span><span class="p">);</span>
</code></pre></div></p>
<p>### 3. 人群管理<br />
 | 方法                | 功能描述                               |
 |---------------------|----------------------------------------|
 | <code>AddWalker()</code>       | 添加行人代理，配置半径/高度/最大速度  |
 | <code>AddOrUpdateVehicle()</code> | 更新车辆OBB，标记为动态障碍物        |
 | <code>UpdateCrowd()</code>     | 每帧更新代理状态（位置/速度/避障）     |
 | <code>RemoveAgent()</code>     | 移除代理并清理映射关系               |</p>
<p>### 4. 动态避障<br />
 - <strong>车辆包围盒计算</strong><br />
   <div class="highlight"><pre><span></span><code><span class="c1">// 计算旋转后的OBB角点</span>
<span class="n">Vector3D</span><span class="w"> </span><span class="n">box_corner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RotatePointOnOrigin2D</span><span class="p">(</span><span class="n">corner</span><span class="p">,</span><span class="w"> </span><span class="n">yaw_angle</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vehicle</span><span class="p">.</span><span class="n">location</span><span class="p">;</span>
</code></pre></div>
 - <strong>避障参数配置</strong><br />
   <div class="highlight"><pre><span></span><code><span class="n">params</span><span class="p">.</span><span class="n">obstacleAvoidanceType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// 避障品质（0-3对应低到高）</span>
</code></pre></div></p>
<hr />
<p>## 类与方法详解<br />
 ### <code>Navigation</code> 类<br />
 #### 关键方法<br />
 | 方法                      | 参数说明                              | 返回值  |
 |--------------------------|---------------------------------------|---------|
 | <code>CreateCrowd()</code>          | 初始化人群管理器，配置过滤器和避障参数 | void    |
 | <code>GetRandomLocation()</code>    | 生成可行走区域的随机位置              | bool    |
 | <code>SetPedestriansCrossFactor()</code> | 设置行人过马路概率（0.0-1.0）      | void    |</p>
<p>#### 内部状态管理<br />
 - <strong>映射表</strong><br />
   <div class="highlight"><pre><span></span><code><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">ActorId</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">_mapped_walkers_id</span><span class="p">;</span><span class="w">  </span><span class="c1">// 行人ID到索引</span>
<span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">ActorId</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">_mapped_vehicles_id</span><span class="p">;</span><span class="w"> </span><span class="c1">// 车辆ID到索引</span>
</code></pre></div></p>
<hr />
<p>## 坐标系统与数据结构<br />
 ### 坐标系转换<br />
 | 系统        | 坐标顺序 | 转换示例                     |
 |-------------|----------|------------------------------|
 | CARLA (UE)  | (X, Y, Z)| <code>from.x, from.y, from.z</code>     |
 | Recast      | (X, Z, Y)| <code>float pos[3] = {x, z, y};</code>  |</p>
<p>### 数据结构<br />
 - <strong>导航网格头</strong><br />
   <div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">NavMeshSetHeader</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">magic</span><span class="p">;</span><span class="w">             </span><span class="c1">// 魔术字 &#39;MSET&#39;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">version</span><span class="p">;</span><span class="w">           </span><span class="c1">// 版本号</span>
<span class="w">  </span><span class="n">dtNavMeshParams</span><span class="w"> </span><span class="n">params</span><span class="p">;</span><span class="c1">// 网格参数（原点/瓦片尺寸）</span>
<span class="p">};</span>
</code></pre></div></p>
<hr />
<p>## 关键流程  </p>
<h3 id="1">1. 路径规划流程</h3>
<ol>
<li><strong>初始化查询环境</strong></li>
</ol>
<div class="highlight"><pre><span></span><code><span class="c1">// 创建并初始化 NavMeshQuery 实例</span>
<span class="n">dtNavMeshQuery</span><span class="o">*</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dtAllocNavMeshQuery</span><span class="p">();</span>
<span class="n">query</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">navmesh</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_POLYS</span><span class="p">);</span>
<span class="c1">// 配置过滤器：设置区域成本、禁行区域等</span>
<span class="n">dtQueryFilter</span><span class="w"> </span><span class="n">filter</span><span class="p">;</span>
<span class="n">filter</span><span class="p">.</span><span class="n">setIncludeFlags</span><span class="p">(</span><span class="n">SAMPLE_POLYFLAGS_ALL</span><span class="p">);</span>
<span class="n">filter</span><span class="p">.</span><span class="n">setExcludeFlags</span><span class="p">(</span><span class="n">SAMPLE_POLYFLAGS_DISABLED</span><span class="p">);</span>
<span class="n">filter</span><span class="p">.</span><span class="n">setAreaCost</span><span class="p">(</span><span class="n">AREA_ROAD</span><span class="p">,</span><span class="w"> </span><span class="n">AREA_ROAD_COST</span><span class="p">);</span>
<span class="n">filter</span><span class="p">.</span><span class="n">setAreaCost</span><span class="p">(</span><span class="n">AREA_GRASS</span><span class="p">,</span><span class="w"> </span><span class="n">AREA_GRASS_COST</span><span class="p">);</span>
</code></pre></div>
<ol>
<li><strong>最近多边形查询</strong></li>
</ol>
<div class="highlight"><pre><span></span><code><span class="n">dtPolyRef</span><span class="w"> </span><span class="n">start_ref</span><span class="p">,</span><span class="w"> </span><span class="n">end_ref</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">start_pos</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">from</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">from</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">from</span><span class="p">.</span><span class="n">z</span><span class="p">};</span>
<span class="kt">float</span><span class="w"> </span><span class="n">end_pos</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">to</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">   </span><span class="n">to</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">   </span><span class="n">to</span><span class="p">.</span><span class="n">z</span><span class="p">};</span>

<span class="c1">// 在 navmesh 中找到距离起点和终点最近的多边形</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dtStatusFailed</span><span class="p">(</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">findNearestPoly</span><span class="p">(</span><span class="n">start_pos</span><span class="p">,</span><span class="w"> </span><span class="n">extents</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">filter</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">start_ref</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 处理找不到起点多边形的情况</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dtStatusFailed</span><span class="p">(</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">findNearestPoly</span><span class="p">(</span><span class="n">end_pos</span><span class="p">,</span><span class="w"> </span><span class="n">extents</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">filter</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">end_ref</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 处理找不到终点多边形的情况</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>
<p><code>extents</code> 为搜索半径，一般设置为 <code>{2,2,2}</code>。</p>
</li>
<li>
<p><strong>多边形路径搜索</strong></p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">dtPolyRef</span><span class="w"> </span><span class="n">polys</span><span class="p">[</span><span class="n">MAX_POLYS</span><span class="p">];</span>
<span class="kt">int</span><span class="w"> </span><span class="n">poly_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dtStatusFailed</span><span class="p">(</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">findPath</span><span class="p">(</span><span class="n">start_ref</span><span class="p">,</span><span class="w"> </span><span class="n">end_ref</span><span class="p">,</span><span class="w"> </span><span class="n">start_pos</span><span class="p">,</span><span class="w"> </span><span class="n">end_pos</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">filter</span><span class="p">,</span><span class="w"> </span><span class="n">polys</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">poly_count</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_POLYS</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 记录日志：路径搜索失败或超过最大多边形数</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>
<p>返回的 <code>polys</code> 数组包含从起始到目标的多边形序列，长度为 <code>poly_count</code>。</p>
</li>
<li>
<p><strong>路径点优化转换</strong></p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w"> </span><span class="n">straight_path</span><span class="p">[</span><span class="n">MAX_POLYS</span><span class="o">*</span><span class="mi">3</span><span class="p">];</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">straight_flags</span><span class="p">[</span><span class="n">MAX_POLYS</span><span class="p">];</span>
<span class="n">dtPolyRef</span><span class="w"> </span><span class="n">straight_polys</span><span class="p">[</span><span class="n">MAX_POLYS</span><span class="p">];</span>
<span class="kt">int</span><span class="w"> </span><span class="n">path_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="n">query</span><span class="o">-&gt;</span><span class="n">findStraightPath</span><span class="p">(</span>
<span class="w">    </span><span class="n">start_pos</span><span class="p">,</span><span class="w"> </span><span class="n">end_pos</span><span class="p">,</span>
<span class="w">    </span><span class="n">polys</span><span class="p">,</span><span class="w"> </span><span class="n">poly_count</span><span class="p">,</span>
<span class="w">    </span><span class="n">straight_path</span><span class="p">,</span><span class="w"> </span><span class="n">straight_flags</span><span class="p">,</span><span class="w"> </span><span class="n">straight_polys</span><span class="p">,</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">path_count</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_POLYS</span><span class="p">,</span>
<span class="w">    </span><span class="n">DT_STRAIGHTPATH_ALL_CROSSINGS</span>
<span class="p">);</span>

<span class="c1">// 将转换后的路径点填充到 vector&lt;Location&gt;</span>
<span class="n">path</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">path_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Location</span><span class="w"> </span><span class="n">pt</span><span class="p">{</span><span class="n">straight_path</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">straight_path</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">straight_path</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">]};</span>
<span class="w">    </span><span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>
<p><code>path_count</code> 为最终路径点数量。</p>
</li>
<li>
<p><strong>清理与返回</strong></p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">dtFreeNavMeshQuery</span><span class="p">(</span><span class="n">query</span><span class="p">);</span>
<span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="n">path</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
</code></pre></div>
<hr />
<h3 id="2">2. 动态障碍物处理流程</h3>
<ol>
<li><strong>更新车辆包围盒</strong></li>
</ol>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">Navigation::AddOrUpdateVehicle</span><span class="p">(</span><span class="n">ActorId</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Location</span><span class="o">&amp;</span><span class="w"> </span><span class="n">loc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Rotator</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rot</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">guard</span><span class="p">(</span><span class="n">_mutex</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// 计算旋转后的 OBB 八个角</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">Vector3D</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="o">&gt;</span><span class="w"> </span><span class="n">corners</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ComputeOBBCorners</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span><span class="w"> </span><span class="n">rot</span><span class="p">.</span><span class="n">yaw</span><span class="p">,</span><span class="w"> </span><span class="n">vehicle_extent</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// 更新 dtTileCache 或 crowdObstacles</span>
<span class="w">    </span><span class="n">_crowd</span><span class="o">-&gt;</span><span class="n">removeObstacle</span><span class="p">(</span><span class="n">_vehicle_obstacles</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
<span class="w">    </span><span class="n">_vehicle_obstacles</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_crowd</span><span class="o">-&gt;</span><span class="n">addObstacle</span><span class="p">(</span><span class="n">corners</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<ol>
<li><strong>动态切割（TileCache）</strong></li>
</ol>
<div class="highlight"><pre><span></span><code><span class="c1">// 若启用 TileCache，则调用以下接口实现局部切割</span>
<span class="n">dtTileCacheUpdate</span><span class="o">*</span><span class="w"> </span><span class="n">tc_update</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dtAllocTileCacheUpdate</span><span class="p">(...);</span>
<span class="n">tc_update</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OPCODE_CUT_OUT</span><span class="p">;</span>
<span class="n">tc_update</span><span class="o">-&gt;</span><span class="n">poly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_poly</span><span class="p">;</span>
<span class="n">tile_cache</span><span class="o">-&gt;</span><span class="n">addTileCacheUpdate</span><span class="p">(</span><span class="n">tc_update</span><span class="p">);</span>
</code></pre></div>
<ol>
<li><strong>重建切片</strong></li>
</ol>
<h2 id="dtstatus-status-tile_cache-buildtilex-y-if-dtstatusfailedstatus"><div class="highlight"><pre><span></span><code><span class="n">dtStatus</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tile_cache</span><span class="o">-&gt;</span><span class="n">buildTile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dtStatusFailed</span><span class="p">(</span><span class="n">status</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 记录错误并重试</span>
<span class="p">}</span>
</code></pre></div></h2>
<h3 id="3">3. 人群模拟与避障更新流程</h3>
<ol>
<li><strong>批量添加/移除代理</strong></li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">walker</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">new_walkers</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">_crowd</span><span class="o">-&gt;</span><span class="n">addAgent</span><span class="p">(</span><span class="n">walker</span><span class="p">.</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">removed_walkers</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">_crowd</span><span class="o">-&gt;</span><span class="n">removeAgent</span><span class="p">(</span><span class="n">_mapped_walkers_id</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div>
<ol>
<li><strong>每帧避障与位置更新</strong></li>
</ol>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">Navigation::UpdateCrowd</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">delta_time</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">guard</span><span class="p">(</span><span class="n">_mutex</span><span class="p">);</span>
<span class="w">    </span><span class="n">_crowd</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">delta_time</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// 同步位置到 CARLA 代理</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">_crowd</span><span class="o">-&gt;</span><span class="n">getAgentCount</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">dtCrowdAgent</span><span class="o">*</span><span class="w"> </span><span class="n">ag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_crowd</span><span class="o">-&gt;</span><span class="n">getAgent</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="n">Location</span><span class="w"> </span><span class="n">pos</span><span class="p">{</span><span class="n">ag</span><span class="o">-&gt;</span><span class="n">npos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">ag</span><span class="o">-&gt;</span><span class="n">npos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">ag</span><span class="o">-&gt;</span><span class="n">npos</span><span class="p">[</span><span class="mi">2</span><span class="p">]};</span>
<span class="w">        </span><span class="n">UpdateCARLAAgent</span><span class="p">(</span><span class="n">_agent_ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">ag</span><span class="o">-&gt;</span><span class="n">vel</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<ol>
<li><strong>分离与预测</strong></li>
</ol>
<div class="highlight"><pre><span></span><code><span class="c1">// 设置分离权重和预测时间</span>
<span class="n">params</span><span class="p">.</span><span class="n">separationWeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">;</span>
<span class="n">params</span><span class="p">.</span><span class="n">predictTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span>
</code></pre></div>
<h2 id="_1">高级定制</h2>
<h3 id="1_1">1. 自定义查询过滤器</h3>
<p>在默认过滤器基础上，通过设置不同的区域标志和成本，实现对特定地形的偏好或避让：</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">CustomFilter</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">dtQueryFilter</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">CustomFilter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 排除水体区域</span>
<span class="w">        </span><span class="n">setExcludeFlags</span><span class="p">(</span><span class="n">SAMPLE_POLYFLAGS_WATER</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 道路成本最低，草地成本略高</span>
<span class="w">        </span><span class="n">setAreaCost</span><span class="p">(</span><span class="n">AREA_ROAD</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>
<span class="w">        </span><span class="n">setAreaCost</span><span class="p">(</span><span class="n">AREA_GRASS</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0f</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 增加人行道优先级</span>
<span class="w">        </span><span class="n">setAreaCost</span><span class="p">(</span><span class="n">AREA_SIDEWALK</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 使用示例</span>
<span class="n">CustomFilter</span><span class="w"> </span><span class="n">filter</span><span class="p">;</span>
<span class="n">query</span><span class="o">-&gt;</span><span class="n">findPath</span><span class="p">(</span><span class="n">startRef</span><span class="p">,</span><span class="w"> </span><span class="n">endRef</span><span class="p">,</span><span class="w"> </span><span class="n">startPos</span><span class="p">,</span><span class="w"> </span><span class="n">endPos</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">filter</span><span class="p">,</span><span class="w"> </span><span class="n">polys</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">polyCount</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_POLYS</span><span class="p">);</span>
</code></pre></div>
<p><strong>说明</strong>：可以继承 <code>dtQueryFilter</code> 并在构造函数中修改 flag 和 cost，以便针对不同场景进行优化。</p>
<h3 id="2-off-mesh-links">2. Off-Mesh Links 处理</h3>
<p>支持跳跃、攀爬等场景，通过 Off-Mesh Links 定义特殊连接：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 添加 Off-Mesh Link</span>
<span class="n">dtMeshTile</span><span class="o">*</span><span class="w"> </span><span class="n">tile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">navmesh</span><span class="o">-&gt;</span><span class="n">getTile</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">verts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">startVertexId</span><span class="p">,</span><span class="w"> </span><span class="n">endVertexId</span><span class="p">};</span>
<span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">linkRadius</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.2f</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">dtPolyRef</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tile</span><span class="o">-&gt;</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">polyCount</span><span class="p">;</span>
<span class="n">dtOffMeshConnection</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">conn</span><span class="p">.</span><span class="n">radius</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linkRadius</span><span class="p">;</span>
<span class="n">conn</span><span class="p">.</span><span class="n">poly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref</span><span class="p">;</span>
<span class="n">conn</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SAMPLE_POLYFLAGS_JUMP</span><span class="p">;</span>
<span class="n">conn</span><span class="p">.</span><span class="n">userId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1234</span><span class="p">;</span>
<span class="n">conn</span><span class="p">.</span><span class="n">startPosition</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sx</span><span class="p">;</span><span class="w"> </span><span class="n">conn</span><span class="p">.</span><span class="n">startPosition</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sy</span><span class="p">;</span><span class="w"> </span><span class="n">conn</span><span class="p">.</span><span class="n">startPosition</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sz</span><span class="p">;</span>
<span class="n">conn</span><span class="p">.</span><span class="n">endPosition</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">ex</span><span class="p">;</span><span class="w"> </span><span class="n">conn</span><span class="p">.</span><span class="n">endPosition</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">ey</span><span class="p">;</span><span class="w"> </span><span class="n">conn</span><span class="p">.</span><span class="n">endPosition</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">ez</span><span class="p">;</span>

<span class="c1">// 将连接写入网格</span>
<span class="n">navmesh</span><span class="o">-&gt;</span><span class="n">addOffMeshConnection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="p">);</span>
</code></pre></div>
<p>调用 <code>findStraightPath</code> 时，返回的 <code>straight_flags</code> 数组中含 <code>DT_STRAIGHTPATH_OFFMESH_CONNECTION</code>，可据此在行走逻辑中处理跳跃或爬升。</p>
<h3 id="3_1">3. 异步加载与多线程优化</h3>
<p>当场景较大时，可在后台线程逐瓦片加载/卸载导航数据，同时主线程运行路径查询：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 后台加载任务</span>
<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">loadTask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">    </span><span class="n">Navigation</span><span class="o">::</span><span class="n">LoadTileAsync</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// 在主线程检查完成并合并</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">loadTask</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">ready</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">guard</span><span class="p">(</span><span class="n">_mutex</span><span class="p">);</span>
<span class="w">    </span><span class="n">navmesh</span><span class="o">-&gt;</span><span class="n">mergeTile</span><span class="p">(</span><span class="n">pendingTile</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>注意</strong>：所有对 <code>navmesh</code> 和 <code>dtCrowd</code> 的修改需在同一锁保护下完成，避免并发冲突。</p>
<h3 id="4">4. 日志与可视化支持</h3>
<p>内置可将导航网格和路径可视化输出到 CARLA 的调试渲染：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 绘制网格边界</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">tileCount</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="o">*</span><span class="w"> </span><span class="n">verts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">navmesh</span><span class="o">-&gt;</span><span class="n">getTile</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">verts</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="o">*</span><span class="w"> </span><span class="n">polys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">navmesh</span><span class="o">-&gt;</span><span class="n">getTile</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">polys</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">navmesh</span><span class="o">-&gt;</span><span class="n">getTile</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">polyCount</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">RenderDebug</span><span class="o">::</span><span class="n">DrawPolygon</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span><span class="w"> </span><span class="n">polys</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">verts</span><span class="p">,</span><span class="w"> </span><span class="n">polys</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vertCount</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 高亮当前路径</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">RenderDebug</span><span class="o">::</span><span class="n">DrawLine</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">],</span><span class="w"> </span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">Color</span><span class="o">::</span><span class="n">Green</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>日志接口集成 <code>spdlog</code>：</p>
<div class="highlight"><pre><span></span><code><span class="n">SPDLOG_INFO</span><span class="p">(</span><span class="s">&quot;Loaded NavMesh tile {} at ({}, {})&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">tileId</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="n">SPDLOG_DEBUG</span><span class="p">(</span><span class="s">&quot;Computed path with {} points&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</code></pre></div>
<p>通过在 CI 中捕获渲染输出和日志，可对路径正确性和性能进行可视化回归测试。
以下是“社交驾驶行为建模”功能的详细介绍及示例伪代码，供文档中直接引用或改写。</p>
<hr />
<h3 id="5-social-driving-behavior-modeling">5. 社交驾驶行为建模（Social Driving Behavior Modeling）</h3>
<p>社交驾驶行为建模旨在让自动驾驶主体（车辆或行人）在多-agent环境中展现更加“自然”“人性化”的行为，例如礼让行人、智能变道、遵守交通礼仪等。核心思路可以基于以下两种方法之一或结合：</p>
<ol>
<li>
<p><strong>社会力模型（Social Force Model）</strong></p>
</li>
<li>
<p>将周围每个交通参与者视作“力源”——吸引力（desire force）驱动车辆沿目标前进，斥力（social force）促使车辆与他人保持安全距离。</p>
</li>
<li>
<p>在每个仿真步，计算合力并更新速度与方向。</p>
</li>
<li>
<p><strong>深度强化学习（Deep Reinforcement Learning）</strong></p>
</li>
<li>
<p>将车辆状态（位置、速度、周边环境）作为观测，动作空间包括加减速、转向和变道；</p>
</li>
<li>通过奖励函数（如“安全”“效率”“礼让”）训练政策网络，实现多样化行为。</li>
</ol>
<p>以上两者可混合使用：先用社会力模型快速逼近安全、礼让行为，再用RL微调细节。</p>
<h3 id="_2">算法流程</h3>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cmath&gt;</span>

<span class="c1">// 简单的二维向量类</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Vector2</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>

<span class="w">    </span><span class="n">Vector2</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">_x</span><span class="p">),</span><span class="w"> </span><span class="n">y</span><span class="p">(</span><span class="n">_y</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="n">Vector2</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">Vector2</span><span class="w"> </span><span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">Vector2</span><span class="w"> </span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">scalar</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scalar</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scalar</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">Vector2</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">length</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">Vector2</span><span class="w"> </span><span class="n">normalized</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">();</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1e-6</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Agent 类</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Agent</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Vector2</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="n">Vector2</span><span class="w"> </span><span class="n">velocity</span><span class="p">;</span>
<span class="w">    </span><span class="n">Vector2</span><span class="w"> </span><span class="n">goal_pos</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">desired_speed</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">mass</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">lane</span><span class="p">;</span>

<span class="w">    </span><span class="n">Agent</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Vector2</span><span class="o">&amp;</span><span class="w"> </span><span class="n">vel</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Vector2</span><span class="o">&amp;</span><span class="w"> </span><span class="n">goal</span><span class="p">,</span>
<span class="w">          </span><span class="kt">double</span><span class="w"> </span><span class="n">speed</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">m</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">position</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span><span class="w"> </span><span class="n">velocity</span><span class="p">(</span><span class="n">vel</span><span class="p">),</span>
<span class="w">          </span><span class="n">goal_pos</span><span class="p">(</span><span class="n">goal</span><span class="p">),</span><span class="w"> </span><span class="n">desired_speed</span><span class="p">(</span><span class="n">speed</span><span class="p">),</span><span class="w"> </span><span class="n">mass</span><span class="p">(</span><span class="n">m</span><span class="p">),</span><span class="w"> </span><span class="n">lane</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>

<span class="c1">// 计算道路约束力（示例 stub，可根据实际情况补充）</span>
<span class="n">Vector2</span><span class="w"> </span><span class="nf">computeRoadConstraints</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Agent</span><span class="o">&amp;</span><span class="w"> </span><span class="n">agent</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 例如车道边界、交通信号灯等影响，这里先返回零向量</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 是否需要变道（规则或RL策略 stub）</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">needLaneChange</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Agent</span><span class="o">&amp;</span><span class="w"> </span><span class="n">agent</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Agent</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">neighbors</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 简单示例：速度低于某阈值则考虑变道</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">agent</span><span class="p">.</span><span class="n">velocity</span><span class="p">.</span><span class="n">length</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">agent</span><span class="p">.</span><span class="n">desired_speed</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.8</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 选取最佳车道（规则或RL策略 stub）</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">selectBestLane</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Agent</span><span class="o">&amp;</span><span class="w"> </span><span class="n">agent</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Agent</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">neighbors</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 简单示例：切换到下一车道</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">agent</span><span class="p">.</span><span class="n">lane</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 是否存在潜在冲突（规则或RL策略 stub）</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">potentialConflict</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Agent</span><span class="o">&amp;</span><span class="w"> </span><span class="n">agent</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Agent</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">neighbors</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">neighbors</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">agent</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">position</span><span class="p">).</span><span class="n">length</span><span class="p">();</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dist</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">1.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 每个仿真步更新函数</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">updateAgentBehavior</span><span class="p">(</span><span class="n">Agent</span><span class="o">&amp;</span><span class="w"> </span><span class="n">agent</span><span class="p">,</span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Agent</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">neighbors</span><span class="p">,</span>
<span class="w">                         </span><span class="kt">double</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 参数</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.0</span><span class="p">;</span><span class="w">       </span><span class="c1">// 斥力强度</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w">       </span><span class="c1">// 斥力衰减系数</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w">       </span><span class="c1">// 吸引力比例</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">D_safe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w">  </span><span class="c1">// 舒适距离</span>

<span class="w">    </span><span class="c1">// 1. 计算吸引力 toward goal</span>
<span class="w">    </span><span class="n">Vector2</span><span class="w"> </span><span class="n">dir_to_goal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">agent</span><span class="p">.</span><span class="n">goal_pos</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">agent</span><span class="p">.</span><span class="n">position</span><span class="p">).</span><span class="n">normalized</span><span class="p">();</span>
<span class="w">    </span><span class="n">Vector2</span><span class="w"> </span><span class="n">F_att</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">dir_to_goal</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">agent</span><span class="p">.</span><span class="n">desired_speed</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">agent</span><span class="p">.</span><span class="n">velocity</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 2. 计算斥力 against each neighbor</span>
<span class="w">    </span><span class="n">Vector2</span><span class="w"> </span><span class="n">F_rep_total</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">neighbors</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Vector2</span><span class="w"> </span><span class="n">d_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">agent</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">position</span><span class="p">;</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">d_vec</span><span class="p">.</span><span class="n">length</span><span class="p">(),</span><span class="w"> </span><span class="mf">1e-3</span><span class="p">);</span>
<span class="w">        </span><span class="n">Vector2</span><span class="w"> </span><span class="n">n_ij</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_vec</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dist</span><span class="p">);</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">exp_term</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exp</span><span class="p">((</span><span class="n">D_safe</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">dist</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">B</span><span class="p">);</span>
<span class="w">        </span><span class="n">Vector2</span><span class="w"> </span><span class="n">F_rep_ij</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_ij</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">exp_term</span><span class="p">);</span>
<span class="w">        </span><span class="n">F_rep_total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">F_rep_ij</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 3. 考虑道路和交通规则约束</span>
<span class="w">    </span><span class="n">Vector2</span><span class="w"> </span><span class="n">F_road</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeRoadConstraints</span><span class="p">(</span><span class="n">agent</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 4. 合力与动力学更新</span>
<span class="w">    </span><span class="n">Vector2</span><span class="w"> </span><span class="n">F_total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">F_att</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">F_rep_total</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">F_road</span><span class="p">;</span>
<span class="w">    </span><span class="n">Vector2</span><span class="w"> </span><span class="n">acceleration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">F_total</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">agent</span><span class="p">.</span><span class="n">mass</span><span class="p">);</span>
<span class="w">    </span><span class="n">agent</span><span class="p">.</span><span class="n">velocity</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">acceleration</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dt</span><span class="p">;</span>
<span class="w">    </span><span class="n">agent</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">agent</span><span class="p">.</span><span class="n">velocity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dt</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 5. 变道或减速决策（可选 RL 微调）</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">needLaneChange</span><span class="p">(</span><span class="n">agent</span><span class="p">,</span><span class="w"> </span><span class="n">neighbors</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">agent</span><span class="p">.</span><span class="n">lane</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">selectBestLane</span><span class="p">(</span><span class="n">agent</span><span class="p">,</span><span class="w"> </span><span class="n">neighbors</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">potentialConflict</span><span class="p">(</span><span class="n">agent</span><span class="p">,</span><span class="w"> </span><span class="n">neighbors</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">agent</span><span class="p">.</span><span class="n">velocity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">agent</span><span class="p">.</span><span class="n">velocity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span><span class="w">  </span><span class="c1">// 紧急减速</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<hr />
<p>## 配置参数<br />
 ### 静态常量<br />
 <div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MAX_AGENTS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span><span class="p">;</span><span class="w">     </span><span class="c1">// 最大代理数</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">AGENT_RADIUS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.3f</span><span class="p">;</span><span class="w"> </span><span class="c1">// 碰撞半径</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">AREA_ROAD_COST</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">10.0f</span><span class="p">;</span><span class="w"> </span><span class="c1">// 道路区域路径成本</span>
</code></pre></div></p>
<p>### 避障参数<br />
 | 参数                  | 值    | 描述                |
 |-----------------------|-------|---------------------|
 | <code>adaptiveDivs</code>        | 7     | 采样细分次数        |
 | <code>separationWeight</code>   | 0.5f  | 分离行为权重        |</p>
<hr />
<p>在 CARLA 的导航模块中，使用 <code>std::mutex</code> 对关键操作加锁的主要目的是确保多线程环境下的数据一致性和线程安全性。以下是对加锁必要性的详细说明，可补充至“注意事项”部分：</p>
<hr />
<h2 id="_3">注意事项</h2>
<ol>
<li>
<p><strong>内存管理</strong></p>
</li>
<li>
<p>显式调用 <code>dtFreeNavMesh()</code> 释放资源，避免内存泄漏。</p>
</li>
<li>
<p><strong>线程安全</strong></p>
</li>
<li>
<p>所有修改 <code>dtCrowd</code> 状态的操作需加锁：</p>
<p><div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">_mutex</span><span class="p">);</span>
</code></pre></div>
   * <strong>加锁的必要性</strong>：
 * <strong>避免数据竞争</strong>：在多线程环境中，多个线程可能同时访问和修改共享资源（如导航网格、代理状态等）。如果不加锁，可能导致数据竞争，产生不可预测的行为。
 * <strong>确保操作的原子性</strong>：加锁可以确保对共享资源的操作是原子的，即操作在执行过程中不会被其他线程打断，从而保持数据的一致性。
 * <strong>防止死锁和资源泄漏</strong>：通过合理使用锁机制，可以避免死锁的发生，并确保资源在使用完毕后被正确释放。
 * <strong>提高程序的稳定性和可靠性</strong>：加锁可以防止由于并发访问导致的程序崩溃或异常，提高系统的稳定性。
 * <strong>参考资料</strong>：关于多线程加锁的详细解释，请参阅 <a href="https://blog.csdn.net/ke1ying/article/details/109531062">CSDN博客</a>。</p>
</li>
<li>
<p><strong>性能限制</strong></p>
</li>
<li>
<p><code>MAX_POLYS=256</code> 和 <code>MAX_AGENTS=500</code> 影响计算复杂度。</p>
</li>
</ol>
<hr />
<table>
<thead>
<tr>
<th>注意事项</th>
<th>对应资源类型</th>
<th>具体对象/结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>内存管理</td>
<td>导航网格与查询对象</td>
<td><code>dtNavMesh*</code>、<code>dtNavMeshQuery*</code></td>
</tr>
<tr>
<td>线程安全</td>
<td>路径查询与人群管理</td>
<td><code>dtNavMesh</code>、<code>dtNavMeshQuery</code>、<code>dtCrowd</code>、<code>dtCrowdAgent</code></td>
</tr>
<tr>
<td>性能限制</td>
<td>网格查询多边形数、人群代理数限制</td>
<td><code>DT_MAX_POLYS</code>、<code>dtCrowd(maxAgents=…)</code></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="_4">内存管理</h2>
<p>Recast/Detour 在 CARLA 中负责导航网格的加载、切割与查询，需手动释放相应资源以防泄漏。</p>
<ul>
<li>
<p><strong>导航网格对象 (<code>dtNavMesh*</code>)</strong></p>
</li>
<li>
<p>CARLA 在 <code>Navigation::Load(...)</code> 中调用 <code>dtAllocNavMesh()</code> 分配网格实例，结束后必须调用 <code>dtFreeNavMesh(navmesh)</code> 释放所有瓦片数据（仅释放标记 <code>DT_TILE_FREE_DATA</code> 的瓦片）([recastnav.com][1])。</p>
</li>
<li>
<p><strong>查询对象 (<code>dtNavMeshQuery*</code>)</strong></p>
</li>
<li>
<p>用于执行 <code>findNearestPoly()</code>、<code>findPath()</code>、<code>findStraightPath()</code> 等操作，分配方式同 <code>dtAllocNavMeshQuery()</code>，完成后应调用 <code>dtFreeNavMeshQuery(query)</code> 以回收节点池和开放列表内存([recastnav.com][1])。</p>
</li>
<li><strong>节点池与开放列表</strong></li>
</ul>
<p>上述资源均在 CARLA 源码的 <code>LibCarla/Navigation</code> 模块中通过 Recast/Detour API 管理，必须成对使用 <code>dtAlloc…</code> 与 <code>dtFree…</code>。</p>
<hr />
<h2 id="_5">线程安全</h2>
<p>CARLA 支持同时更新数百个行人和车辆，底层依赖 Detour 的并发模型，但自身并未对 Detour 做线程封装，需在应用层自行加锁。</p>
<ul>
<li>
<p><strong>Detour 本身非线程安全</strong></p>
</li>
<li>
<p>Detour 将数据分为“导航数据”与“查询数据”两部分。导航数据（<code>dtNavMesh</code>）可多线程只读；查询数据（包含节点池、开放列表）在执行过程中会被修改，存在并发访问冲突([Google 群组][2])。</p>
</li>
<li>
<p><strong>CARLA 的 <code>dtCrowd</code> 管理</strong></p>
</li>
<li>
<p><code>dtCrowd</code> 维护一组 <code>dtCrowdAgent</code>，负责避障与本地寻路。多线程更新时，若多个线程同时调用 <code>update()</code>、<code>addAgent()</code>、<code>removeAgent()</code>，会竞态修改内部容器与过滤器参数，导致未定义行为([rwindegger.github.io][3], [GitHub][4])。</p>
</li>
<li><strong><code>std::mutex</code> 加锁示例</strong></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">Navigation::UpdateCrowd</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">EpisodeState</span><span class="o">&amp;</span><span class="w"> </span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">guard</span><span class="p">(</span><span class="n">_mutex</span><span class="p">);</span>
<span class="w">    </span><span class="n">_crowd</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span><span class="w"> </span><span class="n">agents</span><span class="p">,</span><span class="w"> </span><span class="n">agentCount</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>该锁确保在一次 <code>update()</code> 调用中，无其他线程能同时修改 <code>_crowd</code> 或映射表 <code>_mapped_walkers_id</code>/<code>_mapped_vehicles_id</code>([Google 群组][2])。</li>
<li>
<p><strong>加锁</strong></p>
</li>
<li>
<p><strong>避免数据竞争</strong>：并发读写会导致节点池或代理容器处于不一致状态，触发崩溃或路径错误([Google 群组][5])。</p>
</li>
<li><strong>保证原子性</strong>：一系列操作（如先移除旧代理再添加新代理）要么全部完成，要么全部不生效，防止中间状态被其他线程观察到而出错([Google 群组][2])。</li>
<li><strong>防止资源泄漏</strong>：锁可确保在异常抛出时，析构保护会释放 <code>_mutex</code> 并允许后续清理逻辑正确执行。</li>
<li><strong>提升可靠性</strong>：虽有性能开销，但对关键操作加锁能极大降低生产环境下的随机崩溃风险([Google 群组][2])。</li>
</ul>
<hr />
<h2 id="_6">性能限制</h2>
<p>CARLA 在导航模块中对路径搜索与人群模拟规模做了上限，以控制查询与避障计算复杂度。</p>
<ul>
<li>
<p><strong>最大多边形数 (<code>DT_MAX_POLYS</code>)</strong></p>
</li>
<li>
<p>Detour 查询时会遍历多边形网格，<code>DT_MAX_POLYS=256</code>（默认值）限定 <code>findPath()</code> 等函数的多边形序列最大长度，超限将提前退出；过大可支持长路径但压力激增([recastnav.com][1])。</p>
</li>
<li>
<p><strong>最大代理数 (<code>dtAllocCrowd(maxAgents)</code>)</strong></p>
</li>
<li>
<p>在 <code>Navigation::CreateCrowd()</code> 中，<code>dtAllocCrowd(MAX_AGENTS)</code> 分配代理数组，CARLA 默认 <code>MAX_AGENTS=500</code>，即一次性只能管理 500 个行人/车辆避障；超出后 <code>addAgent()</code> 返回失败([GitHub][4])。</p>
</li>
<li>
<p><strong>避障质量 (<code>obstacleAvoidanceType</code>)</strong></p>
</li>
<li>
<p>可在 0–3 间切换采样分辨率与代价计算复杂度，较高质量下 CPU 采样更密集，影响单帧性能；CARLA 默认 <code>3</code>，可针对性能需求下调✱。</p>
</li>
<li>
<p><strong>多线程并行限度</strong></p>
</li>
<li>
<p>虽可为每线程创建独立 <code>dtNavMeshQuery</code> 实例并发运行查询，但若导航网格需动态更新（<code>addTile()</code>/<code>removeTile()</code>），更新时仍需全局锁定以防查询中断([Google 群组][5])。</p>
</li>
</ul>
<hr />
<p>## 示例代码  </p>
<div class="highlight"><pre><span></span><code><span class="c1">// ===== NavigationExample.cpp =====</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Navigation.h&quot;</span><span class="c1">        // 包含 Navigation 类声明</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;geom/Location.h&quot;</span><span class="c1">     // CARLA 几何库</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;geom/Rotator.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Logging.h&quot;</span><span class="c1">           // 假设有统一的日志接口</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 1. 创建导航实例并加载 NavMesh</span>
<span class="w">    </span><span class="n">Navigation</span><span class="w"> </span><span class="n">nav</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">navmesh_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;city_navmesh.bin&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">nav</span><span class="p">.</span><span class="n">Load</span><span class="p">(</span><span class="n">navmesh_file</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">logging</span><span class="o">::</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;导航数据加载失败: %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">navmesh_file</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">logging</span><span class="o">::</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;成功加载导航网格：%s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">navmesh_file</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>

<span class="w">    </span><span class="c1">// 2. 创建人群管理器，配置避障和路径过滤参数</span>
<span class="w">    </span><span class="n">nav</span><span class="p">.</span><span class="n">CreateCrowd</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// 设置行人越过道路的概率</span>
<span class="w">    </span><span class="n">nav</span><span class="p">.</span><span class="n">SetPedestriansCrossFactor</span><span class="p">(</span><span class="mf">0.2f</span><span class="p">);</span>
<span class="w">    </span><span class="n">logging</span><span class="o">::</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;人群管理器初始化完成&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 3. 添加行人代理</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">walker_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1001</span><span class="p">;</span>
<span class="w">    </span><span class="n">geom</span><span class="o">::</span><span class="n">Location</span><span class="w"> </span><span class="n">walker_spawn</span><span class="p">{</span><span class="mf">10.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">20.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">};</span><span class="w"> </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">nav</span><span class="p">.</span><span class="n">AddWalker</span><span class="p">(</span><span class="n">walker_id</span><span class="p">,</span><span class="w"> </span><span class="n">walker_spawn</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">logging</span><span class="o">::</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;添加行人 %llu 失败&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">walker_id</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">logging</span><span class="o">::</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;行人 %llu 已添加，初始位置 (%.2f, %.2f, %.2f)&quot;</span><span class="p">,</span>
<span class="w">                      </span><span class="n">walker_id</span><span class="p">,</span>
<span class="w">                      </span><span class="n">walker_spawn</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">walker_spawn</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">walker_spawn</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 4. 设置行人目标点</span>
<span class="w">    </span><span class="n">geom</span><span class="o">::</span><span class="n">Location</span><span class="w"> </span><span class="n">walker_target</span><span class="p">{</span><span class="mf">50.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">30.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">};</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">nav</span><span class="p">.</span><span class="n">SetWalkerTarget</span><span class="p">(</span><span class="n">walker_id</span><span class="p">,</span><span class="w"> </span><span class="n">walker_target</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">logging</span><span class="o">::</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;设置行人 %llu 目标失败&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">walker_id</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">logging</span><span class="o">::</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;行人 %llu 目标设置为 (%.2f, %.2f, %.2f)&quot;</span><span class="p">,</span>
<span class="w">                      </span><span class="n">walker_id</span><span class="p">,</span>
<span class="w">                      </span><span class="n">walker_target</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">walker_target</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">walker_target</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 5. 添加一辆动态障碍物（车辆）</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">vehicle_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2001</span><span class="p">;</span>
<span class="w">    </span><span class="n">geom</span><span class="o">::</span><span class="n">Location</span><span class="w"> </span><span class="n">vehicle_loc</span><span class="p">{</span><span class="mf">15.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">25.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">};</span>
<span class="w">    </span><span class="n">geom</span><span class="o">::</span><span class="n">Rotator</span><span class="w"> </span><span class="n">vehicle_rot</span><span class="p">{</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">90.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">};</span><span class="w">  </span><span class="c1">// 车辆朝向 90°</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">nav</span><span class="p">.</span><span class="n">AddOrUpdateVehicle</span><span class="p">(</span><span class="n">vehicle_id</span><span class="p">,</span><span class="w"> </span><span class="n">vehicle_loc</span><span class="p">,</span><span class="w"> </span><span class="n">vehicle_rot</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">logging</span><span class="o">::</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;添加/更新车辆 %llu 失败&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">vehicle_id</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">logging</span><span class="o">::</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;车辆 %llu 已注册为动态障碍物，位置 (%.2f, %.2f, %.2f), 偏航角 %.2f°&quot;</span><span class="p">,</span>
<span class="w">                      </span><span class="n">vehicle_id</span><span class="p">,</span>
<span class="w">                      </span><span class="n">vehicle_loc</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">vehicle_loc</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">vehicle_loc</span><span class="p">.</span><span class="n">z</span><span class="p">,</span>
<span class="w">                      </span><span class="n">vehicle_rot</span><span class="p">.</span><span class="n">yaw</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 6. 主循环：在每个模拟帧调用更新函数</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">fixedDeltaTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">30.0f</span><span class="p">;</span><span class="w">  </span><span class="c1">// 30 FPS</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">frame</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 假设获取当前车辆列表和行人列表的逻辑已在外部实现</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VehicleState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vehicle_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetCurrentVehicleStates</span><span class="p">();</span>
<span class="w">        </span><span class="n">EpisodeState</span><span class="w"> </span><span class="n">sim_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetCurrentEpisodeState</span><span class="p">();</span>

<span class="w">        </span><span class="c1">// 更新人群（行人）避障和路径跟踪</span>
<span class="w">        </span><span class="n">nav</span><span class="p">.</span><span class="n">UpdateCrowd</span><span class="p">(</span><span class="n">fixedDeltaTime</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 更新所有车辆动态障碍物（位置与旋转）</span>
<span class="w">        </span><span class="n">nav</span><span class="p">.</span><span class="n">UpdateVehicles</span><span class="p">(</span><span class="n">vehicle_list</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 可以在此处插入渲染或其他逻辑</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 7. 退出前清理资源（析构时自动释放 NavMesh、Crowd 等）</span>
<span class="w">    </span><span class="n">logging</span><span class="o">::</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;导航模拟结束，开始清理资源&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>要点说明：</strong></p>
<ol>
<li><strong>错误检查与日志</strong>
   每一步操作后都进行了返回值判断，并通过 <code>logging</code> 模块输出信息或警告，便于调试与排查问题。</li>
<li>
<p><strong>配置细节</strong></p>
</li>
<li>
<p>调用 <code>SetPedestriansCrossFactor()</code> 演示了如何动态调整行人过马路的概率。</p>
</li>
<li><code>fixedDeltaTime</code> 固定为 30 帧每秒，仅供示例，可根据实际仿真引擎时间步长调整。</li>
<li>
<p><strong>车辆动态障碍</strong></p>
</li>
<li>
<p>使用 <code>AddOrUpdateVehicle()</code> 注册车辆包围盒，示例中展示了位置和朝向的设置。</p>
</li>
<li>在主循环中，每帧都调用 <code>UpdateVehicles()</code> 同步车辆状态。</li>
<li>
<p><strong>主循环结构</strong></p>
</li>
<li>
<p>假设外部提供 <code>GetCurrentVehicleStates()</code> 与 <code>GetCurrentEpisodeState()</code>，实际可根据用户项目自行实现。</p>
</li>
<li>将行人更新和车辆更新放在同一循环中，保证多代理场景下一致性。</li>
</ol>
<hr />
<p>## 附录<br />
 ### 依赖项<br />
 - <strong>Recast/Detour</strong>：导航网格与路径规划<br />
 - <strong>CARLA 几何库</strong>：<code>geom::Location</code>, <code>geom::Math</code>  </p>
<p>### 调试支持<br />
 - <strong>断言检查</strong>：<br />
   <div class="highlight"><pre><span></span><code><span class="n">DEBUG_ASSERT</span><span class="p">(</span><span class="n">_nav_query</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span><span class="w"> </span><span class="c1">// 确保查询对象已初始化</span>
</code></pre></div>
 - <strong>日志输出</strong>：<br />
   <div class="highlight"><pre><span></span><code><span class="n">logging</span><span class="o">::</span><span class="n">log</span><span class="p">(</span><span class="s">&quot;Nav: failed to create crowd&quot;</span><span class="p">);</span>
</code></pre></div></p>
<h2 id="_7">附录</h2>
<h3 id="_8">依赖项</h3>
<ul>
<li><strong>Recast/Detour</strong>：导航网格与路径规划</li>
<li><strong>CARLA 几何库</strong>：<code>geom::Location</code>, <code>geom::Math</code></li>
</ul>
<h3 id="_9">调试支持</h3>
<ul>
<li><strong>断言检查</strong>：</li>
</ul>
<p><div class="highlight"><pre><span></span><code><span class="n">DEBUG_ASSERT</span><span class="p">(</span><span class="n">_nav_query</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span><span class="w"> </span><span class="c1">// 确保查询对象已初始化</span>
</code></pre></div>
* <strong>日志输出</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="n">logging</span><span class="o">::</span><span class="n">log</span><span class="p">(</span><span class="s">&quot;Nav: failed to create crowd&quot;</span><span class="p">);</span>
</code></pre></div>
<p><strong>补充说明</strong>：增加调试支持说明，帮助定位运行时错误和状态异常。</p>
<hr />
<h2 id="_10">扩展功能</h2>
<h3 id="1-tilecache">1. 运行时导航网格切割与TileCache</h3>
<ul>
<li><strong>动态障碍物切割</strong>：基于 <code>dtTileCache</code> 实现对动态物体的局部切割，无需重建整个网格，可显著提升性能。</li>
<li><strong>离线编辑支持</strong>：使用 CARLA UE4 导出器生成 <code>.OBJ</code> 并调用 RecastBuilder 生成 <code>.BIN</code>，支持自定义参数（如瓦片大小、层高度）(<a href="https://carla.readthedocs.io/en/0.9.7/how_to_generate_pedestrians_navigation/?utm_source=chatgpt.com">carla.readthedocs.io</a>)。</li>
</ul>
<h3 id="2-off-mesh-links_1">2. 离散导航链接（Off-Mesh Links）</h3>
<ul>
<li><strong>跳跃与爬升链接</strong>：允许通过手动或算法方式在 NavMesh 上添加“跳跃”、“梯子”等自定义连接，增强导航灵活性(<a href="https://digestingduck.blogspot.com/2009/07/recast-and-detour-roadmap.html?utm_source=chatgpt.com">digestingduck.blogspot.com</a>)。</li>
<li><strong>运行时增删链接</strong>：可通过 <code>dtMeshTile</code> 动态管理 Off-Mesh 连接，无需重建瓦片；推荐使用哈希表存储链接索引以加速查询。</li>
</ul>
<h3 id="3_2">3. 可视化与调试</h3>
<ul>
<li><strong>NavMesh调试渲染</strong>：CARLA 提供的 No-Rendering 工具可在 2D 地图上可视化导航网格、交通信号和行人路径(<a href="https://carla.org/2019/01/31/release-0.9.3/?utm_source=chatgpt.com">carla.org</a>)。</li>
<li><strong>调试UI插件</strong>：在 UE4 编辑器中使用 Carla Exporter 导出 OBJ，并在场景中加载调试材质查看不同区域成本；可通过过滤器调节 <code>AREA_ROAD_COST</code> 实时预览路径变化。</li>
</ul>
<h3 id="4_1">4. 性能剖析与优化</h3>
<ul>
<li><strong>Query缓存</strong>：对频繁调用的 <code>dtNavMeshQuery</code> 对象进行复用，避免重复分配，减少 GC 开销。</li>
<li><strong>多线程分桶调度</strong>：将 <code>UpdateCrowd</code> 分成多个分区并行执行，每个线程处理一组代理，合并结果时加锁保障一致性。</li>
<li><strong>代理批量更新</strong>：对相邻或相似路径的代理进行合并查询，利用局部空间相似性降低调用次数。</li>
</ul>
<hr />
<h2 id="_11">典型应用案例</h2>
<h3 id="_12">异步获取路径</h3>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">PathResult</span><span class="o">&gt;</span><span class="w"> </span><span class="n">async_get_path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">nav</span><span class="p">,</span><span class="n">from</span><span class="p">,</span><span class="n">to</span><span class="p">,</span><span class="n">filter</span><span class="p">](){</span>
<span class="w">    </span><span class="n">PathResult</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">    </span><span class="n">nav</span><span class="p">.</span><span class="n">GetPath</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="n">to</span><span class="p">,</span><span class="n">filter</span><span class="p">,</span><span class="n">result</span><span class="p">.</span><span class="n">path</span><span class="p">,</span><span class="n">result</span><span class="p">.</span><span class="n">area</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div>
<ul>
<li><strong>补充说明</strong>：使用异步接口可避免主线程阻塞，适用于高并发路径请求场景。</li>
</ul>
<h3 id="_13">自定义区域成本示例</h3>
<div class="highlight"><pre><span></span><code><span class="n">filter</span><span class="o">-&gt;</span><span class="n">setAreaCost</span><span class="p">(</span><span class="n">AREA_ROAD</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0f</span><span class="p">);</span>
<span class="n">filter</span><span class="o">-&gt;</span><span class="n">setAreaCost</span><span class="p">(</span><span class="n">AREA_GRASS</span><span class="p">,</span><span class="w"> </span><span class="mf">20.0f</span><span class="p">);</span>
</code></pre></div>
<ul>
<li><strong>补充说明</strong>：通过动态调节 <code>dtQueryFilter</code> 中的区域成本，可实现行人或车辆对不同地形偏好的模拟。</li>
</ul>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/OpenHUTB/doc" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="https://cdn.rawgit.com/knsv/mermaid/6.0.0/dist/mermaid.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script>
      <script src="../../js/umlconvert.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
