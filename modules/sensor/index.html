<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Sensor - 人车模拟器</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Sensor";
        var mkdocs_page_input_path = "modules/sensor.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> 人车模拟器
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">首页</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">人车模拟器</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Sensor</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/OpenHUTB/carla_doc/edit/master/docs/modules/sensor.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h2 id="table-of-contents">📑 目录（Table of Contents）</h2>
<h3 id="sensorothercollision">第一章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#collision-detector">碰撞事件传感器</a> （sensor.other.collision）</h3>
<ul>
<li><a href="#第一章carla-碰撞事件传感器系统sensorothercollision">第一章：CARLA 碰撞事件传感器系统（sensor.other.collision）</a></li>
<li><a href="#1-模块概览">1 模块概览</a></li>
<li><a href="#2-传感器注册与调用原理">2 传感器注册与调用原理</a></li>
<li><a href="#3-数据结构collisionevent">3 数据结构：CollisionEvent</a></li>
<li><a href="#4-序列化器分析collisioneventserializer">4 序列化器分析</a></li>
<li><a href="#5-rawdata-与-sensordata-概述">5 RawData 与 SensorData 概述</a></li>
<li><a href="#6-python-api-使用示例">6 Python API 使用示例</a></li>
<li><a href="#7-小结与拓展">7 小结与拓展</a></li>
</ul>
<h3 id="sensorothernoop">第二章：空传感器（sensor.other.noop）</h3>
<ul>
<li><a href="#第二章carla-空传感器系统sensorothernoop">第二章：CARLA 空传感器系统（sensor.other.noop）</a></li>
<li><a href="#1-模块概览-1">1 模块概览</a></li>
<li><a href="#2-传感器注册与调用原理-1">2 传感器注册与调用原理</a></li>
<li><a href="#3-序列化器分析noopserializer">3 序列化器分析</a></li>
<li><a href="#4-数据结构与传输机制">4 数据结构与传输机制</a></li>
<li><a href="#5-python-api-使用示例-1">5 Python API 使用示例</a></li>
<li><a href="#6-小结与拓展-1">6 小结与拓展</a></li>
</ul>
<h3 id="sensorotherimu">第三章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#imu-sensor">惯性测量单元传感器</a> （sensor.other.imu）</h3>
<ul>
<li><a href="#第三章carla惯性测量单元传感器系统sensorotherimu">第三章：CARLA惯性测量单元传感器系统（sensor.other.imu）</a></li>
<li><a href="#1-模块概览-2">1 模块概览</a></li>
<li><a href="#2-工作流程与序列化机制">2 工作流程与序列化机制</a></li>
<li><a href="#3-数据结构详解">3 数据结构详解</a></li>
<li><a href="#4-python-api-调用示例">4 Python API 调用示例</a></li>
<li><a href="#5-拓展用例与集成应用">5 拓展用例与集成应用</a></li>
<li><a href="#6-限制与对比分析">6 限制与对比分析</a></li>
<li><a href="#7-总结与建议-1">7 总结与建议</a></li>
</ul>
<h3 id="sensorothergnss">第四章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#gnss-sensor">全球导航卫星系统传感器</a> （sensor.other.gnss）</h3>
<ul>
<li><a href="#第四章carla-全球导航卫星系统传感器sensorothergnss">第四章：CARLA 全球导航卫星系统传感器（sensor.other.gnss）</a></li>
<li><a href="#1-模块概览-3">1 模块概览</a></li>
<li><a href="#2-工作流程与传输机制">2 工作流程与传输机制</a></li>
<li><a href="#3-数据结构解析">3 数据结构解析</a></li>
<li><a href="#4-序列化机制分析">4 序列化机制分析</a></li>
<li><a href="#5-python-api-使用示例-2">5 Python API 使用示例</a></li>
<li><a href="#6-应用拓展与组合使用">6 应用拓展与组合使用</a></li>
<li><a href="#7-总结与建议-2">7 总结与建议</a></li>
</ul>
<h3 id="sensorotherlane_invasion">第五章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#lane-invasion-detector">车道入侵传感器</a> （sensor.other.lane_invasion）</h3>
<ul>
<li>
<p><a href="#第五章carla-车道入侵传感器系统sensorotherlane_invasion">第五章：CARLA 车道入侵传感器系统（sensor.other.lane_invasion）</a></p>
</li>
<li>
<p><a href="#1-模块概览-4">1 模块概览</a></p>
</li>
<li><a href="#2-检测流程与回调机制">2 检测流程与回调机制</a></li>
<li><a href="#3-数据结构laneinvasionevent">3 数据结构：LaneInvasionEvent</a></li>
<li><a href="#4-序列化机制分析-1">4 序列化机制分析</a></li>
<li><a href="#5-python-api-使用示例-3">5 Python API 使用示例</a></li>
<li><a href="#6-应用案例与拓展建议">6 应用案例与拓展建议</a></li>
<li><a href="#7-小结">7 小结</a></li>
</ul>
<h3 id="sensorlidarray_cast">第六章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#lidar-sensor">激光雷达传感器</a> （sensor.lidar.ray_cast）</h3>
<ul>
<li>
<p><a href="#第六章carla-激光雷达传感器系统sensorlidarray_cast">第六章：CARLA 激光雷达传感器系统（sensor.lidar.ray_cast）</a></p>
</li>
<li>
<p><a href="#1-模块概览-5">1 模块概览</a></p>
</li>
<li><a href="#2-工作机制与原理">2 工作机制与原理</a></li>
<li><a href="#3-数据结构与点云格式">3 数据结构与点云格式</a></li>
<li><a href="#4-序列化与反序列化流程">4 序列化与反序列化流程</a></li>
<li><a href="#5-python-api-示例与配置参数">5 Python API 示例与配置参数</a></li>
<li><a href="#6-应用场景与可拓展方向">6 应用场景与可拓展方向</a></li>
<li><a href="#7-总结-1">7 总结</a></li>
</ul>
<h3 id="sensorotherobstacle">第七章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#obstacle-detector">障碍物检测传感器</a> （sensor.other.obstacle）</h3>
<ul>
<li>
<p><a href="#第七章carla-障碍物检测传感器系统sensorotherobstacle">第七章：CARLA 障碍物检测传感器系统（sensor.other.obstacle）</a></p>
</li>
<li>
<p><a href="#1-模块概览-6">1 模块概览</a></p>
</li>
<li><a href="#2-触发机制与事件流程">2 触发机制与事件流程</a></li>
<li><a href="#3-数据结构解析obstacledetectionevent">3 数据结构解析：ObstacleDetectionEvent</a></li>
<li><a href="#4-序列化机制说明">4 序列化机制说明</a></li>
<li><a href="#5-python-api-使用示例-4">5 Python API 使用示例</a></li>
<li><a href="#6-应用场景与扩展建议">6 应用场景与扩展建议</a></li>
<li><a href="#7-小结-1">7 小结</a></li>
</ul>
<h3 id="rgb-sensorcamerargb">第八章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#rgb-camera">RGB 摄像头传感器</a> （sensor.camera.rgb）</h3>
<ul>
<li>
<p><a href="#第八章carla-rgb-摄像头传感器系统sensorcamerargb">第八章：CARLA RGB 摄像头传感器系统（sensor.camera.rgb）</a></p>
</li>
<li>
<p><a href="#1-模块概览-7">1 模块概览</a></p>
</li>
<li><a href="#2-图像采集与传输机制">2 图像采集与传输机制</a></li>
<li><a href="#3-数据结构说明image">3 数据结构说明：Image</a></li>
<li><a href="#4-序列化与编码流程">4 序列化与编码流程</a></li>
<li><a href="#5-python-api-使用示例-5">5 Python API 使用示例</a></li>
<li><a href="#6-应用方向与参数优化">6 应用方向与参数优化</a></li>
<li><a href="#7-小结-2">7 小结</a></li>
</ul>
<h3 id="sensorcameradepth">第九章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#depth-camera">深度相机传感器</a> （sensor.camera.depth）</h3>
<ul>
<li>
<p><a href="#第九章carla-深度图摄像头传感器系统sensorcameradepth">第九章：CARLA 深度图摄像头传感器系统（sensor.camera.depth）</a></p>
</li>
<li>
<p><a href="#1-模块概览-8">1 模块概览</a></p>
</li>
<li><a href="#2-成像原理与深度编码">2 成像原理与深度编码</a></li>
<li><a href="#3-数据结构说明">3 数据结构说明</a></li>
<li><a href="#4-序列化与解码流程">4 序列化与解码流程</a></li>
<li><a href="#5-python-api-使用示例-6">5 Python API 使用示例</a></li>
<li><a href="#6-深度图应用场景">6 深度图应用场景</a></li>
<li><a href="#7-小结-3">7 小结</a></li>
</ul>
<h3 id="sensorcamerasemantic_segmentation">第十章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#semantic-segmentation-camera">语义分割相机传感器</a>（sensor.camera.semantic_segmentation）</h3>
<ul>
<li>
<p><a href="#第十章carla-语义分割摄像头传感器系统sensorcamerasemantic_segmentation">第十章：CARLA 语义分割摄像头传感器系统（sensor.camera.semantic_segmentation）</a></p>
</li>
<li>
<p><a href="#1-模块概览-9">1 模块概览</a></p>
</li>
<li><a href="#2-输出内容与标签定义">2 输出内容与标签定义</a></li>
<li><a href="#3-数据结构与格式说明">3 数据结构与格式说明</a></li>
<li><a href="#4-序列化机制说明-1">4 序列化机制说明</a></li>
<li><a href="#5-python-api-使用示例-7">5 Python API 使用示例</a></li>
<li><a href="#6-应用与扩展方向">6 应用与扩展方向</a></li>
<li><a href="#7-小结-4">7 小结</a></li>
</ul>
<h3 id="sensorradarray_cast">第十一章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#radar-sensor">雷达传感器</a>（sensor.radar.ray_cast）</h3>
<ul>
<li>
<p><a href="#第十一章carla-雷达传感器系统sensorradarray_cast">第十一章：CARLA 雷达传感器系统（sensor.radar.ray_cast）</a></p>
</li>
<li>
<p><a href="#1-模块概览-10">1 模块概览</a></p>
</li>
<li><a href="#2-扫描原理与数据描述">2 扫描原理与数据描述</a></li>
<li><a href="#3-数据结构解析radardetection">3 数据结构解析：RadarDetection</a></li>
<li><a href="#4-序列化与传输机制">4 序列化与传输机制</a></li>
<li><a href="#5-python-api-使用示例-8">5 Python API 使用示例</a></li>
<li><a href="#6-应用与对比分析">6 应用与对比分析</a></li>
<li><a href="#7-小结-5">7 小结</a></li>
</ul>
<h3 id="sensorotherrss">第十二章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#rss-sensor">责任敏感安全传感器</a>（sensor.other.rss）</h3>
<ul>
<li>
<p><a href="#第十二章carla-rss-责任敏感安全传感器系统sensorotherrss">第十二章：CARLA RSS 责任敏感安全传感器系统（sensor.other.rss）</a></p>
</li>
<li>
<p><a href="#1-模块概览-11">1 模块概览</a></p>
</li>
<li><a href="#2-rss-模型简介与传感器原理">2 RSS 模型简介与传感器原理</a></li>
<li><a href="#3-数据结构说明rssresponse">3 数据结构说明：RssResponse</a></li>
<li><a href="#4-序列化与触发机制">4 序列化与触发机制</a></li>
<li><a href="#5-python-api-使用示例-9">5 Python API 使用示例</a></li>
<li><a href="#6-应用案例与扩展分析">6 应用案例与扩展分析</a></li>
<li><a href="#7-小结-6">7 小结</a></li>
</ul>
<hr />
<h1 id="sensorothercollision_1">第一章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#collision-detector">碰撞事件传感器</a>（sensor.other.collision）</h1>
<hr />
<h2 id="1">1 模块概览</h2>
<p><img alt="flowchart_1.png" src="../../img/modules/flowchart_1.png" /></p>
<p>本章详细讲解 CARLA 模拟器中的一类简单传感器：<code>sensor.other.collision</code>，即碰撞事件传感器。该传感器不输出连续的数据流信息，而是在检测到实体碰撞时以事件形式即时触发。其设计初衷是为用户提供车辆与环境中其他对象之间物理交互的监控能力。</p>
<p>在自动驾驶仿真、强化学习安全评估或碰撞规避算法验证中，<code>sensor.other.collision</code> 提供了关键的反馈信号。通过对其数据结构、序列化机制与客户端回调触发流程的深入解析，可全面理解该传感器在 CARLA 感知系统中的运行机制及其工程实现。</p>
<hr />
<h2 id="2">2 传感器注册与调用原理</h2>
<p>CARLA 所有传感器，包括 <code>sensor.other.collision</code>，均基于统一的 Actor 注册与绑定框架。其创建与工作流程可分为以下几个核心阶段：</p>
<ul>
<li><strong>蓝图注册阶段</strong>：CARLA 所有传感器类型在 Unreal Engine 的蓝图系统中定义，供客户端调用。</li>
<li><strong>Actor 创建阶段</strong>：Python 客户端通过 <code>world.spawn_actor()</code> 创建 <code>"sensor.other.collision"</code> 实例。</li>
<li><strong>传感器通道建立</strong>：Actor 自动绑定底层的 <code>SensorData</code> 数据类型，用户通过 <code>.listen()</code> 注册事件处理函数。</li>
<li><strong>事件触发与传输机制</strong>：</li>
<li>服务端生成 <code>CollisionEvent</code> 事件（Bullet 引擎）</li>
<li>使用 <a href="https://github.com/OpenHUTB/carla_cpp/blob/dev/LibCarla/source/carla/sensor/s11n/CollisionEventSerializer.h"><code>CollisionEventSerializer</code></a> 编码为 <code>RawData</code></li>
<li>通过 RPC 网络发送</li>
<li>客户端使用 <code>Deserialize()</code> 解码为 <code>SensorData</code></li>
<li>注入回调函数中进行处理
该流程构成事件捕捉 → 数据序列化 → 网络传输 → 解码还原 → 客户端处理的完整通路。</li>
</ul>
<hr />
<h2 id="3-collisionevent">3 数据结构：CollisionEvent</h2>
<p>定义文件：<a href="https://github.com/OpenHUTB/carla_cpp/blob/dev/LibCarla/source/carla/sensor/data/CollisionEvent.h"><code>carla/sensor/data/CollisionEvent.h</code></a></p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">CollisionEvent</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">self_actor</span><span class="p">;</span>
<span class="w">  </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">other_actor</span><span class="p">;</span>
<span class="w">  </span><span class="n">geom</span><span class="o">::</span><span class="n">Vector3D</span><span class="w"> </span><span class="n">normal_impulse</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<ul>
<li><code>self_actor</code>：传感器附着实体（如车辆）</li>
<li><code>other_actor</code>：碰撞对象（如障碍物、NPC）</li>
<li><code>normal_impulse</code>：冲击力矢量，反映碰撞强度与方向</li>
</ul>
<hr />
<h2 id="4-collisioneventserializer">4 序列化器分析：CollisionEventSerializer</h2>
<p>定义文件：<br />
<a href="https://github.com/OpenHUTB/carla_cpp/blob/dev/LibCarla/source/carla/sensor/s11n/CollisionEventSerializer.h"><code>CollisionEventSerializer.h</code></a><br />
<a href="https://github.com/OpenHUTB/carla_cpp/blob/dev/LibCarla/source/carla/sensor/s11n/CollisionEventSerializer.cpp"><code>CollisionEventSerializer.cpp</code></a></p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Data</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">self_actor</span><span class="p">;</span>
<span class="w">  </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">other_actor</span><span class="p">;</span>
<span class="w">  </span><span class="n">geom</span><span class="o">::</span><span class="n">Vector3D</span><span class="w"> </span><span class="n">normal_impulse</span><span class="p">;</span>
<span class="w">  </span><span class="n">MSGPACK_DEFINE_ARRAY</span><span class="p">(</span><span class="n">self_actor</span><span class="p">,</span><span class="w"> </span><span class="n">other_actor</span><span class="p">,</span><span class="w"> </span><span class="n">normal_impulse</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">SensorT</span><span class="o">&gt;</span>
<span class="k">static</span><span class="w"> </span><span class="n">Buffer</span><span class="w"> </span><span class="n">Serialize</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SensorT</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span>
<span class="w">    </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">self_actor</span><span class="p">,</span>
<span class="w">    </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">other_actor</span><span class="p">,</span>
<span class="w">    </span><span class="n">geom</span><span class="o">::</span><span class="n">Vector3D</span><span class="w"> </span><span class="n">normal_impulse</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">MsgPack</span><span class="o">::</span><span class="n">Pack</span><span class="p">(</span><span class="n">Data</span><span class="p">{</span><span class="n">self_actor</span><span class="p">,</span><span class="w"> </span><span class="n">other_actor</span><span class="p">,</span><span class="w"> </span><span class="n">normal_impulse</span><span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">SharedPtr</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Deserialize</span><span class="p">(</span><span class="n">RawData</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SharedPtr</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">data</span><span class="o">::</span><span class="n">CollisionEvent</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div>
<hr />
<h2 id="5-rawdata-sensordata">5 RawData 与 SensorData 概述</h2>
<p>数据结构定义：<br />
<a href="https://github.com/OpenHUTB/carla_cpp/blob/dev/LibCarla/source/carla/sensor/RawData.h"><code>RawData.h</code></a><br />
<a href="https://github.com/OpenHUTB/carla_cpp/blob/dev/LibCarla/source/carla/sensor/SensorData.h"><code>SensorData.h</code></a></p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">RawData</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">GetFrame</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="nf">GetTimestamp</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">rpc</span><span class="o">::</span><span class="n">Transform</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">GetSensorTransform</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="nf">begin</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SensorData</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">EnableSharedFromThis</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="k">private</span><span class="w"> </span><span class="n">NonCopyable</span><span class="w"> </span><span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
<span class="w">  </span><span class="n">SensorData</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">timestamp</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">rpc</span><span class="o">::</span><span class="n">Transform</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sensor_transform</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>
<hr />
<h2 id="6-python-api">6 Python API 使用示例</h2>
<p>参考文件：<a href="https://github.com/OpenHUTB/carla_doc/blob/dev/src/examples/collision_sensor.py"><code>collision_sensor.py</code></a></p>
<div class="highlight"><pre><span></span><code>def on_collision(event):
    actor = event.other_actor
    impulse = event.normal_impulse
    print(f&quot;发生碰撞！对象类型：{actor.type_id}，冲击向量：{impulse}&quot;)
</code></pre></div>
<div class="highlight"><pre><span></span><code>blueprint_library = world.get_blueprint_library()
bp = blueprint_library.find(&#39;sensor.other.collision&#39;)
transform = carla.Transform(carla.Location(x=0, y=0, z=2.0))
sensor = world.spawn_actor(bp, transform, attach_to=vehicle)
sensor.listen(on_collision)
</code></pre></div>
<hr />
<h2 id="7">7 小结与拓展</h2>
<ul>
<li><code>sensor.other.collision</code> 是轻量、事件驱动的传感器</li>
<li>使用 <code>MsgPack + RawData</code> 组合，编码效率高</li>
<li>常用于：碰撞检测、事故分析、惩罚信号生成</li>
</ul>
<h3 id="_1">可拓展方向：</h3>
<ul>
<li>增加字段（如速度向量、碰撞位置）</li>
<li>结合图像、GNSS 数据实现回溯系统</li>
<li>与强化学习结合生成动态规避策略</li>
</ul>
<hr />
<h1 id="carla-sensorothernoop">第二章：CARLA 空传感器系统（sensor.other.noop）</h1>
<hr />
<h2 id="1_1">1 模块概览</h2>
<p><img alt="flowchart_2.png" src="../../img/modules/flowchart_2.png" /></p>
<p>本章介绍 CARLA 模拟器中最为简化的一类传感器：<code>sensor.other.noop</code>，即“无操作传感器”（No-Operation Sensor）。顾名思义，该传感器不会向客户端发送任何数据，其存在的意义更多是作为客户端挂载传感器的占位符、功能测试器或新传感器开发的最小模板。</p>
<p><code>sensor.other.noop</code> 适用于以下场景：</p>
<ul>
<li>构建新型传感器时的起始模板；</li>
<li>用于网络与回调机制调试，无需实际数据；</li>
<li>占位传感器（需要绑定但暂时不产出数据）；</li>
<li>模拟传感器失败或无响应场景下的系统行为。</li>
</ul>
<p>其核心特征是：<strong>不参与数据流的任何阶段</strong>，服务端不会推送数据，客户端接收到数据则立即报错。</p>
<hr />
<h2 id="2_1">2 传感器注册与调用原理</h2>
<p><code>sensor.other.noop</code> 遵循 CARLA 所有传感器统一的注册、挂载、通信框架，其调用流程包括以下几个阶段：</p>
<ul>
<li><strong>蓝图注册阶段</strong>：该传感器在 Unreal Engine 蓝图系统中以 <code>"sensor.other.noop"</code> 注册，蓝图库中包含其类型定义。</li>
<li><strong>Actor 创建阶段</strong>：客户端通过 <code>world.spawn_actor()</code> 创建该传感器实例，传入 <code>"sensor.other.noop"</code> 字符串作为蓝图 ID，实例可附着至车辆或动态对象。</li>
<li><strong>传感器监听绑定</strong>：</li>
<li>可通过 <code>.listen()</code> 注册 Python 回调函数；</li>
<li>但由于此传感器不会生成任何事件，回调函数永远不会被实际调用；</li>
<li>若数据进入系统，将由序列化器直接拒绝并抛出异常。</li>
</ul>
<hr />
<h2 id="3-noopserializer">3 序列化器分析：NoopSerializer</h2>
<p>该序列化器专为“客户端不接收数据”的传感器设计，核心逻辑是禁止任何数据反序列化。</p>
<h3 id="31">3.1 接口定义</h3>
<div class="highlight"><pre><span></span><code><span class="c1">/// Dummy serializer that blocks all the data.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">NoopSerializer</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="p">[[</span><span class="n">noreturn</span><span class="p">]]</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">SharedPtr</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Deserialize</span><span class="p">(</span><span class="n">RawData</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">data</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>
<p>说明：</p>
<ul>
<li><code>[[noreturn]]</code> 是 C++11 标准修饰符，表示该函数永不返回；</li>
<li>调用该函数将抛出异常，标志该传感器设计为“不可反序列化”。</li>
</ul>
<h3 id="32">3.2 函数实现</h3>
<div class="highlight"><pre><span></span><code><span class="n">SharedPtr</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">NoopSerializer</span><span class="o">::</span><span class="n">Deserialize</span><span class="p">(</span><span class="n">RawData</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">throw_exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;NoopSerializer: Invalid data received.&quot;</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p>说明：</p>
<ul>
<li>使用 CARLA 提供的 <code>throw_exception</code> 工具函数；</li>
<li>一旦客户端尝试处理此类型数据，即触发中断错误；</li>
<li>该机制确保 <code>sensor.other.noop</code> 无法被误用。</li>
</ul>
<hr />
<h2 id="4">4 数据结构与传输机制</h2>
<p>该传感器不绑定任何结构化数据类型：</p>
<ul>
<li>不包含自定义数据结构（如 <code>NoopEvent</code>）；</li>
<li>不通过 <code>RawData</code> 传输任何内容；</li>
<li>无有效 <code>SensorData</code> 派生类实例生成；</li>
<li>虽然支持 <code>.listen()</code> 注册机制，但永不触发。</li>
</ul>
<p>因此，<code>sensor.other.noop</code> 是一种“存在但不发声”的传感器，仅用于挂载占位或调试目的。</p>
<hr />
<h2 id="5-python-api">5 Python API 使用示例</h2>
<p>虽然该传感器不传输数据，仍可正常在 Python 中创建与注册监听。</p>
<div class="highlight"><pre><span></span><code># 定义回调函数（注意：不会被调用）
def on_noop_event(event):
    print(&quot;此处不应出现任何输出&quot;)

# 获取蓝图库并查找蓝图
bp = world.get_blueprint_library().find(&#39;sensor.other.noop&#39;)

# 设置传感器相对位置
transform = carla.Transform(carla.Location(x=0, y=0, z=2.0))

# 创建传感器并附着至车辆
noop_sensor = world.spawn_actor(bp, transform, attach_to=vehicle)

# 注册监听函数（将不会触发）
noop_sensor.listen(on_noop_event)
</code></pre></div>
<p><strong>可选调试建议</strong>：</p>
<ul>
<li>可用日志验证传感器挂载成功；</li>
<li>可调用 <code>.destroy()</code> 观察销毁逻辑；</li>
<li>可组合多个传感器观察 <code>.listen()</code> 机制行为。</li>
</ul>
<hr />
<h2 id="6">6 小结与拓展</h2>
<ul>
<li><code>sensor.other.noop</code> 是 CARLA 中结构最简、用途最特殊的一类传感器；</li>
<li>其核心设计目的是：禁止数据流通，仅做占位和调试；</li>
<li>非常适合作为自定义传感器的开发模板或序列化链测试工具。</li>
</ul>
<h3 id="_2">拓展建议：</h3>
<ul>
<li>作为新事件传感器的起点模板；</li>
<li>用于测试 <code>.listen()</code> 和 <code>.destroy()</code> 回调流程；</li>
<li>模拟传感器故障、异常或丢包处理机制；</li>
<li>可组合图像、IMU 等实际传感器测试是否发生调用竞争或系统冲突。</li>
</ul>
<hr />
<h1 id="sensorotherimu_1">第三章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#imu-sensor">惯性测量单元传感器</a> （sensor.other.imu）</h1>
<hr />
<h2 id="1_2">1 模块概览</h2>
<p><img alt="flowchart_3.png" src="../../img/modules/flowchart_3.png" /></p>
<p><code>sensor.other.imu</code> 是 CARLA 提供的惯性测量单元（IMU）传感器，用于捕捉车辆的三维加速度、角速度及方向信息，广泛应用于轨迹估计、姿态解算、导航融合等自动驾驶仿真任务中。</p>
<p>该传感器会周期性发送事件，传递以下数据：</p>
<ul>
<li><strong>加速度计</strong>：三轴加速度 <code>Vector3D(x, y, z)</code>，单位 m/s²</li>
<li><strong>陀螺仪</strong>：三轴角速度 <code>Vector3D(x, y, z)</code>，单位 rad/s</li>
<li><strong>罗盘</strong>：航向角（方向朝向），单位弧度</li>
</ul>
<p>默认以 20Hz 更新频率输出，支持在蓝图中调整采样速率。</p>
<hr />
<h2 id="2_2">2 工作流程与序列化机制</h2>
<p>IMU 传感器的数据流程如下：</p>
<ol>
<li><strong>事件捕获</strong>：模拟器服务端采集当前帧的 IMU 数据</li>
<li><strong>数据序列化</strong>：使用 <code>IMUSerializer</code> 将加速度、角速度与罗盘值打包为 MsgPack 编码字节流（参见 <code>IMUSerializer.h/.cpp</code>）</li>
<li><strong>网络传输</strong>：打包后的 <code>RawData</code> 通过 RPC 系统传输至客户端</li>
<li><strong>数据还原</strong>：客户端通过 <code>IMUMeasurement</code> 类将字节流还原为结构化对象</li>
<li><strong>回调触发</strong>：Python 层注册的 <code>.listen()</code> 回调函数获得该事件并执行处理逻辑</li>
</ol>
<hr />
<h2 id="3">3 数据结构详解</h2>
<p>IMU 数据通过 <code>IMUMeasurement</code> 类对外暴露，定义位置：</p>
<p>📄 <a href="https://github.com/carla-simulator/carla/blob/dev/LibCarla/source/carla/sensor/data/IMUMeasurement.h"><code>carla/sensor/data/IMUMeasurement.h</code></a></p>
<p>该类封装如下：</p>
<div class="highlight"><pre><span></span><code>class IMUMeasurement : public SensorData {
public:
  geom::Vector3D GetAccelerometer() const;
  geom::Vector3D GetGyroscope() const;
  float GetCompass() const;
};
</code></pre></div>
<ul>
<li><strong>加速度</strong>：IMU 加速度计测得的三轴值</li>
<li><strong>角速度</strong>：陀螺仪角速度</li>
<li><strong>罗盘值</strong>：航向角（通常为 0\~2π 的弧度）</li>
</ul>
<p>所有字段通过 <code>IMUSerializer::Deserialize()</code> 方法从 <code>RawData</code> 还原，序列化结构如下：</p>
<div class="highlight"><pre><span></span><code>struct IMUData {
  Vector3D accelerometer;
  Vector3D gyroscope;
  float compass;
};
</code></pre></div>
<p>通过 <code>MSGPACK_DEFINE_ARRAY(acc, gyro, compass)</code> 支持 MsgPack 自动编码。</p>
<hr />
<h2 id="4-python-api">4 Python API 调用示例</h2>
<p>以下代码展示如何部署 IMU 传感器、注册监听器，并处理接收到的数据：</p>
<div class="highlight"><pre><span></span><code>def on_imu(event):
    acc = event.accelerometer
    gyro = event.gyroscope
    compass = event.compass
    print(f&quot;[IMU] 加速度: {acc} | 角速度: {gyro} | 罗盘: {compass}&quot;)

# 创建传感器
bp = world.get_blueprint_library().find(&#39;sensor.other.imu&#39;)
transform = carla.Transform(carla.Location(x=0, y=0, z=1.0))
imu_sensor = world.spawn_actor(bp, transform, attach_to=vehicle)
imu_sensor.listen(on_imu)
</code></pre></div>
<hr />
<h2 id="5">5 拓展用例与集成应用</h2>
<p>IMU 常与 GNSS、相机、雷达等传感器联用，实现高级状态估计：</p>
<p><strong>与 GNSS 融合：</strong></p>
<div class="highlight"><pre><span></span><code>def on_gnss(gnss):
    print(f&quot;[GNSS] 纬度: {gnss.latitude}, 经度: {gnss.longitude}&quot;)

imu_sensor.listen(on_imu)
gnss_sensor.listen(on_gnss)
</code></pre></div>
<p><strong>估算车辆速度（积分法，简化示例）：</strong></p>
<div class="highlight"><pre><span></span><code>velocity = carla.Vector3D()

def on_imu_integration(imu):
    global velocity
    dt = 0.05  # 默认 20Hz
    a = imu.accelerometer
    velocity.x += a.x * dt
    velocity.y += a.y * dt
    velocity.z += a.z * dt
    print(f&quot;估算速度: {velocity}&quot;)
</code></pre></div>
<hr />
<h2 id="6_1">6 限制与对比分析</h2>
<table>
<thead>
<tr>
<th>属性</th>
<th>CARLA IMU</th>
<th>真实 IMU（如 Xsens）</th>
</tr>
</thead>
<tbody>
<tr>
<td>更新频率</td>
<td>默认 20Hz，可调</td>
<td>最高 &gt; 1000Hz</td>
</tr>
<tr>
<td>噪声建模</td>
<td>默认无噪声</td>
<td>含偏置、漂移等随机扰动</td>
</tr>
<tr>
<td>时间同步</td>
<td>自动与仿真对齐</td>
<td>需硬件级时间戳</td>
</tr>
<tr>
<td>数据输出</td>
<td>无 CSV 导出</td>
<td>支持标准格式</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="7_1">7 总结与建议</h2>
<ul>
<li><code>sensor.other.imu</code> 提供结构清晰、易用的姿态/运动状态反馈能力；</li>
<li>可拓展为带噪模型、加权滤波、数据融合平台；</li>
<li>建议与 <code>sensor.other.gnss</code>、<code>sensor.camera.rgb</code> 联合使用，支持轨迹分析、三维重建等研究任务；</li>
<li>后续可引入 IMU 噪声模拟模块、数据导出功能。</li>
</ul>
<hr />
<h1 id="sensorothergnss_1">第四章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#gnss-sensor">全球导航卫星系统传感器</a> （sensor.other.gnss）</h1>
<hr />
<h2 id="1_3">1 模块概览</h2>
<p><img alt="flowchart_4.png" src="../../img/modules/flowchart_4.png" /></p>
<p><code>sensor.other.gnss</code> 是 CARLA 中用于获取地理位置信息的传感器，模拟真实世界中的全球导航卫星系统（GNSS）设备，如 GPS、北斗等。传感器输出包括：</p>
<ul>
<li><strong>经度（longitude）</strong>：单位°，范围 $-180°, 180°$</li>
<li><strong>纬度（latitude）</strong>：单位°，范围 $-90°, 90°$</li>
<li><strong>海拔（altitude）</strong>：单位为米，代表相对于海平面的高度</li>
</ul>
<p>该传感器可用于场景定位、路径重建、轨迹分析等仿真任务中，常与 IMU、地图匹配模块联合使用。</p>
<hr />
<h2 id="2_3">2 工作流程与传输机制</h2>
<p>GNSS 的数据传输流程如下：</p>
<ol>
<li><strong>事件生成</strong>：服务端在当前仿真帧中生成地理位置信息</li>
<li><strong>数据打包</strong>：通过 <code>GnssSerializer</code> 将 <code>GeoLocation</code> 序列化为 MsgPack 格式的 <code>RawData</code></li>
<li><strong>网络传输</strong>：打包后的字节流通过 CARLA 的 RPC 系统发送给客户端</li>
<li><strong>数据还原</strong>：客户端使用 <code>GnssMeasurement</code> 类解码 <code>RawData</code>，得到结构化数据</li>
<li><strong>Python 层监听</strong>：<code>.listen()</code> 接口注册的函数在每次更新中触发回调</li>
</ol>
<hr />
<h2 id="3_1">3 数据结构解析</h2>
<p>定义位置：<a href="https://github.com/OpenHUTB/carla_cpp/blob/dev/LibCarla/source/carla/sensor/data/GnssMeasurement.h"><code>GnssMeasurement.h</code></a></p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">GnssMeasurement</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">SensorData</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">geom</span><span class="o">::</span><span class="n">GeoLocation</span><span class="w"> </span><span class="n">GetGeoLocation</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="nf">GetLongitude</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="nf">GetLatitude</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="nf">GetAltitude</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>其中：</p>
<ul>
<li><code>GeoLocation</code> 结构体封装了 <code>{ longitude, latitude, altitude }</code></li>
<li>每帧更新一次，数据来源为服务端环境模拟的车辆真实位置信息</li>
</ul>
<p>默认输出单位为：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>Longitude</td>
<td>double</td>
<td>度（°）</td>
</tr>
<tr>
<td>Latitude</td>
<td>double</td>
<td>度（°）</td>
</tr>
<tr>
<td>Altitude</td>
<td>double</td>
<td>米（m）</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="4_1">4 序列化机制分析</h2>
<p>定义文件：
<a href="https://github.com/OpenHUTB/carla_cpp/blob/dev/LibCarla/source/carla/sensor/s11n/GnssSerializer.h"><code>GnssSerializer.h</code></a>
<a href="https://github.com/OpenHUTB/carla_cpp/blob/dev/LibCarla/source/carla/sensor/s11n/GnssSerializer.cpp"><code>GnssSerializer.cpp</code></a></p>
<div class="highlight"><pre><span></span><code><span class="c1">// 客户端解码逻辑</span>
<span class="n">SharedPtr</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GnssSerializer</span><span class="o">::</span><span class="n">Deserialize</span><span class="p">(</span><span class="n">RawData</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SharedPtr</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">data</span><span class="o">::</span><span class="n">GnssMeasurement</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div>
<p>序列化结构体使用 <code>MSGPACK_DEFINE_ARRAY</code> 自动完成：</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">GeoLocation</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">latitude</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">longitude</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">altitude</span><span class="p">;</span>
<span class="w">  </span><span class="n">MSGPACK_DEFINE_ARRAY</span><span class="p">(</span><span class="n">latitude</span><span class="p">,</span><span class="w"> </span><span class="n">longitude</span><span class="p">,</span><span class="w"> </span><span class="n">altitude</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div>
<p>该机制保证 GNSS 数据体积小、解码快，适合高频传输与跨语言兼容。</p>
<hr />
<h2 id="5-python-api_1">5 Python API 使用示例</h2>
<div class="highlight"><pre><span></span><code><span class="c1"># 定义回调函数</span>
<span class="k">def</span> <span class="nf">on_gnss</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">latitude</span>
    <span class="n">lon</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">longitude</span>
    <span class="n">alt</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">altitude</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GNSS] 纬度: </span><span class="si">{</span><span class="n">lat</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">, 经度: </span><span class="si">{</span><span class="n">lon</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">, 海拔: </span><span class="si">{</span><span class="n">alt</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">m&quot;</span><span class="p">)</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1"># 创建并绑定传感器</span>
<span class="n">bp</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">get_blueprint_library</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;sensor.other.gnss&#39;</span><span class="p">)</span>
<span class="n">transform</span> <span class="o">=</span> <span class="n">carla</span><span class="o">.</span><span class="n">Transform</span><span class="p">(</span><span class="n">carla</span><span class="o">.</span><span class="n">Location</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mf">1.6</span><span class="p">))</span>
<span class="n">gnss_sensor</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">spawn_actor</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">attach_to</span><span class="o">=</span><span class="n">vehicle</span><span class="p">)</span>
<span class="n">gnss_sensor</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="n">on_gnss</span><span class="p">)</span>
</code></pre></div>
<p>可选蓝图参数（<code>bp.set_attribute(...)</code>）包括：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sensor_tick</code></td>
<td>传感器更新时间（秒）</td>
<td><code>0.05</code></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="6_2">6 应用拓展与组合使用</h2>
<p>GNSS 传感器常用于以下场景：</p>
<ul>
<li><strong>路径重建</strong>：记录车辆运行轨迹用于回放</li>
<li><strong>定位精度验证</strong>：与地图匹配算法结合测试鲁棒性</li>
<li><strong>IMU + GNSS 融合</strong>：实现基于扩展卡尔曼滤波（EKF）的定位</li>
</ul>
<h3 id="gnss-imu">示例：GNSS 与 IMU 联合使用</h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_fused_data</span><span class="p">(</span><span class="n">gnss</span><span class="p">,</span> <span class="n">imu</span><span class="p">):</span>
    <span class="n">location</span> <span class="o">=</span> <span class="p">(</span><span class="n">gnss</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span> <span class="n">gnss</span><span class="o">.</span><span class="n">longitude</span><span class="p">)</span>
    <span class="n">acceleration</span> <span class="o">=</span> <span class="n">imu</span><span class="o">.</span><span class="n">accelerometer</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[FUSION] 坐标: </span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">, 加速度: </span><span class="si">{</span><span class="n">acceleration</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
<p>该模式可用于轨迹重建、地理围栏检测、自动驾驶行为控制等任务。</p>
<hr />
<h2 id="7_2">7 总结与建议</h2>
<ul>
<li><code>sensor.other.gnss</code> 提供高精度地理位置信息，是自动驾驶仿真系统中的关键模块；</li>
<li>与 IMU、摄像头、地图等配合可实现高级 SLAM 与定位算法验证；</li>
<li>若需实现更真实的模型，可拓展添加噪声模型、地形遮挡、信号丢失模拟等功能。</li>
</ul>
<hr />
<h1 id="sensorotherlane_invasion_1">第五章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#lane-invasion-detector">车道入侵传感器系统</a> （sensor.other.lane_invasion）</h1>
<hr />
<h2 id="1_4">1 模块概览</h2>
<p><img alt="flowchart_5.png" src="../../img/modules/flowchart_5.png" />
<code>sensor.other.lane_invasion</code> 是 CARLA 提供的一类事件型传感器，用于监测车辆是否跨越车道线。该传感器在每次检测到入侵车道标线时触发事件，并将跨越的车道线类型（如实线、虚线）以枚举列表形式返回。</p>
<p>在自动驾驶安全策略、强化学习训练以及车道保持辅助系统（LKA）中，<code>lane_invasion</code> 传感器常用于实现惩罚反馈、路径修正与轨迹约束。</p>
<hr />
<h2 id="2_4">2 检测流程与回调机制</h2>
<p>其工作流程为：</p>
<ol>
<li><strong>服务端</strong>：由地图模块检测当前车辆是否偏离其预定车道；</li>
<li><strong>事件触发</strong>：若检测到跨越车道线，则生成 <code>LaneInvasionEvent</code> 实例；</li>
<li><strong>数据打包</strong>：使用 <code>LaneInvasionEventSerializer</code> 将入侵线类型序列化为 <code>RawData</code>；</li>
<li><strong>网络传输</strong>：通过 RPC 系统发送至客户端；</li>
<li><strong>Python 接收</strong>：回调函数被 <code>.listen()</code> 注册监听，获取并解析车道入侵信息。</li>
</ol>
<hr />
<h2 id="3-laneinvasionevent">3 数据结构：LaneInvasionEvent</h2>
<p>定义文件：<a href="https://github.com/carla-simulator/carla/blob/dev/LibCarla/source/carla/sensor/data/LaneInvasionEvent.h"><code>carla/sensor/data/LaneInvasionEvent.h</code></a></p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">LaneInvasionEvent</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">actor</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">rpc</span><span class="o">::</span><span class="n">LaneMarking</span><span class="o">&gt;</span><span class="w"> </span><span class="n">crossed_lane_markings</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<ul>
<li><code>actor</code>：车辆自身 Actor 实例；</li>
<li><code>crossed_lane_markings</code>：当前帧中车辆所跨越的所有车道线类型（可为多个），类型为枚举，如 <code>Broken</code>, <code>Solid</code>, <code>DoubleSolid</code> 等。</li>
</ul>
<p>该结构紧凑、频次高，适合用于连续动态监测。</p>
<hr />
<h2 id="4_2">4 序列化机制分析</h2>
<p>定义文件：
<a href="https://github.com/carla-simulator/carla/blob/dev/LibCarla/source/carla/sensor/s11n/LaneInvasionEventSerializer.h"><code>LaneInvasionEventSerializer.h</code></a>
<a href="https://github.com/carla-simulator/carla/blob/dev/LibCarla/source/carla/sensor/s11n/LaneInvasionEventSerializer.cpp"><code>LaneInvasionEventSerializer.cpp</code></a></p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Data</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">actor</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">rpc</span><span class="o">::</span><span class="n">LaneMarking</span><span class="o">&gt;</span><span class="w"> </span><span class="n">markings</span><span class="p">;</span>
<span class="w">  </span><span class="n">MSGPACK_DEFINE_ARRAY</span><span class="p">(</span><span class="n">actor</span><span class="p">,</span><span class="w"> </span><span class="n">markings</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">SensorT</span><span class="o">&gt;</span>
<span class="k">static</span><span class="w"> </span><span class="n">Buffer</span><span class="w"> </span><span class="n">Serialize</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SensorT</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">actor</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">rpc</span><span class="o">::</span><span class="n">LaneMarking</span><span class="o">&gt;</span><span class="w"> </span><span class="n">markings</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">MsgPack</span><span class="o">::</span><span class="n">Pack</span><span class="p">(</span><span class="n">Data</span><span class="p">{</span><span class="n">actor</span><span class="p">,</span><span class="w"> </span><span class="n">markings</span><span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">SharedPtr</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Deserialize</span><span class="p">(</span><span class="n">RawData</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SharedPtr</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">data</span><span class="o">::</span><span class="n">LaneInvasionEvent</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div>
<p>说明：</p>
<ul>
<li>序列化结构以 Actor + 多个 LaneMarking 构成，采用 MsgPack 自动打包；</li>
<li><code>RawData</code> 解码后重建 <code>LaneInvasionEvent</code> 对象并回调处理。</li>
</ul>
<hr />
<h2 id="5-python-api_2">5 Python API 使用示例</h2>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_lane_invasion</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="n">markings</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">crossed_lane_markings</span>
    <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">markings</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[LANE INVASION] 跨越线型: </span><span class="si">{</span><span class="n">types</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># 注册传感器</span>
<span class="n">bp</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">get_blueprint_library</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;sensor.other.lane_invasion&#39;</span><span class="p">)</span>
<span class="n">transform</span> <span class="o">=</span> <span class="n">carla</span><span class="o">.</span><span class="n">Transform</span><span class="p">(</span><span class="n">carla</span><span class="o">.</span><span class="n">Location</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mf">1.0</span><span class="p">))</span>
<span class="n">sensor</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">spawn_actor</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">attach_to</span><span class="o">=</span><span class="n">vehicle</span><span class="p">)</span>
<span class="n">sensor</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="n">on_lane_invasion</span><span class="p">)</span>
</code></pre></div>
<hr />
<h2 id="6_3">6 应用案例与拓展建议</h2>
<p>该传感器在以下任务中具有实用价值：</p>
<ul>
<li><strong>行为评估</strong>：在强化学习中作为负反馈信号（lane penalty）；</li>
<li><strong>轨迹控制</strong>：实时检测偏离车道行为，启用修正或报警；</li>
<li><strong>回放分析</strong>：结合 IMU、摄像头数据，回溯偏航过程；</li>
<li><strong>车道建模验证</strong>：辅助验证 HD Map 与车辆车道感知的精度一致性。</li>
</ul>
<p>拓展建议：</p>
<ul>
<li>与 IMU、GNSS 联合，用于重建入侵轨迹与偏离角度；</li>
<li>支持配置忽略特定线型（如仅监控实线跨越）；</li>
<li>将入侵事件导出为 CSV/JSON 用于行为可视化分析。</li>
</ul>
<hr />
<h2 id="7_3">7 小结</h2>
<ul>
<li><code>sensor.other.lane_invasion</code> 是 CARLA 中重要的语义事件传感器；</li>
<li>它以低带宽方式提供关键路径偏离信息，适用于控制反馈与安全分析；</li>
<li>未来可与地图标注、规划模块更深度融合，支持高精轨迹约束与驾驶决策研究。</li>
</ul>
<hr />
<h1 id="sensorlidarray_cast_1">第六章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#lidar-sensor">激光雷达传感器系统</a> （sensor.lidar.ray_cast）</h1>
<hr />
<h2 id="1_5">1 模块概览</h2>
<p><img alt="flowchart_6.png" src="../../img/modules/flowchart_6.png" /></p>
<p><code>sensor.lidar.ray_cast</code> 是 CARLA 模拟器中最常用的激光雷达传感器，基于光线投射（ray casting）机制模拟真实 LiDAR 装置的点云采集过程。它可高效模拟不同线数、角度、旋转频率和噪声模型的激光扫描设备（如 Velodyne HDL-64、Ouster OS1 等）。</p>
<p>激光雷达传感器在 3D 感知、环境建图、障碍物检测与路径规划等任务中具有核心地位，其输出为连续的三维点云流数据。</p>
<hr />
<h2 id="2_5">2 工作机制与原理</h2>
<p><code>sensor.lidar.ray_cast</code> 基于服务端的射线仿真实现：</p>
<ol>
<li><strong>光线发射</strong>：每帧从传感器原点按设定参数发射 N 条激光束（扫描线）；</li>
<li><strong>碰撞检测</strong>：光线与场景中可交物体进行交点检测（基于 GPU 加速）；</li>
<li><strong>数据采样</strong>：记录每条光线的命中距离、角度、强度等；</li>
<li><strong>点云生成</strong>：生成形如 <code>[x, y, z, intensity]</code> 的 3D 点云；</li>
<li><strong>数据打包</strong>：打包为 <code>RawData</code>，通过 RPC 网络传输至客户端；</li>
<li><strong>解码还原</strong>：客户端使用 <code>LidarMeasurement</code> 解码并提供访问接口。</li>
</ol>
<p>该传感器支持设定旋转频率、扫描范围、垂直角分布、点密度、噪声模型等，是极为灵活的仿真组件。</p>
<hr />
<h2 id="3_2">3 数据结构与点云格式</h2>
<p>定义文件：<a href="https://github.com/carla-simulator/carla/blob/dev/LibCarla/source/carla/sensor/data/LidarMeasurement.h"><code>carla/sensor/data/LidarMeasurement.h</code></a></p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">LidarDetection</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">         </span><span class="c1">// 点的 X 坐标</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w">         </span><span class="c1">// 点的 Y 坐标</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w">         </span><span class="c1">// 点的 Z 坐标</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">intensity</span><span class="p">;</span><span class="w"> </span><span class="c1">// 回波强度</span>
<span class="p">};</span>
</code></pre></div>
<p>一个完整的扫描周期包含多个 <code>LidarDetection</code> 点，构成一个 <code>LidarMeasurement</code> 实例：</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">LidarMeasurement</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">SensorData</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">LidarDetection</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">at</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">LidarDetection</span><span class="w"> </span><span class="o">*</span><span class="nf">begin</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>每个点均包含空间坐标和强度，单位均为米（<code>m</code>），强度为 0\~1 之间的浮点数。</p>
<hr />
<h2 id="4_3">4 序列化与反序列化流程</h2>
<p>定义文件：
<a href="https://github.com/carla-simulator/carla/blob/dev/LibCarla/source/carla/sensor/s11n/LidarSerializer.h"><code>LidarSerializer.h</code></a>
<a href="https://github.com/carla-simulator/carla/blob/dev/LibCarla/source/carla/sensor/s11n/LidarSerializer.cpp"><code>LidarSerializer.cpp</code></a></p>
<ul>
<li>服务端使用 <code>LidarSerializer::Serialize()</code> 将所有 <code>LidarDetection</code> 数据打包成连续内存块；</li>
<li>客户端通过 <code>LidarMeasurement</code> 构造函数解码：</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">SharedPtr</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">LidarSerializer</span><span class="o">::</span><span class="n">Deserialize</span><span class="p">(</span><span class="n">RawData</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SharedPtr</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">data</span><span class="o">::</span><span class="n">LidarMeasurement</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div>
<p>点云被连续存储为 <code>[float x, y, z, intensity] * N</code> 形式，传输高效，占用带宽较低，适合高频实时仿真。</p>
<hr />
<h2 id="5-python-api_3">5 Python API 示例与配置参数</h2>
<p>以下代码展示如何部署 LiDAR 传感器，并处理点云数据：</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_lidar</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">raw_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[LIDAR] 点数: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="si">}</span><span class="s2">, 第一个点: </span><span class="si">{</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">bp</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">get_blueprint_library</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;sensor.lidar.ray_cast&#39;</span><span class="p">)</span>
<span class="n">bp</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">,</span> <span class="s1">&#39;100.0&#39;</span><span class="p">)</span>
<span class="n">bp</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;rotation_frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;10.0&#39;</span><span class="p">)</span>
<span class="n">bp</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;channels&#39;</span><span class="p">,</span> <span class="s1">&#39;32&#39;</span><span class="p">)</span>
<span class="n">bp</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;points_per_second&#39;</span><span class="p">,</span> <span class="s1">&#39;56000&#39;</span><span class="p">)</span>

<span class="n">transform</span> <span class="o">=</span> <span class="n">carla</span><span class="o">.</span><span class="n">Transform</span><span class="p">(</span><span class="n">carla</span><span class="o">.</span><span class="n">Location</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mf">2.5</span><span class="p">))</span>
<span class="n">lidar_sensor</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">spawn_actor</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">attach_to</span><span class="o">=</span><span class="n">vehicle</span><span class="p">)</span>
<span class="n">lidar_sensor</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="n">on_lidar</span><span class="p">)</span>
</code></pre></div>
<h3 id="_3">常用参数表：</h3>
<table>
<thead>
<tr>
<th>属性名</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>range</code></td>
<td>最大检测距离（m）</td>
<td>50.0</td>
</tr>
<tr>
<td><code>rotation_frequency</code></td>
<td>每秒转速（Hz）</td>
<td>10.0</td>
</tr>
<tr>
<td><code>channels</code></td>
<td>激光线数（垂直）</td>
<td>32</td>
</tr>
<tr>
<td><code>points_per_second</code></td>
<td>点数密度</td>
<td>56000</td>
</tr>
<tr>
<td><code>upper_fov</code>, <code>lower_fov</code></td>
<td>垂直视角上下限（°）</td>
<td>10, -30</td>
</tr>
<tr>
<td><code>sensor_tick</code></td>
<td>更新时间（s）</td>
<td>0.05</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="6_4">6 应用场景与可拓展方向</h2>
<h3 id="_4">应用场景：</h3>
<ul>
<li>3D 点云生成与可视化；</li>
<li>障碍物检测与跟踪（Obstacle Avoidance）；</li>
<li>SLAM/地图构建（建图+定位）；</li>
<li>与摄像头图像对齐进行深度估计；</li>
<li>自动驾驶决策路径验证。</li>
</ul>
<h3 id="_5">拓展方向：</h3>
<ul>
<li>引入激光噪声建模（如距离抖动、散射）；</li>
<li>增加反射材质模拟（如玻璃表面不回波）；</li>
<li>与相机坐标联合投影，实现点云图像融合；</li>
<li>点云导出为 PCD 格式供后处理工具使用（如 Open3D、PCL）。</li>
</ul>
<hr />
<h2 id="7_4">7 总结</h2>
<p><code>sensor.lidar.ray_cast</code> 是 CARLA 中仿真精度最高、功能最丰富的连续型传感器。其基于 GPU 加速射线投射，提供高频、高密度、可配置的点云数据输出。</p>
<p>该模块适用于感知、规划、重建、避障等任务，是自动驾驶研究不可或缺的重要组件。</p>
<hr />
<h1 id="sensorotherobstacle_1">第七章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#obstacle-detector">障碍物检测传感器系统</a> （sensor.other.obstacle）</h1>
<hr />
<h2 id="1_6">1 模块概览</h2>
<p><img alt="flowchart_7.png" src="../../img/modules/flowchart_7.png" /></p>
<p><code>sensor.other.obstacle</code> 是 CARLA 提供的一类事件触发型传感器，用于在仿真环境中检测车辆或行人前方的潜在障碍物。与 <code>collision</code> 传感器不同，它在实际碰撞发生<strong>之前</strong>触发，为自动驾驶决策提供提前预警。</p>
<p>该传感器通常被附着于主控实体（如车辆），当检测到其前方存在障碍物进入指定感知半径时，触发 <code>ObstacleDetectionEvent</code>，并返回障碍物的相对位置、速度、Actor ID 等信息。</p>
<hr />
<h2 id="2_6">2 触发机制与事件流程</h2>
<p>该传感器通过连续评估障碍物与传感器附着体（通常为车辆）的相对几何关系触发事件：</p>
<ol>
<li><strong>服务端检测</strong>：在每帧仿真中，根据感知参数计算是否存在障碍物进入视野范围；</li>
<li><strong>事件生成</strong>：若满足触发条件，生成 <code>ObstacleDetectionEvent</code>；</li>
<li><strong>数据编码</strong>：使用 <code>ObstacleDetectionEventSerializer</code> 将障碍物 Actor ID、距离、速度等打包为 <code>RawData</code>；</li>
<li><strong>网络传输</strong>：通过 CARLA 的 RPC 系统将数据推送至客户端；</li>
<li><strong>回调触发</strong>：客户端通过 <code>.listen()</code> 注册的 Python 回调函数接收该事件。</li>
</ol>
<p>该机制支持近实时检测与事件压缩传输，适用于高频控制反馈与行为建模。</p>
<hr />
<h2 id="3-obstacledetectionevent">3 数据结构解析：ObstacleDetectionEvent</h2>
<p>定义文件：<a href="https://github.com/carla-simulator/carla/blob/dev/LibCarla/source/carla/sensor/data/ObstacleDetectionEvent.h"><code>carla/sensor/data/ObstacleDetectionEvent.h</code></a></p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">ObstacleDetectionEvent</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">self_actor</span><span class="p">;</span><span class="w">       </span><span class="c1">// 传感器附着体（通常为主车）</span>
<span class="w">  </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">other_actor</span><span class="p">;</span><span class="w">      </span><span class="c1">// 检测到的障碍物</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">distance</span><span class="p">;</span><span class="w">              </span><span class="c1">// 当前距离（单位：米）</span>
<span class="w">  </span><span class="n">geom</span><span class="o">::</span><span class="n">Vector3D</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span><span class="w">       </span><span class="c1">// 接触法线方向（用于避障判断）</span>
<span class="p">};</span>
</code></pre></div>
<p>说明：</p>
<ul>
<li><code>self_actor</code>：发出检测的实体，通常为车辆本体；</li>
<li><code>other_actor</code>：障碍物 Actor（动态物体，如其他车辆、行人）；</li>
<li><code>distance</code>：两者之间的欧式距离；</li>
<li><code>normal</code>：从障碍物指向车辆的法向向量，用于判断障碍方向与应对策略。</li>
</ul>
<hr />
<h2 id="4_4">4 序列化机制说明</h2>
<p>定义文件：
<a href="https://github.com/carla-simulator/carla/blob/dev/LibCarla/source/carla/sensor/s11n/ObstacleDetectionEventSerializer.h"><code>ObstacleDetectionEventSerializer.h</code></a>
<a href="https://github.com/carla-simulator/carla/blob/dev/LibCarla/source/carla/sensor/s11n/ObstacleDetectionEventSerializer.cpp"><code>ObstacleDetectionEventSerializer.cpp</code></a></p>
<p>序列化结构体如下：</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Data</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">self_actor</span><span class="p">;</span>
<span class="w">  </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">other_actor</span><span class="p">;</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">distance</span><span class="p">;</span>
<span class="w">  </span><span class="n">geom</span><span class="o">::</span><span class="n">Vector3D</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span>
<span class="w">  </span><span class="n">MSGPACK_DEFINE_ARRAY</span><span class="p">(</span><span class="n">self_actor</span><span class="p">,</span><span class="w"> </span><span class="n">other_actor</span><span class="p">,</span><span class="w"> </span><span class="n">distance</span><span class="p">,</span><span class="w"> </span><span class="n">normal</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div>
<p>序列化函数：</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">SensorT</span><span class="o">&gt;</span>
<span class="k">static</span><span class="w"> </span><span class="n">Buffer</span><span class="w"> </span><span class="n">Serialize</span><span class="p">(</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SensorT</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span>
<span class="w">  </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">self_actor</span><span class="p">,</span>
<span class="w">  </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">other_actor</span><span class="p">,</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">distance</span><span class="p">,</span>
<span class="w">  </span><span class="n">geom</span><span class="o">::</span><span class="n">Vector3D</span><span class="w"> </span><span class="n">normal</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">MsgPack</span><span class="o">::</span><span class="n">Pack</span><span class="p">(</span><span class="n">Data</span><span class="p">{</span><span class="n">self_actor</span><span class="p">,</span><span class="w"> </span><span class="n">other_actor</span><span class="p">,</span><span class="w"> </span><span class="n">distance</span><span class="p">,</span><span class="w"> </span><span class="n">normal</span><span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<p>反序列化函数：</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">SharedPtr</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Deserialize</span><span class="p">(</span><span class="n">RawData</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SharedPtr</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">data</span><span class="o">::</span><span class="n">ObstacleDetectionEvent</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div>
<hr />
<h2 id="5-python-api_4">5 Python API 使用示例</h2>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_obstacle</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="n">obstacle</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">other_actor</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">distance</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[OBSTACLE] 检测到障碍物 ID=</span><span class="si">{</span><span class="n">obstacle</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> 距离=</span><span class="si">{</span><span class="n">distance</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> m&quot;</span><span class="p">)</span>

<span class="n">bp</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">get_blueprint_library</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;sensor.other.obstacle&#39;</span><span class="p">)</span>
<span class="n">transform</span> <span class="o">=</span> <span class="n">carla</span><span class="o">.</span><span class="n">Transform</span><span class="p">(</span><span class="n">carla</span><span class="o">.</span><span class="n">Location</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mf">1.2</span><span class="p">))</span>
<span class="n">sensor</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">spawn_actor</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">attach_to</span><span class="o">=</span><span class="n">vehicle</span><span class="p">)</span>
<span class="n">sensor</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="n">on_obstacle</span><span class="p">)</span>
</code></pre></div>
<p>你也可以设置可选属性：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>distance</code></td>
<td>检测范围（米）</td>
<td>5.0</td>
</tr>
<tr>
<td><code>only_dynamics</code></td>
<td>是否仅检测动态物体</td>
<td>True</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="6_5">6 应用场景与扩展建议</h2>
<h3 id="_6">应用场景：</h3>
<ul>
<li><strong>行为预测</strong>：检测交通密度与动态交互（如并线、跟车）；</li>
<li><strong>路径修正</strong>：用于控制模块触发制动或绕行；</li>
<li><strong>防碰撞规划</strong>：可作为 Collision Sensor 的前置预警；</li>
<li><strong>人机共驾</strong>：识别动态障碍并介入人类驾驶行为；</li>
<li><strong>强化学习训练</strong>：将“接近障碍物”事件作为负反馈。</li>
</ul>
<h3 id="_7">拓展建议：</h3>
<ul>
<li>加入障碍物速度/加速度字段；</li>
<li>支持多障碍物并发检测结果；</li>
<li>支持障碍物类别过滤（如忽略行人、静态桩）；</li>
<li>联合摄像头进行视觉语义增强。</li>
</ul>
<hr />
<h2 id="7_5">7 小结</h2>
<ul>
<li><code>sensor.other.obstacle</code> 提供动态障碍预警机制，是事件驱动型传感器；</li>
<li>可提前于碰撞生成预警信号，在路径规划与行为建模中广泛使用；</li>
<li>推荐与 Collision、IMU、Radar 等模块联合使用，实现更完整的行为感知。</li>
</ul>
<hr />
<h1 id="rgb-sensorcamerargb_1">第八章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#rgb-camera">RGB 摄像头传感器系统</a>（sensor.camera.rgb）</h1>
<hr />
<h2 id="1_7">1 模块概览</h2>
<p><img alt="flowchart_8.png" src="../../img/modules/flowchart_8.png" /></p>
<p><code>sensor.camera.rgb</code> 是 CARLA 中最基础且最常用的图像传感器，模拟真实世界中的 RGB 相机输出，生成三通道图像（Red, Green, Blue），支持用户自定义分辨率、视场角、帧率等参数。</p>
<p>该传感器广泛应用于以下任务：</p>
<ul>
<li>自动驾驶中的目标检测、语义分割等视觉感知任务；</li>
<li>数据集构建（如 nuScenes、KITTI 格式）；</li>
<li>多传感器融合（如与 LiDAR、IMU 联合使用）；</li>
<li>场景渲染与仿真回放。</li>
</ul>
<hr />
<h2 id="2_7">2 图像采集与传输机制</h2>
<p>RGB 相机传感器的数据处理流程如下：</p>
<ol>
<li><strong>渲染采样</strong>：服务端使用 Unreal Engine 渲染模块生成当前视角图像帧；</li>
<li><strong>图像打包</strong>：图像帧由 <code>ImageSerializer</code> 编码为二进制 <code>RawData</code>；</li>
<li><strong>网络传输</strong>：通过 RPC 系统将图像流传输至客户端；</li>
<li><strong>数据还原</strong>：客户端自动解码为 <code>sensor.data.Image</code> 实例；</li>
<li><strong>Python 处理</strong>：注册的 <code>.listen()</code> 回调函数处理图像帧，通常用于保存或神经网络推理。</li>
</ol>
<hr />
<h2 id="3-image">3 数据结构说明：Image</h2>
<p>定义文件：<a href="https://github.com/carla-simulator/carla/blob/dev/LibCarla/source/carla/sensor/data/Image.h"><code>carla/sensor/data/Image.h</code></a></p>
<p>图像结构定义如下：</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Image</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">SensorData</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w">       </span><span class="c1">// 图像宽度</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w">      </span><span class="c1">// 图像高度</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"> </span><span class="c1">// 图像数据，每像素占4字节（RGBA）</span>
<span class="p">};</span>
</code></pre></div>
<p>说明：</p>
<ul>
<li>图像以 <code>uint8_t</code> 字节序存储，每像素 4 通道（Red, Green, Blue, Alpha）；</li>
<li>可以在 Python 中转为 <code>np.array</code> 或保存为 <code>PIL.Image</code>。</li>
</ul>
<hr />
<h2 id="4_5">4 序列化与编码流程</h2>
<p>定义文件：
<a href="https://github.com/carla-simulator/carla/blob/dev/LibCarla/source/carla/sensor/s11n/ImageSerializer.h"><code>ImageSerializer.h</code></a></p>
<ul>
<li><code>ImageSerializer::Serialize()</code> 将渲染帧打包为连续 RGBA 字节流；</li>
<li><code>ImageSerializer::Deserialize()</code> 直接返回 <code>data::Image</code> 实例：</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">SharedPtr</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ImageSerializer</span><span class="o">::</span><span class="n">Deserialize</span><span class="p">(</span><span class="n">RawData</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SharedPtr</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">data</span><span class="o">::</span><span class="n">Image</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div>
<p>整个流程无需额外结构化数据编码，依赖图像本体作为主数据内容，适合大吞吐图像序列传输。</p>
<hr />
<h2 id="5-python-api_5">5 Python API 使用示例</h2>
<p>以下示例展示如何部署 RGB 相机，并保存或处理帧图像：</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">save_rgb_image</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="n">image</span><span class="o">.</span><span class="n">save_to_disk</span><span class="p">(</span><span class="s1">&#39;output/rgb_</span><span class="si">%06d</span><span class="s1">.png&#39;</span> <span class="o">%</span> <span class="n">image</span><span class="o">.</span><span class="n">frame</span><span class="p">)</span>

<span class="n">bp</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">get_blueprint_library</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;sensor.camera.rgb&#39;</span><span class="p">)</span>
<span class="n">bp</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;image_size_x&#39;</span><span class="p">,</span> <span class="s1">&#39;800&#39;</span><span class="p">)</span>
<span class="n">bp</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;image_size_y&#39;</span><span class="p">,</span> <span class="s1">&#39;600&#39;</span><span class="p">)</span>
<span class="n">bp</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;fov&#39;</span><span class="p">,</span> <span class="s1">&#39;90&#39;</span><span class="p">)</span>

<span class="n">transform</span> <span class="o">=</span> <span class="n">carla</span><span class="o">.</span><span class="n">Transform</span><span class="p">(</span><span class="n">carla</span><span class="o">.</span><span class="n">Location</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mf">2.4</span><span class="p">))</span>
<span class="n">camera</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">spawn_actor</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">attach_to</span><span class="o">=</span><span class="n">vehicle</span><span class="p">)</span>
<span class="n">camera</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="n">save_rgb_image</span><span class="p">)</span>
</code></pre></div>
<p>你也可以用 <code>numpy</code> 解码图像：</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">def</span> <span class="nf">decode_np</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">raw_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">image</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="mi">4</span><span class="p">))[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># RGB</span>
    <span class="k">return</span> <span class="n">array</span>
</code></pre></div>
<hr />
<h2 id="6_6">6 应用方向与参数优化</h2>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>image_size_x</code></td>
<td>水平方向像素数</td>
<td>800</td>
</tr>
<tr>
<td><code>image_size_y</code></td>
<td>垂直方向像素数</td>
<td>600</td>
</tr>
<tr>
<td><code>fov</code></td>
<td>水平视角（°）</td>
<td>90</td>
</tr>
<tr>
<td><code>sensor_tick</code></td>
<td>更新时间（秒）</td>
<td>0.05</td>
</tr>
<tr>
<td><code>gamma</code></td>
<td>图像色调校正系数</td>
<td>2.2</td>
</tr>
</tbody>
</table>
<h3 id="_8">应用方向：</h3>
<ul>
<li>多视角图像采集（前视、侧视、鸟瞰）；</li>
<li>与 LiDAR/IMU 融合用于深度估计与定位；</li>
<li>用于训练视觉模型（检测、分割、跟踪）；</li>
<li>与语义图（<code>sensor.camera.semantic_segmentation</code>）联合生成 GT 标注图像；</li>
<li>将图像与 GNSS/IMU 时间对齐生成时空标注序列。</li>
</ul>
<hr />
<h2 id="7_6">7 小结</h2>
<p><code>sensor.camera.rgb</code> 是 CARLA 感知系统中的基础视觉模块，提供稳定、高质量、可配置的图像输出能力。其在自动驾驶系统开发、视觉模型训练与多模态感知实验中具有不可替代的作用。</p>
<p>推荐配合其他传感器（IMU、GNSS、Depth、LiDAR）使用，构建完整的数据生成与处理流水线。</p>
<hr />
<h1 id="sensorcameradepth_1">第九章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#depth-camera">深度相机传感器系统</a> （sensor.camera.depth）</h1>
<hr />
<h2 id="1_8">1 模块概览</h2>
<p><img alt="flowchart_9.png" src="../../img/modules/flowchart_9.png" /></p>
<p><code>sensor.camera.depth</code> 是 CARLA 提供的专用深度图相机传感器，用于模拟相机视角下的每像素距离场景物体的真实物理距离（单位为米）。其输出为 4 通道图像（RGBA），其中 RGB 通道编码深度信息，Alpha 通道通常为 255。</p>
<p>该传感器常用于：</p>
<ul>
<li>点云生成（结合内参投影）；</li>
<li>训练单目深度估计模型；</li>
<li>RGB-D 感知任务；</li>
<li>三维重建与视觉 SLAM；</li>
<li>自动驾驶下游任务中的几何感知。</li>
</ul>
<hr />
<h2 id="2_8">2 成像原理与深度编码</h2>
<p>CARLA 中的深度相机使用如下逻辑将真实距离值编码为图像格式：</p>
<h3 id="_9">编码方式（在渲染端）：</h3>
<p>CARLA 默认使用 3 通道（R, G, B）编码浮点深度（单位：米）：</p>
<div class="highlight"><pre><span></span><code><span class="n">depth</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span> <span class="o">+</span> <span class="n">G</span> <span class="o">*</span> <span class="mi">256</span> <span class="o">+</span> <span class="n">B</span> <span class="o">*</span> <span class="mi">256</span> <span class="o">*</span> <span class="mi">256</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">256</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1000.0</span>
</code></pre></div>
<ul>
<li>可解码为每像素 0–1000 米内的精度深度图；</li>
<li>图像格式为 8-bit 无符号整数，每像素 4 字节（RGBA）。</li>
</ul>
<hr />
<h2 id="3_3">3 数据结构说明</h2>
<p>深度图使用与 RGB 图像相同的数据结构：</p>
<p>定义位置：<a href="https://github.com/carla-simulator/carla/blob/dev/LibCarla/source/carla/sensor/data/Image.h"><code>carla/sensor/data/Image.h</code></a></p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Image</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">SensorData</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"> </span><span class="c1">// RGBA 图像流</span>
<span class="p">};</span>
</code></pre></div>
<ul>
<li>图像以 <code>uint8_t</code> 存储，布局为 RGBA；</li>
<li>深度编码在 RGB 通道，Alpha 通道可忽略。</li>
</ul>
<hr />
<h2 id="4_6">4 序列化与解码流程</h2>
<p>该传感器复用了 <code>ImageSerializer</code>：</p>
<p>定义文件：<a href="https://github.com/carla-simulator/carla/blob/dev/LibCarla/source/carla/sensor/s11n/ImageSerializer.h"><code>ImageSerializer.h</code></a></p>
<ul>
<li>图像渲染 → 原始字节流打包为 <code>RawData</code>；</li>
<li>客户端 <code>ImageSerializer::Deserialize()</code> 解包为 <code>Image</code> 对象；</li>
<li>Python 层通过 <code>.raw_data</code> 解码深度。</li>
</ul>
<p>无 MsgPack 序列化，采用原始流传输，更高效适配图像数据密度。</p>
<hr />
<h2 id="5-python-api_6">5 Python API 使用示例</h2>
<p>以下代码展示如何部署深度相机并转换为实际深度图：</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">decode_depth</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">raw_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">image</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="mi">4</span><span class="p">))[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="c1"># 深度解码</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="p">(</span><span class="n">array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">256</span> <span class="o">+</span> <span class="n">array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">256</span> <span class="o">*</span> <span class="mi">256</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">256</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1000.0</span>
    <span class="k">return</span> <span class="n">depth</span>

<span class="c1"># 创建传感器</span>
<span class="n">bp</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">get_blueprint_library</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;sensor.camera.depth&#39;</span><span class="p">)</span>
<span class="n">bp</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;image_size_x&#39;</span><span class="p">,</span> <span class="s1">&#39;800&#39;</span><span class="p">)</span>
<span class="n">bp</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;image_size_y&#39;</span><span class="p">,</span> <span class="s1">&#39;600&#39;</span><span class="p">)</span>

<span class="n">transform</span> <span class="o">=</span> <span class="n">carla</span><span class="o">.</span><span class="n">Transform</span><span class="p">(</span><span class="n">carla</span><span class="o">.</span><span class="n">Location</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mf">2.4</span><span class="p">))</span>
<span class="n">camera</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">spawn_actor</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">attach_to</span><span class="o">=</span><span class="n">vehicle</span><span class="p">)</span>
<span class="n">camera</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="k">lambda</span> <span class="n">image</span><span class="p">:</span> <span class="n">decode_depth</span><span class="p">(</span><span class="n">image</span><span class="p">))</span>
</code></pre></div>
<p>也可保存为深度图图像（伪彩）或导出为 PFM 格式。</p>
<hr />
<h2 id="6_7">6 深度图应用场景</h2>
<h3 id="_10">常见用途：</h3>
<ul>
<li><strong>点云投影</strong>：结合内参可将深度图转换为相机系 3D 点云；</li>
<li><strong>RGB-D 感知训练</strong>：用于单目深度估计、3D 目标检测、深度分割；</li>
<li><strong>立体匹配数据集</strong>：与 <code>sensor.camera.rgb</code> 同步输出，可形成训练样本对；</li>
<li><strong>三维重建</strong>：将连续帧深度图拼接成稠密点云；</li>
<li><strong>视觉 SLAM</strong>：与 ORB-SLAM2、ElasticFusion 等框架结合使用。</li>
</ul>
<hr />
<h2 id="7_7">7 小结</h2>
<p><code>sensor.camera.depth</code> 提供高精度、连续、结构一致的深度图像输出，在自动驾驶视觉研究中是不可替代的重要组件。</p>
<p>推荐与 RGB、语义分割、IMU/GNSS 联合使用，用于高质量数据生成、深度估计模型训练与三维结构重建。</p>
<hr />
<h1 id="sensorcamerasemantic_segmentation_1">第十章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#semantic-segmentation-camera">语义分割摄像头传感器系统</a> （sensor.camera.semantic_segmentation）</h1>
<hr />
<h2 id="1_9">1 模块概览</h2>
<p><img alt="flowchart_10.png" src="../../img/modules/flowchart_10.png" /></p>
<p><code>sensor.camera.semantic_segmentation</code> 是 CARLA 提供的语义感知型图像传感器。它将模拟环境中可见物体（如车辆、行人、道路等）按照类别进行像素级别的标注，每帧输出一张语义分割图像，用于训练自动驾驶模型中的感知网络或环境理解模块。</p>
<p>该传感器在数据采集、分割模型训练、语义地图构建、端到端学习等任务中具有广泛应用价值。</p>
<hr />
<h2 id="2_9">2 输出内容与标签定义</h2>
<p>该传感器输出为<strong>单通道图像</strong>，每个像素为一个整数值，表示该像素所属的语义类别。默认图像格式为：</p>
<ul>
<li><code>RGBA</code> 字节流，实际仅使用 <code>R</code> 通道（值范围：0–255）；</li>
<li>每个 ID 对应一种语义类别，CARLA 提供默认映射关系（可自定义）。</li>
</ul>
<h3 id="_11">示例标签对照表：</h3>
<table>
<thead>
<tr>
<th>类别名称</th>
<th>类别 ID</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0</td>
</tr>
<tr>
<td>Buildings</td>
<td>1</td>
</tr>
<tr>
<td>Fences</td>
<td>2</td>
</tr>
<tr>
<td>Other</td>
<td>3</td>
</tr>
<tr>
<td>Pedestrians</td>
<td>4</td>
</tr>
<tr>
<td>Poles</td>
<td>5</td>
</tr>
<tr>
<td>Roads</td>
<td>6</td>
</tr>
<tr>
<td>RoadLines</td>
<td>7</td>
</tr>
<tr>
<td>Sidewalks</td>
<td>8</td>
</tr>
<tr>
<td>Vegetation</td>
<td>9</td>
</tr>
<tr>
<td>Vehicles</td>
<td>10</td>
</tr>
<tr>
<td>Wall</td>
<td>11</td>
</tr>
<tr>
<td>TrafficSign</td>
<td>12</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="3_4">3 数据结构与格式说明</h2>
<p>语义分割图像复用图像类结构：</p>
<p>定义位置：<a href="https://github.com/carla-simulator/carla/blob/dev/LibCarla/source/carla/sensor/data/Image.h"><code>carla/sensor/data/Image.h</code></a></p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Image</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">SensorData</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"> </span><span class="c1">// 每像素RGBA，语义ID编码在R通道</span>
<span class="p">};</span>
</code></pre></div>
<p>说明：</p>
<ul>
<li>虽然为 RGBA 图像，但只有红色通道包含有效的语义类别；</li>
<li>可直接用 <code>image.raw_data</code> → <code>np.uint8</code> → <code>reshape</code> 转换为二维语义图。</li>
</ul>
<hr />
<h2 id="4_7">4 序列化机制说明</h2>
<p><code>sensor.camera.semantic_segmentation</code> 复用 <code>ImageSerializer</code>：</p>
<p>定义文件：<a href="https://github.com/carla-simulator/carla/blob/dev/LibCarla/source/carla/sensor/s11n/ImageSerializer.h"><code>ImageSerializer.h</code></a></p>
<div class="highlight"><pre><span></span><code><span class="n">SharedPtr</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ImageSerializer</span><span class="o">::</span><span class="n">Deserialize</span><span class="p">(</span><span class="n">RawData</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SharedPtr</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">data</span><span class="o">::</span><span class="n">Image</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>无额外结构字段，仅传输原始图像数据；</li>
<li>每帧语义图由服务端生成（Unreal Engine 渲染）后通过 RPC 系统推送；</li>
<li>客户端将数据解码为 <code>Image</code> 实例并触发回调。</li>
</ul>
<hr />
<h2 id="5-python-api_7">5 Python API 使用示例</h2>
<p>以下示例展示如何创建语义分割传感器，并将图像保存或解析为标签矩阵：</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">save_semantic</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="n">image</span><span class="o">.</span><span class="n">save_to_disk</span><span class="p">(</span><span class="s1">&#39;output/seg_</span><span class="si">%06d</span><span class="s1">.png&#39;</span> <span class="o">%</span> <span class="n">image</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">carla</span><span class="o">.</span><span class="n">ColorConverter</span><span class="o">.</span><span class="n">CityScapesPalette</span><span class="p">)</span>

<span class="n">bp</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">get_blueprint_library</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;sensor.camera.semantic_segmentation&#39;</span><span class="p">)</span>
<span class="n">bp</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;image_size_x&#39;</span><span class="p">,</span> <span class="s1">&#39;800&#39;</span><span class="p">)</span>
<span class="n">bp</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;image_size_y&#39;</span><span class="p">,</span> <span class="s1">&#39;600&#39;</span><span class="p">)</span>
<span class="n">transform</span> <span class="o">=</span> <span class="n">carla</span><span class="o">.</span><span class="n">Transform</span><span class="p">(</span><span class="n">carla</span><span class="o">.</span><span class="n">Location</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mf">2.4</span><span class="p">))</span>

<span class="n">seg_sensor</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">spawn_actor</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">attach_to</span><span class="o">=</span><span class="n">vehicle</span><span class="p">)</span>
<span class="n">seg_sensor</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="n">save_semantic</span><span class="p">)</span>
</code></pre></div>
<h3 id="_12">自定义解析标签矩阵：</h3>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">parse_semantic</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">raw_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">seg_labels</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">image</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="mi">4</span><span class="p">))[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># R通道为语义标签</span>
    <span class="k">return</span> <span class="n">seg_labels</span>
</code></pre></div>
<hr />
<h2 id="6_8">6 应用与扩展方向</h2>
<h3 id="_13">应用场景：</h3>
<ul>
<li>训练语义分割模型（如 DeepLab、PSPNet）；</li>
<li>联合 RGB/Depth 生成多模态数据集；</li>
<li>构建语义 HD 地图（自动车道标注）；</li>
<li>强化学习场景中的语义感知输入；</li>
<li>与 GNSS/IMU 时间对齐，构建时空标注序列。</li>
</ul>
<h3 id="_14">拓展建议：</h3>
<ul>
<li>替换默认 CityScapes 标签体系，构建自定义语义类别；</li>
<li>增加边缘高亮、透明度渲染参数；</li>
<li>配合 <code>ColorConverter</code> 自定义彩色编码方案；</li>
<li>输出压缩格式（如 JPEG8）以节省带宽。</li>
</ul>
<hr />
<h2 id="7_8">7 小结</h2>
<p><code>sensor.camera.semantic_segmentation</code> 是 CARLA 中唯一原生支持像素级语义标注的传感器。它提供标准化标签图，适合用于多种感知任务，尤其在构建多视图、多模态、高频率自动驾驶数据集方面扮演关键角色。</p>
<p>推荐与 <code>RGB/Depth/LiDAR</code> 联合使用，支持多任务模型训练与语义地图制作。</p>
<hr />
<h2 id="carla-sensorradarray_cast">第十一章：CARLA 雷达传感器系统（sensor.radar.ray_cast）</h2>
<h3 id="1_10">1 模块概览</h3>
<p><img alt="flowchart_11.png" src="../../img/modules/flowchart_11.png" />
CARLA 中的 <code>sensor.radar.ray_cast</code> 模拟车载雷达的基本特性，通过射线投射模拟雷达波束在三维空间中遇到物体后的反射点。该模块适用于低分辨率目标检测、运动分析、障碍识别等任务。</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据频率</td>
<td>可配置（推荐 10\~20Hz）</td>
</tr>
<tr>
<td>回调格式</td>
<td><code>carla.RadarMeasurement</code></td>
</tr>
<tr>
<td>单点数据结构</td>
<td><code>carla.RadarDetection</code></td>
</tr>
<tr>
<td>模拟特性</td>
<td>包含相对速度、距离、方位角和俯仰角</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="2_10">2 扫描原理与数据描述</h3>
<p>该传感器通过以下参数定义雷达扫描区域：</p>
<ul>
<li><code>horizontal_fov</code>: 水平视场（默认 30 度）</li>
<li><code>vertical_fov</code>: 垂直视场（默认 10 度）</li>
<li><code>range</code>: 有效距离（默认 100 米）</li>
</ul>
<p>传感器会从车体坐标系出发，发射若干射线，每条射线检测到的目标构成一个 <code>RadarDetection</code> 点。每个点包含：</p>
<ul>
<li><code>depth</code>: 到目标的距离（米）</li>
<li><code>azimuth</code>: 方位角（rad）</li>
<li><code>altitude</code>: 俯仰角（rad）</li>
<li><code>velocity</code>: 相对于车辆的径向速度（m/s）</li>
</ul>
<hr />
<h3 id="3-radardetection">3 数据结构解析：<code>RadarDetection</code></h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">carla</span><span class="o">.</span><span class="n">RadarDetection</span><span class="p">:</span>
    <span class="n">depth</span><span class="p">:</span> <span class="nb">float</span>       <span class="c1"># 目标距离（m）</span>
    <span class="n">velocity</span><span class="p">:</span> <span class="nb">float</span>    <span class="c1"># 径向速度（m/s）</span>
    <span class="n">azimuth</span><span class="p">:</span> <span class="nb">float</span>     <span class="c1"># 方位角（rad）</span>
    <span class="n">altitude</span><span class="p">:</span> <span class="nb">float</span>    <span class="c1"># 俯仰角（rad）</span>
</code></pre></div>
<ul>
<li>点云顺序无规律排序，需按角度聚类分析；</li>
<li><code>velocity</code> 可用于区分静止物体与移动目标；</li>
<li>无 ID，需自行跟踪识别。</li>
</ul>
<hr />
<h3 id="4_8">4 序列化与传输机制</h3>
<p>CARLA 将 <code>RadarMeasurement</code> 数据序列化为 <code>RawData</code>，通过 RPC 管道传输至客户端。与其他传感器不同，雷达数据较小，传输效率高。</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>① 触发帧回调</td>
<td>服务端检测帧时更新射线投射结果</td>
</tr>
<tr>
<td>② 序列化</td>
<td>每个 <code>RadarDetection</code> 被编码为字节流结构</td>
</tr>
<tr>
<td>③ 客户端接收</td>
<td>Python 客户端接收 <code>RadarMeasurement</code> 并解码为点集</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="5-python-api_8">5 Python API 使用示例</h3>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">carla</span>

<span class="k">def</span> <span class="nf">radar_callback</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">detection</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distance: </span><span class="si">{</span><span class="n">detection</span><span class="o">.</span><span class="n">depth</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> m, Speed: </span><span class="si">{</span><span class="n">detection</span><span class="o">.</span><span class="n">velocity</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> m/s&quot;</span><span class="p">)</span>

<span class="n">world</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get_world</span><span class="p">()</span>
<span class="n">bp_lib</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">get_blueprint_library</span><span class="p">()</span>
<span class="n">radar_bp</span> <span class="o">=</span> <span class="n">bp_lib</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;sensor.radar.ray_cast&#39;</span><span class="p">)</span>

<span class="n">radar_bp</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;horizontal_fov&#39;</span><span class="p">,</span> <span class="s1">&#39;35&#39;</span><span class="p">)</span>
<span class="n">radar_bp</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;vertical_fov&#39;</span><span class="p">,</span> <span class="s1">&#39;10&#39;</span><span class="p">)</span>
<span class="n">radar_bp</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">,</span> <span class="s1">&#39;50&#39;</span><span class="p">)</span>

<span class="n">spawn_point</span> <span class="o">=</span> <span class="n">carla</span><span class="o">.</span><span class="n">Transform</span><span class="p">(</span><span class="n">carla</span><span class="o">.</span><span class="n">Location</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mf">1.0</span><span class="p">))</span>
<span class="n">radar</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">spawn_actor</span><span class="p">(</span><span class="n">radar_bp</span><span class="p">,</span> <span class="n">spawn_point</span><span class="p">,</span> <span class="n">attach_to</span><span class="o">=</span><span class="n">vehicle</span><span class="p">)</span>

<span class="n">radar</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="k">lambda</span> <span class="n">data</span><span class="p">:</span> <span class="n">radar_callback</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</code></pre></div>
<hr />
<h3 id="6_9">6 应用与对比分析</h3>
<table>
<thead>
<tr>
<th>应用领域</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动驾驶感知</td>
<td>用于检测移动目标（如对向车辆、自行车）</td>
</tr>
<tr>
<td>模拟预警系统</td>
<td>可用于构建碰撞预警、AEB 仿真</td>
</tr>
<tr>
<td>天气鲁棒性</td>
<td>雾、雨等极端天气下性能优于 LiDAR</td>
</tr>
</tbody>
</table>
<blockquote>
<p>需注意：雷达检测精度有限，不能替代 LiDAR 或相机的精确识别能力，适合作为冗余传感器或动态监测模块。</p>
</blockquote>
<hr />
<h3 id="7_9">7 小结</h3>
<ul>
<li><code>sensor.radar.ray_cast</code> 是 CARLA 提供的轻量级雷达仿真模块；</li>
<li>支持实时回调并提供速度信息；</li>
<li>易于部署和组合，但需注意精度限制。</li>
</ul>
<hr />
<h1 id="sensorotherrss_1">第十二章：<a href="https://openhutb.github.io/carla_doc/ref_sensors/#rss-sensor">责任敏感安全传感器系统</a>（sensor.other.rss）</h1>
<hr />
<h2 id="1_11">1 模块概览</h2>
<p><img alt="flowchart_12.png" src="../../img/modules/flowchart_12.png" />
CARLA 中的 <code>sensor.other.rss</code> 是对 <a href="https://www.mobileye.com/responsibility-sensitive-safety/">Mobileye 提出的 RSS（Responsibility-Sensitive Safety）模型</a> 的仿真实现。它评估当前车辆是否在纵向和横向方向上满足合理安全距离，若违反安全规则，则通过事件输出提供结构化响应。</p>
<p>该传感器广泛应用于以下领域：</p>
<ul>
<li>自动驾驶系统的<strong>安全性评估</strong></li>
<li>安全冗余感知与<strong>控制系统回退逻辑验证</strong></li>
<li>车辆规划/控制模块中的<strong>AEB 与干预触发检测</strong></li>
</ul>
<hr />
<h2 id="2-rss">2 RSS 模型简介与传感器原理</h2>
<p>RSS 模型基于一套形式化定义的安全距离计算规则。CARLA 内置实现使用以下核心规则：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>最小纵向距离</td>
<td>基于当前速度差、最大加速度计算</td>
</tr>
<tr>
<td>最小横向距离</td>
<td>允许目标在紧急变道情况下仍能避免碰撞</td>
</tr>
<tr>
<td>响应等级</td>
<td>安全、警告、紧急干预（可自定义响应策略）</td>
</tr>
</tbody>
</table>
<p>传感器工作流程：</p>
<ol>
<li><strong>每帧检查当前主车与其他车辆间的 RSS 状态</strong></li>
<li><strong>生成 RSS 响应结构体</strong>（包含：距离状态、是否违反、安全响应等级）</li>
<li><strong>通过 RPC 通道传递给客户端</strong></li>
<li><strong>Python 层接收结构化安全状态信息</strong></li>
</ol>
<hr />
<h2 id="3-rssresponse">3 数据结构说明：<code>RssResponse</code></h2>
<p>定义位置：<code>carla/sensor/data/RssResponse.h</code></p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">RssResponse</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_safe</span><span class="p">;</span><span class="w">                 </span><span class="c1">// 是否符合安全规则</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">longitudinal_safe</span><span class="p">;</span><span class="w">       </span><span class="c1">// 纵向是否安全</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">lateral_safe</span><span class="p">;</span><span class="w">            </span><span class="c1">// 横向是否安全</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">response_status</span><span class="p">;</span><span class="w">  </span><span class="c1">// 可为 &quot;Safe&quot;, &quot;Brake&quot;, &quot;Warning&quot;</span>
<span class="p">};</span>
</code></pre></div>
<p>说明：</p>
<ul>
<li><code>is_safe = longitudinal_safe &amp;&amp; lateral_safe</code></li>
<li>若任一方向违反规则，<code>response_status</code> 将标识对应响应等级</li>
<li>可拓展为枚举式响应策略触发器</li>
</ul>
<hr />
<h2 id="4_9">4 序列化与触发机制</h2>
<p>CARLA 使用专属的 <code>RssResponseSerializer</code> 对结构体进行 MsgPack 编码：</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Data</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_safe</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">longitudinal_safe</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">lateral_safe</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">response_status</span><span class="p">;</span>
<span class="w">  </span><span class="n">MSGPACK_DEFINE_ARRAY</span><span class="p">(</span><span class="n">is_safe</span><span class="p">,</span><span class="w"> </span><span class="n">longitudinal_safe</span><span class="p">,</span><span class="w"> </span><span class="n">lateral_safe</span><span class="p">,</span><span class="w"> </span><span class="n">response_status</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div>
<p>序列化过程：</p>
<ol>
<li>服务端检测每帧 RSS 状态并生成 <code>RssResponse</code></li>
<li>使用 <code>RssResponseSerializer::Serialize()</code> 打包为 <code>RawData</code></li>
<li>客户端使用 <code>Deserialize()</code> 恢复为 <code>SensorData</code> 实例</li>
<li><code>.listen()</code> 回调函数进行实时判断/记录/控制触发</li>
</ol>
<hr />
<h2 id="5-python-api_9">5 Python API 使用示例</h2>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">rss_callback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">event</span><span class="o">.</span><span class="n">is_safe</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[RSS] 安全违规：状态=</span><span class="si">{</span><span class="n">event</span><span class="o">.</span><span class="n">response_status</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[RSS] 安全状态良好&quot;</span><span class="p">)</span>

<span class="n">bp</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">get_blueprint_library</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;sensor.other.rss&#39;</span><span class="p">)</span>
<span class="n">rss_sensor</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">spawn_actor</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">carla</span><span class="o">.</span><span class="n">Transform</span><span class="p">(),</span> <span class="n">attach_to</span><span class="o">=</span><span class="n">vehicle</span><span class="p">)</span>
<span class="n">rss_sensor</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="n">rss_callback</span><span class="p">)</span>
</code></pre></div>
<p>该传感器无空间坐标要求，直接附着于车辆即可。内部逻辑自动检测与其他交通参与者的 RSS 状态。</p>
<hr />
<h2 id="6_10">6 应用案例与扩展分析</h2>
<table>
<thead>
<tr>
<th>场景用途</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>控制回退系统</td>
<td>AEB（自动紧急制动）干预触发、最小安全距离报警</td>
</tr>
<tr>
<td>路测仿真回放分析</td>
<td>重放轨迹时重建“是否违规”记录序列，用于模型责任分析</td>
</tr>
<tr>
<td>安全规划调优</td>
<td>与行为规划器集成时提供实时限制反馈，避免非法动作规划</td>
</tr>
<tr>
<td>模拟工况生成</td>
<td>快速生成车道偏离、跟车过近、急加速等 RSS 违规场景</td>
</tr>
</tbody>
</table>
<blockquote>
<p>可将 <code>response_status</code> 输出为 CSV、图像覆盖等形式进行对比标注。</p>
</blockquote>
<hr />
<h2 id="7_10">7 小结</h2>
<p><code>sensor.other.rss</code> 提供了对 Mobileye-RSS 安全规则的结构化支持，是自动驾驶系统安全性评估与回退逻辑验证的重要传感器。其输出直观、数据小、结构清晰，适合嵌入任意仿真任务中。</p>
<hr />
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/OpenHUTB/carla_doc" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="https://cdn.rawgit.com/knsv/mermaid/6.0.0/dist/mermaid.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script>
      <script src="../../js/umlconvert.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
