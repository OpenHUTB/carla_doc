<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>CARLA 碰撞事件传感器系统（sensor.other.collision） - 人车模拟器</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "CARLA \u78b0\u649e\u4e8b\u4ef6\u4f20\u611f\u5668\u7cfb\u7edf\uff08sensor.other.collision\uff09";
        var mkdocs_page_input_path = "modules/sensor.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> 人车模拟器
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">首页</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">人车模拟器</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">CARLA 碰撞事件传感器系统（sensor.other.collision）</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/OpenHUTB/carla_doc/edit/master/docs/modules/sensor.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="carla-sensorothercollision">CARLA 碰撞事件传感器系统（sensor.other.collision）</h1>
<hr />
<h2 id="1">1 模块概览</h2>
<p>本文档详细讲解 CARLA 模拟器中的一类简单传感器：<code>sensor.other.collision</code>，即碰撞事件传感器。该传感器不输出连续数据流，而是在发生事件时触发，用于监测模拟中车辆或行人与其他物体之间的物理接触。通过对其数据结构、序列化机制、客户端接收方式的解析，揭示其在 CARLA 感知系统中的运行机制。</p>
<hr />
<h2 id="2">2 传感器注册与调用原理</h2>
<p>CARLA 所有传感器，包括 <code>sensor.other.collision</code>，都基于统一的传感器注册机制。碰撞传感器的生命周期由客户端 Python API 控制，但核心的绑定与数据通路如下：</p>
<ul>
<li><strong>蓝图注册阶段</strong>：传感器类型如 <code>sensor.other.collision</code> 在 Unreal Engine 蓝图中定义，并注册至 Blueprint Library 中。</li>
<li><strong>Actor 创建阶段</strong>：客户端通过 <code>world.spawn_actor</code> 方法从蓝图中创建对应的传感器 Actor，并将其附着至车体等实体上。</li>
<li><strong>传感器通道建立</strong>：Actor 绑定了底层的 <code>SensorData</code> 类型（例如 <code>CollisionEvent</code> 派生自 <code>SensorData</code>），并通过 <code>listen()</code> 方法注册 Python 回调函数。</li>
<li><strong>事件触发与回调机制</strong>：</li>
<li>服务端 C++ 模拟器捕捉到物理碰撞，生成 <code>CollisionEvent</code> 数据结构。</li>
<li>通过 <code>CollisionEventSerializer</code> 使用 MsgPack 编码为 <code>RawData</code> 数据包。</li>
<li>通过 RPC 管道将 <code>RawData</code> 传输至客户端。</li>
<li>客户端自动调用对应的 <code>Deserialize()</code> 方法还原 <code>SensorData</code> 对象。</li>
<li>最终将对象作为参数传入 <code>sensor.listen(fn)</code> 中的 Python 函数。</li>
</ul>
<p>这一机制实现了“事件 → 序列化 → 网络传输 → 客户端恢复 → 回调”的完整闭环。</p>
<hr />
<h2 id="3-collisionevent">3 数据结构：CollisionEvent</h2>
<p>文件：<code>carla/sensor/data/CollisionEvent.h</code></p>
<p>该结构用于表示碰撞时的核心信息，封装了碰撞双方的 Actor 信息和冲击矢量，便于在物理分析、异常事件检测等应用中使用。</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">CollisionEvent</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">self_actor</span><span class="p">;</span><span class="w">           </span><span class="c1">// 当前传感器所属对象（如车辆本体）</span>
<span class="w">  </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">other_actor</span><span class="p">;</span><span class="w">          </span><span class="c1">// 碰撞的另一个对象（如行人、路灯）</span>
<span class="w">  </span><span class="n">geom</span><span class="o">::</span><span class="n">Vector3D</span><span class="w"> </span><span class="n">normal_impulse</span><span class="p">;</span><span class="w">   </span><span class="c1">// 碰撞时的冲击力向量（单位 N·s）</span>
<span class="p">};</span>
</code></pre></div>
<ul>
<li><code>self_actor</code> 与 <code>other_actor</code> 提供了 Actor 的 ID 和类型等元信息，便于在客户端快速识别。</li>
<li><code>normal_impulse</code> 用于衡量碰撞强度，是三维向量，表示冲击的方向和幅值。</li>
</ul>
<hr />
<h2 id="4-collisioneventserializer">4 序列化器分析：CollisionEventSerializer</h2>
<p>文件：<code>sensor/s11n/CollisionEventSerializer.{h,cpp}</code></p>
<p>该类用于将 <code>CollisionEvent</code> 数据结构打包为字节流 RawData 并进行网络传输，支持高效的序列化和反序列化。</p>
<h3 id="41">4.1 数据托运结构</h3>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Data</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">self_actor</span><span class="p">;</span>
<span class="w">  </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">other_actor</span><span class="p">;</span>
<span class="w">  </span><span class="n">geom</span><span class="o">::</span><span class="n">Vector3D</span><span class="w"> </span><span class="n">normal_impulse</span><span class="p">;</span>
<span class="w">  </span><span class="n">MSGPACK_DEFINE_ARRAY</span><span class="p">(</span><span class="n">self_actor</span><span class="p">,</span><span class="w"> </span><span class="n">other_actor</span><span class="p">,</span><span class="w"> </span><span class="n">normal_impulse</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div>
<p>该结构通过 <code>MSGPACK_DEFINE_ARRAY</code> 宏定义，使其具备序列化能力，便于通过 <code>MsgPack</code> 编码传输。</p>
<h3 id="42-server">4.2 序列化（Server 端）</h3>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">SensorT</span><span class="o">&gt;</span>
<span class="k">static</span><span class="w"> </span><span class="n">Buffer</span><span class="w"> </span><span class="n">Serialize</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SensorT</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span>
<span class="w">    </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">self_actor</span><span class="p">,</span>
<span class="w">    </span><span class="n">rpc</span><span class="o">::</span><span class="n">Actor</span><span class="w"> </span><span class="n">other_actor</span><span class="p">,</span>
<span class="w">    </span><span class="n">geom</span><span class="o">::</span><span class="n">Vector3D</span><span class="w"> </span><span class="n">normal_impulse</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">MsgPack</span><span class="o">::</span><span class="n">Pack</span><span class="p">(</span><span class="n">Data</span><span class="p">{</span><span class="n">self_actor</span><span class="p">,</span><span class="w"> </span><span class="n">other_actor</span><span class="p">,</span><span class="w"> </span><span class="n">normal_impulse</span><span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>此函数在服务端运行，将 <code>CollisionEvent</code> 信息打包为 <code>Buffer</code>，随后通过 RPC 系统发送至客户端。</li>
</ul>
<h3 id="43-client">4.3 反序列化（Client 端）</h3>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">SharedPtr</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Deserialize</span><span class="p">(</span><span class="n">RawData</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SharedPtr</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">data</span><span class="o">::</span><span class="n">CollisionEvent</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>客户端接收到 <code>RawData</code> 后，会通过该方法重构为 <code>CollisionEvent</code> 对象并触发回调函数。</li>
</ul>
<blockquote>
<p>注：该模块采用轻量级高性能的 <code>MessagePack</code> 作为数据序列化方案，编码数据体积远小于 JSON 或 XML，适用于实时仿真系统。</p>
</blockquote>
<hr />
<h2 id="5-rawdata-sensordata">5 RawData 与 SensorData 概述</h2>
<p>在 CARLA 的传感器架构中，所有传感器数据在底层都通过 <code>RawData</code> 进行传输，而结构化的数据（如碰撞事件）则会通过 <code>SensorData</code> 类进一步封装。这两者的关系如下：</p>
<ul>
<li><code>RawData</code>：底层的字节数据容器，封装网络传输数据、帧号、传感器位置等信息。</li>
<li><code>SensorData</code>：从 <code>RawData</code> 派生出的抽象类，表示可由客户端识别的数据类型。</li>
</ul>
<p>以 <code>CollisionEvent</code> 为例，其结构如下：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// RawData（基类）</span>
<span class="k">class</span><span class="w"> </span><span class="nc">RawData</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">GetFrame</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="nf">GetTimestamp</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">rpc</span><span class="o">::</span><span class="n">Transform</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">GetSensorTransform</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="nf">begin</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w">  </span><span class="c1">// 数据起始位置</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w">           </span><span class="c1">// 数据大小</span>
<span class="p">};</span>

<span class="c1">// SensorData（结构化数据封装）</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SensorData</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">EnableSharedFromThis</span><span class="o">&lt;</span><span class="n">SensorData</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="k">private</span><span class="w"> </span><span class="n">NonCopyable</span><span class="w"> </span><span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
<span class="w">  </span><span class="n">SensorData</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">timestamp</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">rpc</span><span class="o">::</span><span class="n">Transform</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sensor_transform</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// CollisionEvent（具体数据结构）</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CollisionEvent</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">SensorData</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 包含 self_actor, other_actor, normal_impulse</span>
<span class="p">};</span>
</code></pre></div>
<h3 id="51">5.1 在序列化器中的角色</h3>
<ul>
<li>服务端将 <code>CollisionEvent</code> 数据打包进 <code>RawData</code> 缓冲区；</li>
<li>客户端调用 <code>Deserialize(RawData &amp;&amp;)</code>，根据序列化协议反向构造 <code>SensorData</code> 对象；</li>
<li>最终通过 <code>sensor.listen()</code> 回调函数传递给 Python 用户使用。</li>
</ul>
<p>该结构便于扩展，所有结构化数据传感器（如 IMU、碰撞、GNSS）均基于这一机制实现。</p>
<hr />
<h2 id="6-python-api">6 Python API 使用示例</h2>
<blockquote>
<p>注：以下示例假定你已在主程序中定义了 <code>client</code>、<code>vehicle</code>、<code>transform</code> 等变量。</p>
</blockquote>
<div class="highlight"><pre><span></span><code># 定义回调函数：当碰撞发生时，将调用该函数处理事件信息
def on_collision(event):
    actor = event.other_actor              # 获取碰撞对方的 Actor 对象
    impulse = event.normal_impulse        # 获取碰撞冲击向量（Vector3D）
    print(f&quot;发生碰撞！对象类型：{actor.type_id}，冲击向量：{impulse}&quot;)

# 以下变量需在外部提前定义（通常在主程序中）：
# client = carla.Client(&#39;localhost&#39;, 2000)  # 连接模拟器
# world = client.get_world()  # 获取当前 CARLA 世界对象
# blueprint_library = world.get_blueprint_library()  # 获取蓝图库
# transform = carla.Transform(...)  # 定义传感器相对位置
# vehicle = world.spawn_actor(...)  # 目标车辆对象

# 从蓝图库中检索碰撞传感器蓝图（类型为 sensor.other.collision）
bp = blueprint_library.find(&#39;sensor.other.collision&#39;)

# 生成传感器对象并附着到已有车辆上
sensor = world.spawn_actor(bp, transform, attach_to=vehicle)

# 注册监听函数，回调将持续监听碰撞事件
sensor.listen(on_collision)
</code></pre></div>
<ul>
<li><code>on_collision</code> 是监听器函数，在碰撞事件到达时执行。</li>
<li>可进一步拓展为：记录日志、分析速度/角度、触发避障逻辑等。</li>
</ul>
<hr />
<h2 id="7">7 文件分布</h2>
<table>
<thead>
<tr>
<th>文件</th>
<th>位置</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CollisionEvent.h</code></td>
<td><code>sensor/data/</code></td>
<td>定义碰撞事件数据结构</td>
</tr>
<tr>
<td><code>CollisionEventSerializer.h/.cpp</code></td>
<td><code>sensor/s11n/</code></td>
<td>编码/解码事件数据为 RawData</td>
</tr>
<tr>
<td><code>RawData.h</code></td>
<td><code>sensor/</code></td>
<td>抽象数据包装基类，用于数据收发</td>
</tr>
<tr>
<td><code>Python 示例</code></td>
<td>用户自定义脚本</td>
<td>调用传感器、监听回调、打印信息等</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="8">8 小结与拓展</h2>
<ul>
<li><code>sensor.other.collision</code> 是 CARLA 中最轻量级的事件传感器之一，仅在物理碰撞时触发。</li>
<li>序列化逻辑采用 MsgPack + 自定义数据结构，传输高效、实现简洁。</li>
<li>事件回调机制适合用于行为分析、数据驱动建模、仿真故障检测等场景。</li>
<li>可扩展场景包括：</li>
<li>联合 IMU/GNSS 分析事故发生前后的运动状态</li>
<li>结合图像数据回溯碰撞现场</li>
<li>搭配控制模块生成碰撞规避策略</li>
<li>增加时间戳、碰撞位置、速度向量等字段，实现更精细建模</li>
</ul>
<hr />
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/OpenHUTB/carla_doc" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="https://cdn.rawgit.com/knsv/mermaid/6.0.0/dist/mermaid.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script>
      <script src="../../js/umlconvert.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
