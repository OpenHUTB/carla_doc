<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Util模块技术文档 - 人车模拟器</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Util\u6a21\u5757\u6280\u672f\u6587\u6863";
        var mkdocs_page_input_path = "modules/Util.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> 人车模拟器
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">首页</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">人车模拟器</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Util模块技术文档</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/OpenHUTB/carla_doc/edit/master/docs/modules/Util.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="util">Util模块技术文档</h1>
<h2 id="1">1. 概述</h2>
<p>CARLA的Util模块提供了一系列底层的C++工具类，用于简化对Unreal世界中各种对象、集合体、导航、随机数以及调试绘制等功能的操作。Util模块位于源码路径<code>Unreal/CarlaUE4/Plugins/Carla/Source/Carla/Util</code>下，包含29个源文件和头文件，涵盖从附件管理、随机引擎到导航网络、文件解析、调试绘制等多方面工具。</p>
<h3 id="11-util">1.1 Util模块与其它模块的调用关系图</h3>
<p><pre class="mermaid"><code>flowchart LR
  subgraph Util 模块
    A[UActorAttacher] --&gt;|Attach| B[Game/Vehicle]
    C[UBoundingBoxCalculator] --&gt;|Calc BB| D[RPC Server]
    E[FDebugShapeDrawer] --&gt;|Draw| F[UWorld]
    G[ProceduralCustomMesh] --&gt;|Mesh| H[OpenDriveGenerator]
    I[FIniFile] --&gt;|Config| J[Plugin Settings]
  end
  subgraph 其他模块
    B --&gt;|Spawn Sensor| K[Sensor Module]
    D --&gt;|Serialize| L[Client Python]
    H --&gt;|Render Road| M[Traffic Module]
  end</code></pre>
- <code>UActorAttacher</code> 为 Game 与 Vehicle 模块提供动态附加接口；
- <code>UBoundingBoxCalculator</code> 在 RPC Server 中被调用，用于生成网络序列化的包围盒数据；
- <code>FDebugShapeDrawer</code> 直接作用于 UWorld，渲染调试原语；
- <code>ProceduralCustomMesh</code> 与 OpenDriveGenerator、RoadPainterWrapper 协作，呈现场景几何；
- <code>FIniFile</code> 在插件启动时读取外部配置，并在各模块初始化时注入参数。</p>
<h3 id="12-util">1.2 Util模块关键流程图</h3>
<pre class="mermaid"><code>flowchart TD
  subgraph 模块初始化
    A1[FIniFile: 读取 .ini 配置]
    A2[ObjectRegister: 注册全局管理对象]
    A1 --&gt; A2
    A3[RandomEngine: 初始化随机数引擎]
    A2 --&gt; A3
    A4[NoWorldOffsetSceneComponent: 设置世界坐标稳定]
    A3 --&gt; A4
  end

  subgraph 仿真执行循环
    B1[FCarlaEngine Tick]
    B1 --&gt; B2[UActorAttacher: 附加传感器至车辆]
    B2 --&gt; B3[RandomEngine: 生成随机参数]
    B3 --&gt; B4[UBoundingBoxCalculator: 计算各 Actor 包围盒]
    B4 --&gt; B5[FDebugShapeDrawer: 绘制调试形状]
    B5 --&gt; B6[ProceduralCustomMesh: 动态生成自定义网格]
    B6 --&gt; B7[NavigationMesh: 更新/重构导航网格]
    B7 --&gt; B8[RayTracer: 执行射线检测]
    B8 --&gt; B9[FCarlaServer: 聚合 &amp; RPC 序列化]
  end</code></pre>
<h3 id="13-util">1.3 Util模块关键类表</h3>
<table>
<thead>
<tr>
<th>子模块</th>
<th>功能简介</th>
<th>源码位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>ActorAttacher</td>
<td>将任意 <code>USceneComponent</code>（相机、传感器等）动态附加到 <code>AActor</code> 上</td>
<td><code>Util/ActorAttacher.h</code><br><code>Util/ActorAttacher.cpp</code></td>
</tr>
<tr>
<td>EmptyActor</td>
<td>提供一个空的 <code>AActor</code> 占位类，用于测试或性能基准</td>
<td><code>Util/EmptyActor.h</code><br><code>Util/EmptyActor.cpp</code></td>
</tr>
<tr>
<td>NoWorldOffsetSceneComponent</td>
<td>定义不随世界坐标偏移的场景组件，用于 UI 或调试可视化</td>
<td><code>Util/NoWorldOffsetSceneComponent.h</code><br><code>Util/NoWorldOffsetSceneComponent.cpp</code></td>
</tr>
<tr>
<td>ActorWithRandomEngine &amp; RandomEngine</td>
<td>封装 C++ 标准随机数引擎，支持可复现随机行为</td>
<td><code>Util/ActorWithRandomEngine.h</code><br><code>Util/ActorWithRandomEngine.cpp</code><br><code>Util/RandomEngine.h</code><br><code>Util/RandomEngine.cpp</code></td>
</tr>
<tr>
<td>ScopedStack</td>
<td>基于 RAII 的作用域栈管理工具，可跟踪嵌套调用或状态</td>
<td><code>Util/ScopedStack.h</code></td>
</tr>
<tr>
<td>BoundingBox &amp; BoundingBoxCalculator</td>
<td>定义 <code>FBoundingBox</code> 结构，并提供包围盒到世界/屏幕坐标的转换计算</td>
<td><code>Util/BoundingBox.h</code><br><code>Util/BoundingBox.cpp</code><br><code>Util/BoundingBoxCalculator.h</code><br><code>Util/BoundingBoxCalculator.cpp</code></td>
</tr>
<tr>
<td>DebugShapeDrawer</td>
<td>在场景中绘制线框、点、面等调试几何体</td>
<td><code>Util/DebugShapeDrawer.h</code><br><code>Util/DebugShapeDrawer.cpp</code></td>
</tr>
<tr>
<td>ProceduralCustomMesh</td>
<td>运行时生成或修改 <code>UProceduralMeshComponent</code> 的自定义网格</td>
<td><code>Util/ProceduralCustomMesh.h</code></td>
</tr>
<tr>
<td>RayTracer</td>
<td>封装射线检测接口，用于碰撞检测和视线跟踪</td>
<td><code>Util/RayTracer.h</code><br><code>Util/RayTracer.cpp</code></td>
</tr>
<tr>
<td>NavigationMesh</td>
<td>与 Unreal 导航网格系统交互，支持路径查询</td>
<td><code>Util/NavigationMesh.h</code><br><code>Util/NavigationMesh.cpp</code></td>
</tr>
<tr>
<td>RoadPainterWrapper</td>
<td>动态调用 Unreal 道路绘制接口，在关卡中绘制道路或车道线</td>
<td><code>Util/RoadPainterWrapper.h</code><br><code>Util/RoadPainterWrapper.cpp</code></td>
</tr>
<tr>
<td>EnvironmentObject</td>
<td>封装地图中静态物体（建筑、路牌、信号灯等）的通用接口</td>
<td><code>Util/EnvironmentObject.h</code></td>
</tr>
<tr>
<td>IniFile</td>
<td>读取/写入 Unreal 风格的 <code>.ini</code> 配置文件</td>
<td><code>Util/IniFile.h</code></td>
</tr>
<tr>
<td>ObjectRegister</td>
<td>全局对象注册器，管理插件内部可被索引的对象</td>
<td><code>Util/ObjectRegister.h</code><br><code>Util/ObjectRegister.cpp</code></td>
</tr>
<tr>
<td>NonCopyable</td>
<td>禁止拷贝、仅允许移动的基类模板，用于防止资源误拷贝</td>
<td><code>Util/NonCopyable.h</code></td>
</tr>
<tr>
<td>ListView</td>
<td>封装 Unreal Slate/UMG 列表视图控件的常用操作</td>
<td><code>Util/ListView.h</code></td>
</tr>
</tbody>
</table>
<h2 id="2-util">2. Util核心功能类</h2>
<h3 id="21-uactorattacheractor">2.1 UActorAttacher：Actor 附加器</h3>
<h4 id="211">2.1.1 概要</h4>
<p><code>UActorAttacher</code>是 CARLA Unreal 插件中用于在运行时将“子” Actor（如传感器、摄像头等）附加到“父” Actor（如车辆、建筑物等）上的静态工具类，支持三种常用的附加模式：
- 刚性附加（Rigid）：调用 <code>Child-&gt;AttachToActor(Parent, FAttachmentTransformRules::KeepRelativeTransform)</code>；
- 弹簧臂附加（SpringArm）：调用<code>UActorAttacher_AttachActorsWithSpringArm(Child, Parent)</code>；
- “幽灵”弹簧臂附加（SpringArmGhost）：调用<code>UActorAttacher_AttachActorsWithSpringArmGhost(Child, Parent)</code>。</p>
<p>在内部，<code>AttachActors</code> 会根据传入的 <code>EAttachmentType</code> 枚举选择不同的实现分支，或调用 <code>Unreal</code> 原生的 <code>AttachToActor</code>，或动态创建并配置 <code>USpringArmComponent</code> 和 <code>UChildActorComponent</code>，实现带碰撞测试或不带碰撞测试的带臂附加效果。
最后将子 Actor 的所有者（Owner）设置为父 Actor，以便后续的生命周期和 RPC 权限管理</p>
<h4 id="212">2.1.2 关键方法详解</h4>
<ol>
<li><code>AttachActors</code>
<div class="highlight"><pre><span></span><code><span class="n">UFUNCTION</span><span class="p">(</span><span class="n">BlueprintCallable</span><span class="p">,</span><span class="w"> </span><span class="n">Category</span><span class="o">=</span><span class="s">&quot;CARLA|Actor Attacher&quot;</span><span class="p">)</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">AttachActors</span><span class="p">(</span><span class="n">AActor</span><span class="w"> </span><span class="o">*</span><span class="n">Child</span><span class="p">,</span><span class="w"> </span><span class="n">AActor</span><span class="w"> </span><span class="o">*</span><span class="n">Parent</span><span class="p">,</span><span class="w"> </span><span class="n">EAttachmentType</span><span class="w"> </span><span class="n">AttachmentType</span><span class="p">);</span>
</code></pre></div></li>
<li>作用：根据传入的AttachmentType分发到三种附加实现方式，最后执行<code>Child-&gt;SetOwner(Parent)</code>，将子 Actor 的所有者设为父 Actor</li>
<li>关键变量：</li>
<li><code>Child</code>、<code>Parent</code>：要附加的子/父 Actor 指针：</li>
<li><code>AttachmentType</code>：枚举值决定调用哪种附加方式。</li>
<li>
<p>使用场景：在仿真初始化或 <code>BeginPlay</code> 阶段将传感器、摄像头等以不同跟随模式挂载到车辆或其他移动 Actor 上。</p>
</li>
<li>
<p><code>UActorAttacher_AttachActorsWithSpringArm</code>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">UActorAttacher_AttachActorsWithSpringArm</span><span class="p">(</span><span class="n">AActor</span><span class="w"> </span><span class="o">*</span><span class="n">Child</span><span class="p">,</span><span class="w"> </span><span class="n">AActor</span><span class="w"> </span><span class="o">*</span><span class="n">Parent</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// 1. 动态创建 SpringArmComponent</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">SpringArm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NewObject</span><span class="o">&lt;</span><span class="n">USpringArmComponent</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Parent</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// 2. 计算子 Actor 相对位置并重置位置</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">ChildLocation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">Child</span><span class="o">-&gt;</span><span class="n">GetActorLocation</span><span class="p">();</span>
<span class="w">  </span><span class="n">Child</span><span class="o">-&gt;</span><span class="n">SetActorLocation</span><span class="p">(</span><span class="n">FVector</span><span class="o">::</span><span class="n">ZeroVector</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// 3. 配置弹簧臂属性</span>
<span class="w">  </span><span class="n">SpringArm</span><span class="o">-&gt;</span><span class="n">TargetOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FVector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">30.0f</span><span class="p">);</span>
<span class="w">  </span><span class="n">SpringArm</span><span class="o">-&gt;</span><span class="n">bDoCollisionTest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="n">SpringArm</span><span class="o">-&gt;</span><span class="n">SetRelativeRotation</span><span class="p">(</span><span class="n">FRotationMatrix</span><span class="o">::</span><span class="n">MakeFromX</span><span class="p">(</span><span class="n">ChildLocation</span><span class="p">).</span><span class="n">Rotator</span><span class="p">());</span>
<span class="w">  </span><span class="n">SpringArm</span><span class="o">-&gt;</span><span class="n">SetupAttachment</span><span class="p">(</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">GetRootComponent</span><span class="p">());</span>
<span class="w">  </span><span class="n">SpringArm</span><span class="o">-&gt;</span><span class="n">TargetArmLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ChildLocation</span><span class="p">.</span><span class="n">Size</span><span class="p">();</span>
<span class="w">  </span><span class="n">SpringArm</span><span class="o">-&gt;</span><span class="n">bEnableCameraRotationLag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="n">SpringArm</span><span class="o">-&gt;</span><span class="n">CameraRotationLagSpeed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">8.0f</span><span class="p">;</span>
<span class="w">  </span><span class="n">SpringArm</span><span class="o">-&gt;</span><span class="n">bInheritPitch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="n">SpringArm</span><span class="o">-&gt;</span><span class="n">bInheritRoll</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="n">SpringArm</span><span class="o">-&gt;</span><span class="n">bInheritYaw</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="n">SpringArm</span><span class="o">-&gt;</span><span class="n">AttachToComponent</span><span class="p">(</span>
<span class="w">      </span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">GetRootComponent</span><span class="p">(),</span>
<span class="w">      </span><span class="n">FAttachmentTransformRules</span><span class="o">::</span><span class="n">KeepRelativeTransform</span><span class="p">);</span>
<span class="w">  </span><span class="n">SpringArm</span><span class="o">-&gt;</span><span class="n">RegisterComponent</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// 4. 创建并附加 ChildActorComponent</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">ChildComp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NewObject</span><span class="o">&lt;</span><span class="n">UChildActorComponent</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Parent</span><span class="p">);</span>
<span class="w">  </span><span class="n">ChildComp</span><span class="o">-&gt;</span><span class="n">SetupAttachment</span><span class="p">(</span>
<span class="w">      </span><span class="n">SpringArm</span><span class="p">,</span>
<span class="w">      </span><span class="n">USpringArmComponent</span><span class="o">::</span><span class="n">SocketName</span><span class="p">);</span>
<span class="w">  </span><span class="n">Child</span><span class="o">-&gt;</span><span class="n">AttachToComponent</span><span class="p">(</span>
<span class="w">      </span><span class="n">ChildComp</span><span class="p">,</span>
<span class="w">      </span><span class="n">FAttachmentTransformRules</span><span class="o">::</span><span class="n">KeepRelativeTransform</span><span class="p">);</span>
<span class="w">  </span><span class="n">ChildComp</span><span class="o">-&gt;</span><span class="n">RegisterComponent</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></p>
</li>
<li>作用：利用 <code>USpringArmComponent</code> 自动实现带碰撞测试的“弹簧臂”跟随，使子 Actor 始终保持与父 Actor 之间的指定距离和方向</li>
<li>关键变量：</li>
<li><code>ChildLocation</code>：用于计算臂长和设置旋转方向；</li>
<li><code>TargetOffset</code>、<code>bDoCollisionTest</code>、<code>TargetArmLength</code>、<code>CameraRotationLagSpeed</code>：分别决定臂的偏移、高度、碰撞行为及旋转滞后。</li>
<li>使用场景：驾驶视角摄像头或第三人称摄像机跟随，需保持一定距离并对地形碰撞自动校正。</li>
</ol>
<h3 id="22-aactorwithrandomengine">2.2 AActorWithRandomEngine：随机引擎注入器</h3>
<h4 id="221">2.2.1 概要</h4>
<p><code>AActorWithRandomEngine</code> 是 CARLA 插件中用于支持确定性随机行为的抽象 Actor 基类， 位于 <code>CarlaUE4/Plugins/Carla/Source/Carla/Util/ActorWithRandomEngine.*</code>。该类内置了一个 <code>URandomEngine</code> 实例，并通过固定或可配置的种子（Seed）初始化，从而实现可重现的随机数序列。并在 <code>Blueprint/C++</code> 中通过<code>GetRandomEngine</code>、<code>GetSeed</code>、<code>SetSeed</code> 提供访问与修改接口。</p>
<p>该类支持在编辑器中配置种子值，或启用自动生成随机种子。在构造阶段（Construction）或属性变更时，内部的随机引擎会根据当前种子重新初始化，确保每次仿真运行的随机行为可控且可复现。</p>
<h4 id="222">2.2.2 关键方法详解</h4>
<ol>
<li><code>OnConstruction</code>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">AActorWithRandomEngine::OnConstruction</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">FTransform</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Transform</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Super</span><span class="o">::</span><span class="n">OnConstruction</span><span class="p">(</span><span class="n">Transform</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bGenerateRandomSeed</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">Seed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FMath</span><span class="o">::</span><span class="n">Rand</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">RandomEngine</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">RandomEngine</span><span class="o">-&gt;</span><span class="n">Initialize</span><span class="p">(</span><span class="n">Seed</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></li>
<li>作用：在 Actor 被放置或属性变更后调用，用于根据当前配置的种子值初始化随机引擎，确保每次 Actor 构建时，随机引擎的状态与当前种子一致，从而实现可控的随机行为。</li>
<li>关键变量：</li>
<li>
<p><code>Transform</code>：Actor 在编辑器或运行时“放置”时的世界变换信息，包含位置、旋转、缩放，通常用于根据初始位置执行额外逻辑。</p>
</li>
<li>
<p><code>SetSeed</code>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">AActorWithRandomEngine::SetSeed</span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">InSeed</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Seed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">InSeed</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">RandomEngine</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">RandomEngine</span><span class="o">-&gt;</span><span class="n">Initialize</span><span class="p">(</span><span class="n">Seed</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
</li>
<li>作用：设置新的种子值，并重新初始化随机引擎，以改变随机行为的序列。</li>
<li>关键变量：</li>
<li><code>InSeed</code>：从外部传入的新种子值，用于替换当前的 Seed;</li>
<li>`RandomEngine：内部使用的随机引擎实例，调用随机引擎的初始化方法，将其内部状态重置为基于新 Seed 的起始状态。</li>
<li><code>seed</code>：当前使用的种子值，默认值为 123456789。</li>
</ol>
<p>#### 2.2.3 使用示例
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">AMyRandomActor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">AActorWithRandomEngine</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">GENERATED_BODY</span><span class="p">()</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">BeginPlay</span><span class="p">()</span><span class="w"> </span><span class="k">override</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Super</span><span class="o">::</span><span class="n">BeginPlay</span><span class="p">();</span>

<span class="w">        </span><span class="c1">// 使用随机引擎生成一个 0 到 100 之间的整数</span>
<span class="w">        </span><span class="n">int32</span><span class="w"> </span><span class="n">RandomValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetRandomEngine</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetUniformIntInRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Log</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Generated Random Value: %d&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">RandomValue</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="c1">// 创建一个继承自 AActorWithRandomEngine 的自定义 Actor</span>
</code></pre></div>
- 说明：此示例展示了如何在自定义的 <code>AMyRandomActor</code> 中复用 <code>AActorWithRandomEngine</code> 提供的随机引擎功能，并在游戏开始时生成一个 0–100 范围内的随机整数并输出日志。</p>
<h2 id="23-boundingbox">2.3 BoundingBox相关类</h2>
<h3 id="231-fboundingbox">2.3.1 FBoundingBox：边界框结构</h3>
<h4 id="_1">概要</h4>
<p><code>FBoundingBox</code>是一个BlueprintType的USTRUCT，用于在C++与BluePrint间传递和操作三维边界框信息。CARLA 中所有 Actor（车辆、行人、交通标志、静态网格等）均可通过该结构表示其局部边界框，方便后续在世界或摄像机坐标下进行投影、碰撞检测或可视化渲染。</p>
<h4 id="_2">成员详解</h4>
<p><div class="highlight"><pre><span></span><code><span class="n">USTRUCT</span><span class="p">(</span><span class="n">BlueprintType</span><span class="p">)</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">CARLA_API</span><span class="w"> </span><span class="n">FBoundingBox</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">GENERATED_BODY</span><span class="p">()</span>

<span class="w">  </span><span class="c1">/// 边界框相对于其所有者的原点</span>
<span class="w">  </span><span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span><span class="w"> </span><span class="n">BlueprintReadWrite</span><span class="p">)</span>
<span class="w">  </span><span class="n">FVector</span><span class="w"> </span><span class="n">Origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">};</span>

<span class="w">  </span><span class="c1">/// 边界框的半径范围（沿 X/Y/Z 方向的一半长度）</span>
<span class="w">  </span><span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span><span class="w"> </span><span class="n">BlueprintReadWrite</span><span class="p">)</span>
<span class="w">  </span><span class="n">FVector</span><span class="w"> </span><span class="n">Extent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">};</span>

<span class="w">  </span><span class="c1">/// 边界框的旋转（相对于父 Actor 的局部旋转）</span>
<span class="w">  </span><span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span><span class="w"> </span><span class="n">BlueprintReadWrite</span><span class="p">)</span>
<span class="w">  </span><span class="n">FRotator</span><span class="w"> </span><span class="n">Rotation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">};</span>
<span class="p">};</span>
</code></pre></div>
- Origin：包围盒中心点在父 Actor 局部坐标系下的位置；
- Extent：包围盒在三个轴上的半尺寸，用于计算 Min/Max 边界；
- Rotation：包围盒相对于父 Actor 局部坐标系的欧拉旋转。该设计借鉴自 Unreal 引擎中 UBoxComponent 的中心/Extent/Rotation 表示。</p>
<h3 id="232-uboundingboxcalculator">2.3.2 UBoundingBoxCalculator：边界框计算器</h3>
<h4 id="_3">概要</h4>
<p><code>UBoundingBoxCalculator</code> 是一个派生自 <code>UBlueprintFunctionLibrary</code> 的静态函数集，负责根据不同 Actor 或网格类型，提取或合成对应的 FBoundingBox 信息。</p>
<h4 id="_4">关键方法详解</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能简介</th>
<th>参数说明</th>
<th>返回值 / 输出</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>GetActorBoundingBox</strong></td>
<td>根据传入的 <code>AActor*</code> 类型动态分支：<br>– 车辆 → 调用 <code>GetVehicleBoundingBox</code><br>– 行人 → 调用 <code>GetCharacterBoundingBox</code><br>– 交通标志 → 合并触发体包围盒<br>– 其他 → 收集并合并所有网格组件包围盒。</td>
<td><code>const AActor* Actor</code> — 待计算边界的 Actor 指针<br><code>uint8 InTagQueried</code> — 按标签筛选（默认 <code>0xFF</code>，不过滤）</td>
<td><code>FBoundingBox</code> — Actor 局部空间包围盒</td>
</tr>
<tr>
<td><strong>GetVehicleBoundingBox</strong></td>
<td>提取车辆内部包围变换与半宽度，额外检测可能挂载的骨骼或子模型，通过 Socket 扩展范围后，应用组件到世界变换。</td>
<td><code>const ACarlaWheeledVehicle* Vehicle</code><br><code>uint8 InTagQueried</code></td>
<td><code>FBoundingBox</code> — 世界空间包围盒</td>
</tr>
<tr>
<td><strong>GetCharacterBoundingBox</strong></td>
<td>基于 <code>UCapsuleComponent</code> 从半径与半高生成行人包围盒，并应用组件到世界空间的变换。</td>
<td><code>const ACharacter* Character</code><br><code>uint8 InTagQueried</code></td>
<td><code>FBoundingBox</code> — 世界空间包围盒</td>
</tr>
<tr>
<td><strong>GetTrafficLightBoundingBox</strong></td>
<td>针对 <code>ATrafficLightBase</code> 中各灯体或触发体调用 <code>CombineBBsOfActor</code> 进行按距离与标签合并，按标签筛选后输出多段包围盒。</td>
<td><code>const ATrafficLightBase* TrafficLight</code><br><code>TArray&lt;FBoundingBox&gt;&amp; OutBB</code><br><code>TArray&lt;uint8&gt;&amp; OutTag</code><br><code>uint8 InTagQueried</code></td>
<td>—（通过 <code>OutBB</code>/<code>OutTag</code> 返回多个包围盒及对应标签）</td>
</tr>
<tr>
<td><strong>GetStaticMeshBoundingBox</strong></td>
<td>直接使用 <code>UStaticMesh::GetBoundingBox()</code> 获得包围框，再封装为 <code>FBoundingBox</code>。</td>
<td><code>const UStaticMesh* StaticMesh</code></td>
<td><code>FBoundingBox</code></td>
</tr>
<tr>
<td><strong>GetSkeletalMeshBoundingBox</strong></td>
<td>遍历 LOD 0 顶点缓冲计算 Min/Max，进而求中心与半幅，返回精确顶点包围盒（当前动画姿势未考虑）。</td>
<td><code>const USkeletalMesh* SkeletalMesh</code></td>
<td><code>FBoundingBox</code></td>
</tr>
<tr>
<td><strong>GetISMBoundingBox</strong></td>
<td>对 <code>UInstancedStaticMeshComponent</code> 每个实例 (PerInstanceSMData) 应用父组件变换，逐个生成并返回 <code>FBoundingBox</code>。</td>
<td><code>UInstancedStaticMeshComponent* ISMComp</code><br><code>TArray&lt;FBoundingBox&gt;&amp; OutBoundingBox</code></td>
<td>—（通过 <code>OutBoundingBox</code> 返回实例包围盒列表）</td>
</tr>
<tr>
<td><strong>GetBBsOfStaticMeshComponents</strong></td>
<td>遍历给定静态网格组件数组，按可见性与标签过滤后，提取并应用组件变换，累积输出包围盒与标签。</td>
<td><code>const TArray&lt;UStaticMeshComponent*&gt;&amp; StaticMeshComps</code><br><code>TArray&lt;FBoundingBox&gt;&amp; OutBB</code><br><code>TArray&lt;uint8&gt;&amp; OutTag</code><br><code>uint8 InTagQueried</code></td>
<td>—（通过 <code>OutBB</code>/<code>OutTag</code> 返回）</td>
</tr>
<tr>
<td><strong>GetBBsOfSkeletalMeshComponents</strong></td>
<td>与上同，针对骨骼网格组件数组；对每个可见且符合标签的组件，调用 <code>GetSkeletalMeshBoundingBox</code> 并应用变换后输出。</td>
<td><code>const TArray&lt;USkeletalMeshComponent*&gt;&amp; SkeletalMeshComps</code><br><code>TArray&lt;FBoundingBox&gt;&amp; OutBB</code><br><code>TArray&lt;uint8&gt;&amp; OutTag</code><br><code>uint8 InTagQueried</code></td>
<td>—（通过 <code>OutBB</code>/<code>OutTag</code> 返回）</td>
</tr>
<tr>
<td><strong>GetBoundingBoxOfActors</strong></td>
<td>对一组 <code>AActor*</code>，批量调用 <code>GetBBsOfActor</code> 并合并所有返回的包围盒列表，直接返回结果数组。</td>
<td><code>const TArray&lt;AActor*&gt;&amp; Actors</code><br><code>uint8 InTagQueried</code></td>
<td><code>TArray&lt;FBoundingBox&gt;</code></td>
</tr>
<tr>
<td><strong>GetBBsOfActor</strong></td>
<td>对单个 <code>AActor*</code>：排除特殊蓝图或不可见组件，分类调用各 <code>Get*BoundingBox</code> 系列和 <code>Get*Components</code> 系列方法，返回所有包围盒。</td>
<td><code>const AActor* Actor</code><br><code>uint8 InTagQueried</code></td>
<td><code>TArray&lt;FBoundingBox&gt;</code></td>
</tr>
<tr>
<td><strong>CombineBBs</strong></td>
<td>通用合并 <code>TArray&lt;FBoundingBox&gt;</code> 中所有包围盒为最小包围；基于旋转/Extent 计算全局 Min/Max 再取中心与半幅。</td>
<td><code>const TArray&lt;FBoundingBox&gt;&amp; BBsToCombine</code></td>
<td><code>FBoundingBox</code></td>
</tr>
<tr>
<td><strong>CombineBoxes</strong></td>
<td>通用合并 <code>TArray&lt;UBoxComponent*&gt;</code>，先转换为 <code>FBoundingBox</code> 再调用通用合并逻辑，输出最小包围盒。</td>
<td><code>const TArray&lt;UBoxComponent *&gt;&amp; BBsToCombine</code></td>
<td><code>FBoundingBox</code></td>
</tr>
<tr>
<td><strong>CombineBBsOfActor</strong></td>
<td>针对单 Actor 静态网格组件的包围列表，按距离阈值与标签合并同类型近邻包围盒，不合并的单个也保留；统计后输出新包围盒与标签。</td>
<td><code>const AActor* Actor</code><br><code>TArray&lt;FBoundingBox&gt;&amp; OutBB</code><br><code>TArray&lt;uint8&gt;&amp; OutTag</code><br><code>float DistanceThreshold</code><br><code>uint8 TagToCombine</code></td>
<td>—（通过 <code>OutBB</code>/<code>OutTag</code> 返回新组合结果）</td>
</tr>
<tr>
<td><strong>GetMeshCompsFromActorBoundingBox</strong></td>
<td>在指定距离阈值内（默认 10000）从 Actor 所有 <code>UStaticMeshComponent</code> 中筛选出位于给定 <code>FBoundingBox</code> 附近的组件列表。</td>
<td><code>const AActor* Actor</code><br><code>const FBoundingBox&amp; InBB</code><br><code>TArray&lt;UStaticMeshComponent*&gt;&amp; OutStaticMeshComps</code></td>
<td>—（通过 <code>OutStaticMeshComps</code> 返回匹配组件）</td>
</tr>
</tbody>
</table>
<h3 id="_5">小结</h3>
<ul>
<li><code>FBoundingBox</code> 提供了统一的包围盒数据结构；</li>
<li><code>UBoundingBoxCalculator</code> 则围绕不同 Actor/组件类型提供了从局部到世界空间的包围盒提取、批量和合并能力；</li>
<li>组合该工具链，可支持 CARLA 中传感器感知、HUD 渲染、碰撞检测及数据采集等多种场景。</li>
</ul>
<h2 id="24-fdebugshapedrawer">2.4 FDebugShapeDrawer：调试形状绘制器</h2>
<h3 id="241">2.4.1 概要</h3>
<p><code>FDebugShapeDrawer</code> 是 CARLA 中用于在 <code>Unreal Engine</code> 世界 (<code>UWorld</code>) 中绘制调试形状的工具类。它通过访问 <code>carla::rpc::DebugShape</code> 对象，根据其定义的形状类型（如点、线、箭头、盒子、字符串等）在世界或 HUD 上进行可视化展示。该类内部使用了 <code>FShapeVisitor</code> 结构体，通过访问者模式处理不同的形状类型，实现了灵活且可扩展的调试绘制机制。</p>
<h3 id="242">2.4.2 使用场景</h3>
<ul>
<li>在仿真过程中实时可视化调试信息，如传感器检测结果、路径规划轨迹等。</li>
<li>在 HUD 上展示关键调试信息，辅助开发和测试。</li>
<li>在大型地图中，通过 <code>ALargeMapManager</code> 进行坐标转换，确保绘制位置的准确性。</li>
</ul>
<h3 id="243">2.4.3 关键方法详解</h3>
<p>1.<code>FDebugShapeDrawer::Draw</code>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">FDebugShapeDrawer::Draw</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">carla</span><span class="o">::</span><span class="n">rpc</span><span class="o">::</span><span class="n">DebugShape</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Shape</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">Visitor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FShapeVisitor</span><span class="p">(</span><span class="n">World</span><span class="p">,</span><span class="w"> </span><span class="n">Shape</span><span class="p">.</span><span class="n">color</span><span class="p">,</span><span class="w"> </span><span class="n">Shape</span><span class="p">.</span><span class="n">life_time</span><span class="p">,</span><span class="w"> </span><span class="n">Shape</span><span class="p">.</span><span class="n">persistent_lines</span><span class="p">);</span>
<span class="w">  </span><span class="n">boost</span><span class="o">::</span><span class="n">variant2</span><span class="o">::</span><span class="n">visit</span><span class="p">(</span><span class="n">Visitor</span><span class="p">,</span><span class="w"> </span><span class="n">Shape</span><span class="p">.</span><span class="n">primitive</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
- 作用：根据传入的<code>DebugShape</code>对象，调用相应的绘制方法在世界或 HUD 上渲染调试形状。
- 实现细节：
  - 构造<code>FShapeVisitor</code>对象，传入当前世界引用、颜色、生命周期和持久化标志。
  - 使用<code>boost::variant2::visit</code>访问<code>Shape.primitive</code>，根据实际的形状类型调用对应的绘制方法。</p>
<p>2.<code>FShapeVisitor::operator() (Arrow)</code>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">FShapeVisitor::operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">Shape</span><span class="o">::</span><span class="n">Arrow</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Arrow</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">FVector</span><span class="w"> </span><span class="n">Begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FVector</span><span class="p">(</span><span class="n">Arrow</span><span class="p">.</span><span class="n">line</span><span class="p">.</span><span class="n">begin</span><span class="p">);</span>
<span class="w">  </span><span class="n">FVector</span><span class="w"> </span><span class="n">End</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">FVector</span><span class="p">(</span><span class="n">Arrow</span><span class="p">.</span><span class="n">line</span><span class="p">.</span><span class="n">end</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// 坐标转换</span>
<span class="w">  </span><span class="n">ALargeMapManager</span><span class="o">*</span><span class="w"> </span><span class="n">LargeMap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UCarlaStatics</span><span class="o">::</span><span class="n">GetLargeMapManager</span><span class="p">(</span><span class="n">World</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">LargeMap</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LargeMap</span><span class="o">-&gt;</span><span class="n">GlobalToLocalLocation</span><span class="p">(</span><span class="n">Begin</span><span class="p">);</span>
<span class="w">    </span><span class="n">End</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">LargeMap</span><span class="o">-&gt;</span><span class="n">GlobalToLocalLocation</span><span class="p">(</span><span class="n">End</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// 箭头向量与变换</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">Diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">End</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Begin</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">FRotator</span><span class="w"> </span><span class="n">LookAt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FRotationMatrix</span><span class="o">::</span><span class="n">MakeFromX</span><span class="p">(</span><span class="n">Diff</span><span class="p">).</span><span class="n">Rotator</span><span class="p">();</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">FTransform</span><span class="w"> </span><span class="n">Transform</span><span class="p">{</span><span class="n">LookAt</span><span class="p">,</span><span class="w"> </span><span class="n">Begin</span><span class="p">};</span>

<span class="w">  </span><span class="c1">// 绘制主干与箭头头部</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">ArrowSize</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mf">1e2f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Arrow</span><span class="p">.</span><span class="n">arrow_size</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">ArrowTipDist</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">Diff</span><span class="p">.</span><span class="n">Size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ArrowSize</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">Thickness</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mf">1e2f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Arrow</span><span class="p">.</span><span class="n">line</span><span class="p">.</span><span class="n">thickness</span><span class="p">;</span>
<span class="w">  </span><span class="n">World</span><span class="o">-&gt;</span><span class="n">PersistentLineBatcher</span><span class="o">-&gt;</span><span class="n">DrawLines</span><span class="p">({</span>
<span class="w">    </span><span class="n">FBatchedLine</span><span class="p">(</span><span class="n">Begin</span><span class="p">,</span><span class="w"> </span><span class="n">End</span><span class="p">,</span><span class="w"> </span><span class="n">Color</span><span class="p">,</span><span class="w"> </span><span class="n">LifeTime</span><span class="p">,</span><span class="w"> </span><span class="n">Thickness</span><span class="p">,</span><span class="w"> </span><span class="n">DepthPriority</span><span class="p">),</span>
<span class="w">    </span><span class="n">FBatchedLine</span><span class="p">(</span>
<span class="w">      </span><span class="n">Transform</span><span class="p">.</span><span class="n">TransformPosition</span><span class="p">(</span><span class="n">FVector</span><span class="p">(</span><span class="n">ArrowTipDist</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="n">ArrowSize</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="n">ArrowSize</span><span class="p">)),</span>
<span class="w">      </span><span class="n">End</span><span class="p">,</span><span class="w"> </span><span class="n">Color</span><span class="p">,</span><span class="w"> </span><span class="n">LifeTime</span><span class="p">,</span><span class="w"> </span><span class="n">Thickness</span><span class="p">,</span><span class="w"> </span><span class="n">DepthPriority</span><span class="p">),</span>
<span class="w">    </span><span class="c1">// ... 其他箭头分支</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
- 解析：
  - 通过 <code>LargeMapManager</code> 将全局坐标转换为本地坐标，保证在大地图下的位置准确性。
  - 计算箭头方向向量 <code>Diff</code> 并生成变换 <code>Transform</code>，用于定位箭头头部。
  - 使用 <code>DrawLines</code> 绘制箭头的主干及四个箭头分支，提高可视化效果。</p>
<h2 id="25-fnavigationmesh">2.5 FNavigationMesh：导航网格管理器</h2>
<h3 id="251">2.5.1 概要</h3>
<p><code>FNavigationMesh</code> 是 CARLA 中用于与 Unreal 导航网格系统交互的工具类，位于 <code>CarlaUE4/Plugins/Carla/Source/Carla/Util/NavigationMesh.*</code>。其主要功能是加载与指定地图名称相关联的导航网格数据，支持路径查询和导航功能。该类通过读取存储为 <code>.bin</code> 文件的导航网格数据，为仿真中的路径规划和智能体导航提供支持。</p>
<h3 id="252">2.5.2 关键方法详解</h3>
<h4 id="load">Load 方法</h4>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">TArray</span><span class="o">&lt;</span><span class="n">uint8</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Load</span><span class="p">(</span><span class="n">FString</span><span class="w"> </span><span class="n">MapName</span><span class="p">);</span>
</code></pre></div>
<ul>
<li><strong>作用</strong>：根据传入的地图名称加载对应的导航网格二进制数据文件。</li>
<li><strong>参数</strong>：</li>
<li><code>MapName</code>：指定地图的名称，用于定位对应的导航网格文件。</li>
<li><strong>返回值</strong>：返回一个 <code>TArray&lt;uint8&gt;</code> 类型的数组，包含导航网格文件的二进制内容。如果加载失败，则返回空数组。</li>
<li><strong>实现逻辑</strong>：</li>
<li><strong>编辑器模式处理</strong>：<ul>
<li>如果在编辑器中运行，地图名称可能会有一个额外的前缀（如 <code>UEDPIE_0_</code>）。代码会移除这个前缀，以确保文件查找的正确性。</li>
<li>例如，原始地图名称为 <code>UEDPIE_0_Town01</code>，校正后变为 <code>Town01</code>。</li>
</ul>
</li>
<li><strong>构建文件名</strong>：<ul>
<li>根据地图名称构建导航网格文件的完整名称，假设文件后缀为 <code>.bin</code>。例如，地图名称为 <code>Town01</code>，则文件名为 <code>Town01.bin</code>。</li>
</ul>
</li>
<li><strong>查找文件</strong>：<ul>
<li>使用 <code>IFileManager::Get().FindFilesRecursive</code> 方法在项目内容目录（<code>FPaths::ProjectContentDir()</code>）中递归查找与导航网格文件名匹配的文件。</li>
</ul>
</li>
<li><strong>加载文件内容</strong>：<ul>
<li>如果找到文件，尝试使用 <code>FFileHelper::LoadFileToArray</code> 方法将文件内容加载到 <code>Content</code> 数组中。</li>
<li>如果加载成功，输出日志信息，提示正在加载的文件名。</li>
<li>如果加载失败，输出错误信息，提示加载失败的文件名。</li>
</ul>
</li>
<li><strong>返回结果</strong>：<ul>
<li>返回加载到的导航网格文件内容（可能为空，如果加载失败）。</li>
</ul>
</li>
</ul>
<h3 id="253">2.5.3 使用示例</h3>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Carla/Util/NavigationMesh.h&quot;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">LoadNavigationMeshData</span><span class="p">(</span><span class="n">FString</span><span class="w"> </span><span class="n">MapName</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 调用 FNavigationMesh::Load 方法加载导航网格数据</span>
<span class="w">    </span><span class="n">TArray</span><span class="o">&lt;</span><span class="n">uint8</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MeshData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FNavigationMesh</span><span class="o">::</span><span class="n">Load</span><span class="p">(</span><span class="n">MapName</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 检查加载结果</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">MeshData</span><span class="p">.</span><span class="n">Num</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Log</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Navigation Mesh data loaded successfully for map &#39;%s&#39;&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">MapName</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 进一步处理加载的导航网格数据</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Failed to load Navigation Mesh data for map &#39;%s&#39;&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">MapName</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><strong>说明</strong>：此示例展示了如何在 CARLA 仿真中加载指定地图的导航网格数据。通过调用 <code>FNavigationMesh::Load</code> 方法，可以获取导航网格的二进制数据，用于后续的路径规划和导航功能。</li>
</ul>
<h3 id="254">2.5.4 注意事项</h3>
<ol>
<li><strong>文件路径</strong>：</li>
<li>确保导航网格文件存储在项目的 <code>Content</code> 目录下，并且文件名与地图名称匹配。</li>
<li><strong>编辑器模式</strong>：</li>
<li>如果在编辑器中运行，需要处理地图名称的前缀问题，以确保文件查找的正确性。</li>
<li><strong>错误处理</strong>：</li>
<li>在实际使用中，应添加适当的错误处理逻辑，以应对文件未找到或加载失败的情况。</li>
</ol>
<h3 id="255">2.5.5 扩展功能</h3>
<ul>
<li><strong>路径查询</strong>：</li>
<li><code>FNavigationMesh</code> 类可以进一步扩展，提供路径查询功能，例如通过调用 Unreal 的导航系统接口，实现从起点到终点的路径规划。</li>
<li><strong>动态更新</strong>：</li>
<li>支持在运行时动态更新导航网格，以适应场景中动态变化的障碍物或路径。</li>
</ul>
<p>通过 <code>FNavigationMesh</code> 类，CARLA 仿真系统能够高效地加载和管理导航网格数据，为智能体的路径规划和导航功能提供坚实的基础。</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/OpenHUTB/carla_doc" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="https://cdn.rawgit.com/knsv/mermaid/6.0.0/dist/mermaid.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script>
      <script src="../../js/umlconvert.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
