<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>CARLA OpenDriveParser 说明文档 - 人车模拟器</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "CARLA OpenDriveParser \u8bf4\u660e\u6587\u6863";
        var mkdocs_page_input_path = "modules/opendirve.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> 人车模拟器
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">首页</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">人车模拟器</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">CARLA OpenDriveParser 说明文档</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/OpenHUTB/carla_doc/edit/master/docs/modules/opendirve.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="carla-opendriveparser">CARLA OpenDriveParser 说明文档</h1>
<p>本文件定义了 CARLA 模拟器中用于解析 OpenDRIVE 地图数据的 OpenDriveParser 类。该类位于 carla::opendrive 命名空间中，主要职责是从 OpenDRIVE XML 文件中读取道路网络数据，并将其转换为 CARLA 内部表示形式。</p>
<h2 id="_1">📦 命名空间</h2>
<p>cpp</p>
<p>namespace carla {
  namespace opendrive {
    ...
  }
}
该类位于 carla::opendrive 命名空间下。</p>
<h2 id="opendriveparser">🏗️ 类定义详解：OpenDriveParser</h2>
<p>cpp</p>
<p>class OpenDriveParser</p>
<p>简介</p>
<p>OpenDriveParser 是 CARLA 模拟器中 carla::opendrive 命名空间下的一个核心类，专门用于解析 OpenDRIVE（.xodr）格式的地图文件。
它被设计为 纯静态工具类 —— 即类中所有成员函数都是 static，无需也不应创建该类的实例。</p>
<p>这个类是 CARLA 将现实交通规则与地形数据导入其仿真环境的桥梁。其目标是将 OpenDRIVE 文件转换为 CARLA 使用的 Map 数据结构，并保留道路几何、车道属性、连接关系等关键信息。</p>
<p>### 类特点</p>
<p>🔹 纯静态类：不允许实例化，所有方法为 static。</p>
<p>🔹 工具类设计：提供“加载”和“解析”两个核心能力。</p>
<p>🔹 封装解析细节：使用 XML 解析库（如 pugixml）来处理底层文件格式。</p>
<p>🔹 模块化输出：返回标准化 Map 对象，供 CARLA 路网系统使用。</p>
<h3 id="_2">为什么使用静态类？</h3>
<p>将其设计为静态类的好处：</p>
<p>1.避免了频繁创建/销毁对象带来的性能负担；</p>
<p>2.明确该类仅提供“功能”，没有“状态”；</p>
<p>3.更易于在不同模块中通用调用。</p>
<h3 id="_3">类接口概览</h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static Map Load(std::string opendrive_file)</td>
<td>从 OpenDRIVE 文件内容中解析出一份完整的 Map 对象</td>
</tr>
<tr>
<td>static std::string GetXodrHeader(const std::string &amp;opendrive_file)</td>
<td>获取 OpenDRIVE 文件头信息</td>
</tr>
</tbody>
</table>
<p>虽然目前暴露的函数不多，但它们背后隐藏了大量对 XML 元素的处理逻辑，包括道路定义、几何形状、交叉口、连接、规则等。</p>
<h3 id="_4">类依赖关系</h3>
<p>输入依赖：OpenDRIVE .xodr 文件内容（纯文本格式 XML）</p>
<p>输出依赖：返回 carla::opendrive::Map 类的实例</p>
<p>外部库依赖：使用 pugixml 处理 XML 文件内容</p>
<h2 id="_5">🔧 主要静态方法</h2>
<ol>
<li>Map Load(std::string opendrive_file)</li>
</ol>
<p>功能：从 OpenDRIVE XML 字符串加载地图。</p>
<p>参数： opendrive_file: OpenDRIVE 文件内容字符串（不是文件路径）。</p>
<p>返回值：一个构造完成的 Map 对象。</p>
<p>异常：可能会抛出 std::runtime_error。</p>
<ol>
<li>std::string GetXodrHeader(const std::string &amp;opendrive_file)</li>
</ol>
<p>功能：提取 OpenDRIVE 文件头部信息。</p>
<p>参数：完整的 OpenDRIVE XML 文件内容。</p>
<p>返回值：文件头内容的字符串。</p>
<h2 id="map">🗺️ 数据结构说明：Map</h2>
<h3 id="_6">简要介绍</h3>
<p>Map 是 CARLA 仿真平台中处理道路网络的核心数据结构之一。虽然在 OpenDriveParser.h 中没有展开其定义，但该结构通常定义在 carla/opendrive/Map.h 文件中，并由 carla::opendrive::OpenDriveParser::Load 方法返回。</p>
<p>这个数据结构是 OpenDRIVE 文件经过解析后的高层封装，包含了描述交通网络的全部信息，包括但不限于：</p>
<p>道路（Roads）, 车道（Lanes） ,交叉口（Junctions） ,几何信息（Geometries） ,拓扑连接（LaneLinks / RoadLinks） ,信号灯和交通规则（Signals / Controllers）</p>
<h3 id="map_1">Map 的作用</h3>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>仿真世界构建</td>
<td>提供构建 CARLA 仿真环境的蓝图（如道路网格）</td>
</tr>
<tr>
<td>路径规划</td>
<td>为车辆行为模块提供路径信息</td>
</tr>
<tr>
<td>感知模拟</td>
<td>为传感器生成提供几何和拓扑依据</td>
</tr>
<tr>
<td>可视化</td>
<td>支持地图在模拟器界面中的渲染展示</td>
</tr>
<tr>
<td>路网分析</td>
<td>供外部工具提取道路属性、生成路线、计算可行驶区域等</td>
</tr>
</tbody>
</table>
<h3 id="_7">结构组成（典型字段）</h3>
<p>以下为 Map 常见字段的逻辑结构说明：</p>
<p>cpp</p>
<p>class Map {
public:
  std::vector<Road> roads;            // 所有道路信息
  std::vector<Junction> junctions;    // 所有交叉口
  std::vector<Signal> signals;        // 所有交通信号灯/标志
  Header header;                      // 地图头部信息（来自 OpenDRIVE <header>）
};
1. roads</p>
<p>包含所有 OpenDRIVE <road> 节点的信息，每一条道路包含以下内容：</p>
<p>道路ID与名称, 道路长度. 几何段（直线、圆弧、样条线）, 车道信息（分布、宽度、类型）</p>
<ol>
<li>junctions</li>
</ol>
<p>包含 <junction> 节点，描述多个道路交汇处的连接方式：</p>
<p>哪些车道互通? 如何在交叉口内转弯? 交通优先权。</p>
<ol>
<li>signals</li>
</ol>
<p>表示地图中定义的交通灯、限速标志、停车标志等信息：</p>
<p>类型（如红绿灯、限速牌），安装位置，控制关系（与道路或车道绑定）</p>
<ol>
<li>header</li>
</ol>
<p>存储 OpenDRIVE <header> 元素的信息，如：</p>
<p>地图名称与版本号，
创建时间，
原始坐标系统（可用于坐标投影）。</p>
<h3 id="opendriveparser_1">与 OpenDriveParser 的关系</h3>
<p>1.Map 是 OpenDriveParser::Load() 的直接返回结果。</p>
<p>2.OpenDriveParser 完整解析 OpenDRIVE XML 文件，重建出结构化的 Map 对象，供 CARLA 世界使用。</p>
<p>换言之，OpenDriveParser 是“入口”，而 Map 是“出口”。</p>
<h3 id="_8">使用示例</h3>
<p>cpp</p>
<p>std::string xodr_data = LoadFile("Town04.xodr");
carla::opendrive::Map map = OpenDriveParser::Load(xodr_data);</p>
<p>// 获取第一个道路信息
const Road&amp; road = map.GetRoad(0);
std::cout &lt;&lt; "Road ID: " &lt;&lt; road.id &lt;&lt; std::endl;</p>
<p>内部可能涉及到诸如：</p>
<p>1.将坐标从 OpenDRIVE 的参考线转换为 CARLA 世界坐标；</p>
<p>2.将道路元素（如车道、交叉口）转换为 CARLA 的可用形式；</p>
<p>3.构建车道之间的连接逻辑；</p>
<p>4.计算几何信息、样条插值等。</p>
<h2 id="_9">⚠️ 注意事项</h2>
<p>输入是字符串格式的完整 OpenDRIVE 文件内容，不是文件路径。</p>
<p>使用前请确认该字符串已正确读取整个 XML 文件。</p>
<p>若输入格式有误或内容缺失，解析可能会失败。</p>
<h2 id="_10">📚 示例代码</h2>
<p>cpp</p>
<h1 id="include-carlaopendriveopendriveparserh">include "carla/opendrive/OpenDriveParser.h"</h1>
<p>std::string xodr_contents = ReadFile("Town01.xodr");
carla::opendrive::Map map = carla::opendrive::OpenDriveParser::Load(xodr_contents);</p>
<hr />
<h1 id="opendriveparsercpp-carla">📄 OpenDriveParser.cpp 源文件说明（CARLA）</h1>
<p>该文件实现了 CARLA 项目中 OpenDRIVE 格式地图解析的核心模块：<code>OpenDriveParser</code>。它负责从 OpenDRIVE XML 字符串中解析并构建 CARLA 中的道路网络地图对象（<code>road::Map</code>）。</p>
<hr />
<h2 id="_11">📁 文件位置</h2>
<div class="highlight"><pre><span></span><code>LibCarla/source/carla/opendrive/OpenDriveParser.cpp
</code></pre></div>
<hr />
<h2 id="_12">🧱 主要功能详解</h2>
<p>该文件（OpenDriveParser.cpp）的核心职责是：解析 OpenDRIVE 地图数据。其中最重要的函数是：</p>
<p>cpp</p>
<p>boost::optional<road::Map> OpenDriveParser::Load(const std::string &amp;opendrive);
 函数说明：OpenDriveParser::Load</p>
<h3 id="_13">函数原型</h3>
<p>cpp</p>
<p>boost::optional<road::Map> OpenDriveParser::Load(const std::string &amp;opendrive);</p>
<h3 id="_14">输入参数</h3>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>opendrive</td>
<td>const std::string &amp;</td>
<td>包含 OpenDRIVE 地图完整 XML 内容的字符串。可以是从 .xodr 文件读取的文本内容</td>
</tr>
</tbody>
</table>
<p>返回值
返回类型为 boost::optional<road::Map>：</p>
<p>如果解析成功：返回一个包含完整地图结构的 road::Map 对象；</p>
<p>如果解析失败（如格式错误、缺少必要字段）：返回空（boost::none）。</p>
<h3 id="_15">函数职责</h3>
<p>该函数的主要职责是将输入的 XML 字符串（符合 OpenDRIVE 标准）解析成 CARLA 中用于导航与仿真的地图结构 road::Map，其包含：</p>
<p>道路几何信息（曲线、直线、坐标）</p>
<p>车道结构（宽度、类型、连接关系）</p>
<p>交叉口信息（连接规则、优先级）</p>
<p>道路标志（红绿灯、限速标志、指示牌）</p>
<p>道路拓扑信息（如何从一个车道连接到另一个）</p>
<h3 id="_16">函数内部工作流程</h3>
<p>以下为该函数的典型处理步骤（在 OpenDriveParser.cpp 中实现）：</p>
<p>1.初始化 XML 解析器（pugixml）</p>
<p>将输入的字符串 opendrive 加载进 pugi::xml_document</p>
<p>2.检查 OpenDRIVE根元素是否存在</p>
<p>如果找不到，立即返回空值（无效的输入）</p>
<p>3.解析 header 元素</p>
<p>解析并构造 road::Map::Header，包含地图版本号、供应商信息、原点坐标、投影类型等</p>
<p>4.调用子模块进行结构化解析</p>
<p>该函数并不直接处理所有解析细节，而是通过调用多个专用子解析器模块实现解耦和职责分离。</p>
<h2 id="_17">🧰 调用的子解析器模块</h2>
<table>
<thead>
<tr>
<th>解析器名称</th>
<th>文件位置</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>GeometryParser</td>
<td>parser/GeometryParser.h</td>
<td>解析 <geometry> 段（包括直线、弧线、样条）为曲线段数据结构</td>
</tr>
<tr>
<td>LaneOffsetParser</td>
<td>parser/LaneOffsetParser.h</td>
<td>解析 <laneOffset> 信息，即道路车道中心线的横向偏移量变化</td>
</tr>
<tr>
<td>LaneWidthParser</td>
<td>parser/LaneWidthParser.h</td>
<td>解析 <width> 元素，获取车道宽度的多段变化</td>
</tr>
<tr>
<td>LaneParser</td>
<td>parser/LaneParser.h</td>
<td>解析 <lane>，包含车道类型、连接、宽度等</td>
</tr>
<tr>
<td>LaneSectionParser</td>
<td>parser/LaneSectionParser.h</td>
<td>解析 <laneSection>，构建各个车道组合成的横截面结构</td>
</tr>
<tr>
<td>RoadLinkParser</td>
<td>parser/RoadLinkParser.h</td>
<td>解析 <link> 信息，建立道路之间的连接</td>
</tr>
<tr>
<td>JunctionParser</td>
<td>parser/JunctionParser.h</td>
<td>解析 <junction> 交叉口结构，处理优先级、连接等</td>
</tr>
<tr>
<td>SignalParser</td>
<td>parser/SignalParser.h</td>
<td>解析 <signals>，包括限速牌、信号灯、路面标识</td>
</tr>
<tr>
<td>ControllerParser</td>
<td>parser/ControllerParser.h</td>
<td>解析 <controller>，关联信号与控制器</td>
</tr>
</tbody>
</table>
<p>每个解析器都实现了一个 static Parse(...) 方法，接收相应的 XML 节点，返回结构化数据。</p>
<h3 id="_18">成功返回示例</h3>
<p>cpp</p>
<p>auto result = OpenDriveParser::Load(xodr_data);
if (result) {
    std::cout &lt;&lt; "加载成功！道路数量：" &lt;&lt; result-&gt;GetRoadCount() &lt;&lt; std::endl;
}</p>
<h3 id="_19">错误处理机制</h3>
<p>1.解析失败不会抛出异常，而是返回 boost::none</p>
<p>2.用户应检查 optional 是否有值再继续访问</p>
<p>3.内部某些子解析器会打印出错误日志，有助于调试格式问题的 OpenDRIVE 文件</p>
<h3 id="_20">与其他模块协作</h3>
<table>
<thead>
<tr>
<th>模块</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>pugixml</td>
<td>XML DOM 解析</td>
</tr>
<tr>
<td>road::Map</td>
<td>存储解析后的地图数据</td>
</tr>
<tr>
<td>各种 *Parser 子模块</td>
<td>解析不同级别的 OpenDRIVE 结构</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="_21">🧩 依赖模块</h2>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;carla/opendrive/OpenDriveParser.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;carla/Logging.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;carla/opendrive/parser/*.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;carla/road/MapBuilder.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pugixml/pugixml.hpp&gt;</span>
</code></pre></div>
<ul>
<li>✅ 使用 <code>pugixml</code> 加载和解析 XML</li>
<li>✅ 使用各类 parser 对不同部分进行解析（道路、信号、控制器等）</li>
<li>✅ 使用 <code>MapBuilder</code> 构建最终地图对象</li>
</ul>
<hr />
<h2 id="opendriveparserload">🔍 函数解析：OpenDriveParser::Load</h2>
<div class="highlight"><pre><span></span><code><span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">road</span><span class="o">::</span><span class="n">Map</span><span class="o">&gt;</span><span class="w"> </span><span class="n">OpenDriveParser</span><span class="o">::</span><span class="n">Load</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">opendrive</span><span class="p">)</span>
</code></pre></div>
<h3 id="_22">函数流程：</h3>
<ol>
<li><strong>加载 XML 数据</strong>
   <div class="highlight"><pre><span></span><code><span class="n">pugi</span><span class="o">::</span><span class="n">xml_document</span><span class="w"> </span><span class="n">xml</span><span class="p">;</span>
<span class="n">pugi</span><span class="o">::</span><span class="n">xml_parse_result</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xml</span><span class="p">.</span><span class="n">load_string</span><span class="p">(</span><span class="n">opendrive</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
</code></pre></div></li>
<li>
<p>利用 pugixml 从字符串中读取 XML 文档</p>
</li>
<li>
<p><strong>错误处理</strong>
   <div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">parse_result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">log_error</span><span class="p">(</span><span class="s">&quot;unable to parse the OpenDRIVE XML string&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{};</span>
<span class="p">}</span>
</code></pre></div></p>
</li>
<li>
<p><strong>初始化构建器</strong>
   <div class="highlight"><pre><span></span><code><span class="n">carla</span><span class="o">::</span><span class="n">road</span><span class="o">::</span><span class="n">MapBuilder</span><span class="w"> </span><span class="n">map_builder</span><span class="p">;</span>
</code></pre></div></p>
</li>
<li>
<p><strong>解析各个部分（按顺序）</strong></p>
</li>
<li>地理参考（坐标系）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">GeoReferenceParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></li>
<li>道路（road）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">RoadParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></li>
<li>路口（junction）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">JunctionParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></li>
<li>几何数据（geometry）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">GeometryParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></li>
<li>车道（lane）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">LaneParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></li>
<li>属性配置（profile：如坡度/曲率）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">ProfilesParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></li>
<li>交通分组（公交/非机动车等）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">TrafficGroupParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></li>
<li>信号（交通灯、标志等）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">SignalParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></li>
<li>静态对象（建筑、栏杆等）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">ObjectParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></li>
<li>
<p>控制器（如红绿灯控制逻辑）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">ControllerParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></p>
</li>
<li>
<p><strong>构建最终 Map</strong>
   <div class="highlight"><pre><span></span><code><span class="k">return</span><span class="w"> </span><span class="n">map_builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</code></pre></div></p>
</li>
</ol>
<hr />
<h2 id="_23">🗺️ 模块调用关系</h2>
<div class="highlight"><pre><span></span><code>OpenDriveParser::Load(string)
  ├── XML 加载（pugixml）
  ├── GeoReferenceParser
  ├── RoadParser
  ├── JunctionParser
  ├── GeometryParser
  ├── LaneParser
  ├── ProfilesParser
  ├── TrafficGroupParser
  ├── SignalParser
  ├── ObjectParser
  ├── ControllerParser
  └── MapBuilder::Build()
</code></pre></div>
<hr />
<h2 id="_24">⚙️ 类图概念（简化）</h2>
<div class="highlight"><pre><span></span><code><span class="n">OpenDriveParser</span>
<span class="w">  </span><span class="err">└──</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">Load</span><span class="p">(</span><span class="n">opendrive</span><span class="o">:</span><span class="w"> </span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">optional</span><span class="o">&lt;</span><span class="n">road</span><span class="o">::</span><span class="n">Map</span><span class="o">&gt;</span>
</code></pre></div>
<ul>
<li>所有逻辑集中在 <code>Load</code> 函数中，内部组合各解析器模块进行 XML 内容解析</li>
</ul>
<hr />
<h2 id="_25">✅ 特性小结</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>模块化</td>
<td>各解析功能分离为独立模块（parser）</td>
</tr>
<tr>
<td>错误安全</td>
<td>使用 <code>boost::optional</code> 表达失败</td>
</tr>
<tr>
<td>扩展性</td>
<td>新增解析器模块时易于集成</td>
</tr>
<tr>
<td>性能良好</td>
<td>基于轻量级 pugixml 实现</td>
</tr>
<tr>
<td>支持蓝图间接调用</td>
<td>被上层封装（如 Unreal 的 <code>UOpenDrive</code> 类）</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="_26">💡 使用场景</h2>
<ul>
<li>加载 <code>.xodr</code> 地图字符串到 CARLA 引擎中</li>
<li>在地图工具链中进行道路、交叉口、交通信号等解析</li>
<li>用于运行时生成或验证地图网络结构</li>
</ul>
<hr />
<h1 id="carla-opendriveparser_1">CARLA OpenDriveParser 说明文档</h1>
<p>本文件定义了 CARLA 模拟器中用于解析 OpenDRIVE 地图数据的 OpenDriveParser 类。该类位于 carla::opendrive 命名空间中，主要职责是从 OpenDRIVE XML 文件中读取道路网络数据，并将其转换为 CARLA 内部表示形式。</p>
<h2 id="_27">📦 命名空间</h2>
<p>cpp</p>
<p>namespace carla {
  namespace opendrive {
    ...
  }
}
该类位于 carla::opendrive 命名空间下。</p>
<h2 id="opendriveparser_2">🏗️ 类定义详解：OpenDriveParser</h2>
<p>cpp</p>
<p>class OpenDriveParser</p>
<p>简介</p>
<p>OpenDriveParser 是 CARLA 模拟器中 carla::opendrive 命名空间下的一个核心类，专门用于解析 OpenDRIVE（.xodr）格式的地图文件。
它被设计为 纯静态工具类 —— 即类中所有成员函数都是 static，无需也不应创建该类的实例。</p>
<p>这个类是 CARLA 将现实交通规则与地形数据导入其仿真环境的桥梁。其目标是将 OpenDRIVE 文件转换为 CARLA 使用的 Map 数据结构，并保留道路几何、车道属性、连接关系等关键信息。</p>
<p>### 类特点</p>
<p>🔹 纯静态类：不允许实例化，所有方法为 static。</p>
<p>🔹 工具类设计：提供“加载”和“解析”两个核心能力。</p>
<p>🔹 封装解析细节：使用 XML 解析库（如 pugixml）来处理底层文件格式。</p>
<p>🔹 模块化输出：返回标准化 Map 对象，供 CARLA 路网系统使用。</p>
<h3 id="_28">为什么使用静态类？</h3>
<p>将其设计为静态类的好处：</p>
<p>1.避免了频繁创建/销毁对象带来的性能负担；</p>
<p>2.明确该类仅提供“功能”，没有“状态”；</p>
<p>3.更易于在不同模块中通用调用。</p>
<h3 id="_29">类接口概览</h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static Map Load(std::string opendrive_file)</td>
<td>从 OpenDRIVE 文件内容中解析出一份完整的 Map 对象</td>
</tr>
<tr>
<td>static std::string GetXodrHeader(const std::string &amp;opendrive_file)</td>
<td>获取 OpenDRIVE 文件头信息</td>
</tr>
</tbody>
</table>
<p>虽然目前暴露的函数不多，但它们背后隐藏了大量对 XML 元素的处理逻辑，包括道路定义、几何形状、交叉口、连接、规则等。</p>
<h3 id="_30">类依赖关系</h3>
<p>输入依赖：OpenDRIVE .xodr 文件内容（纯文本格式 XML）</p>
<p>输出依赖：返回 carla::opendrive::Map 类的实例</p>
<p>外部库依赖：使用 pugixml 处理 XML 文件内容</p>
<h2 id="_31">🔧 主要静态方法</h2>
<ol>
<li>Map Load(std::string opendrive_file)</li>
</ol>
<p>功能：从 OpenDRIVE XML 字符串加载地图。</p>
<p>参数： opendrive_file: OpenDRIVE 文件内容字符串（不是文件路径）。</p>
<p>返回值：一个构造完成的 Map 对象。</p>
<p>异常：可能会抛出 std::runtime_error。</p>
<ol>
<li>std::string GetXodrHeader(const std::string &amp;opendrive_file)</li>
</ol>
<p>功能：提取 OpenDRIVE 文件头部信息。</p>
<p>参数：完整的 OpenDRIVE XML 文件内容。</p>
<p>返回值：文件头内容的字符串。</p>
<h2 id="map_2">🗺️ 数据结构说明：Map</h2>
<h3 id="_32">简要介绍</h3>
<p>Map 是 CARLA 仿真平台中处理道路网络的核心数据结构之一。虽然在 OpenDriveParser.h 中没有展开其定义，但该结构通常定义在 carla/opendrive/Map.h 文件中，并由 carla::opendrive::OpenDriveParser::Load 方法返回。</p>
<p>这个数据结构是 OpenDRIVE 文件经过解析后的高层封装，包含了描述交通网络的全部信息，包括但不限于：</p>
<p>道路（Roads）, 车道（Lanes） ,交叉口（Junctions） ,几何信息（Geometries） ,拓扑连接（LaneLinks / RoadLinks） ,信号灯和交通规则（Signals / Controllers）</p>
<h3 id="map_3">Map 的作用</h3>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>仿真世界构建</td>
<td>提供构建 CARLA 仿真环境的蓝图（如道路网格）</td>
</tr>
<tr>
<td>路径规划</td>
<td>为车辆行为模块提供路径信息</td>
</tr>
<tr>
<td>感知模拟</td>
<td>为传感器生成提供几何和拓扑依据</td>
</tr>
<tr>
<td>可视化</td>
<td>支持地图在模拟器界面中的渲染展示</td>
</tr>
<tr>
<td>路网分析</td>
<td>供外部工具提取道路属性、生成路线、计算可行驶区域等</td>
</tr>
</tbody>
</table>
<h3 id="_33">结构组成（典型字段）</h3>
<p>以下为 Map 常见字段的逻辑结构说明：</p>
<p>cpp</p>
<p>class Map {
public:
  std::vector<Road> roads;            // 所有道路信息
  std::vector<Junction> junctions;    // 所有交叉口
  std::vector<Signal> signals;        // 所有交通信号灯/标志
  Header header;                      // 地图头部信息（来自 OpenDRIVE <header>）
};
1. roads</p>
<p>包含所有 OpenDRIVE <road> 节点的信息，每一条道路包含以下内容：</p>
<p>道路ID与名称, 道路长度. 几何段（直线、圆弧、样条线）, 车道信息（分布、宽度、类型）</p>
<ol>
<li>junctions</li>
</ol>
<p>包含 <junction> 节点，描述多个道路交汇处的连接方式：</p>
<p>哪些车道互通? 如何在交叉口内转弯? 交通优先权。</p>
<ol>
<li>signals</li>
</ol>
<p>表示地图中定义的交通灯、限速标志、停车标志等信息：</p>
<p>类型（如红绿灯、限速牌），安装位置，控制关系（与道路或车道绑定）</p>
<ol>
<li>header</li>
</ol>
<p>存储 OpenDRIVE <header> 元素的信息，如：</p>
<p>地图名称与版本号，
创建时间，
原始坐标系统（可用于坐标投影）。</p>
<h3 id="opendriveparser_3">与 OpenDriveParser 的关系</h3>
<p>1.Map 是 OpenDriveParser::Load() 的直接返回结果。</p>
<p>2.OpenDriveParser 完整解析 OpenDRIVE XML 文件，重建出结构化的 Map 对象，供 CARLA 世界使用。</p>
<p>换言之，OpenDriveParser 是“入口”，而 Map 是“出口”。</p>
<h3 id="_34">使用示例</h3>
<p>cpp</p>
<p>std::string xodr_data = LoadFile("Town04.xodr");
carla::opendrive::Map map = OpenDriveParser::Load(xodr_data);</p>
<p>// 获取第一个道路信息
const Road&amp; road = map.GetRoad(0);
std::cout &lt;&lt; "Road ID: " &lt;&lt; road.id &lt;&lt; std::endl;</p>
<p>内部可能涉及到诸如：</p>
<p>1.将坐标从 OpenDRIVE 的参考线转换为 CARLA 世界坐标；</p>
<p>2.将道路元素（如车道、交叉口）转换为 CARLA 的可用形式；</p>
<p>3.构建车道之间的连接逻辑；</p>
<p>4.计算几何信息、样条插值等。</p>
<h2 id="_35">⚠️ 注意事项</h2>
<p>输入是字符串格式的完整 OpenDRIVE 文件内容，不是文件路径。</p>
<p>使用前请确认该字符串已正确读取整个 XML 文件。</p>
<p>若输入格式有误或内容缺失，解析可能会失败。</p>
<h2 id="_36">📚 示例代码</h2>
<p>cpp</p>
<h1 id="include-carlaopendriveopendriveparserh_1">include "carla/opendrive/OpenDriveParser.h"</h1>
<p>std::string xodr_contents = ReadFile("Town01.xodr");
carla::opendrive::Map map = carla::opendrive::OpenDriveParser::Load(xodr_contents);</p>
<hr />
<h1 id="opendriveparsercpp-carla_1">📄 OpenDriveParser.cpp 源文件说明（CARLA）</h1>
<p>该文件实现了 CARLA 项目中 OpenDRIVE 格式地图解析的核心模块：<code>OpenDriveParser</code>。它负责从 OpenDRIVE XML 字符串中解析并构建 CARLA 中的道路网络地图对象（<code>road::Map</code>）。</p>
<hr />
<h2 id="_37">📁 文件位置</h2>
<div class="highlight"><pre><span></span><code>LibCarla/source/carla/opendrive/OpenDriveParser.cpp
</code></pre></div>
<hr />
<h2 id="_38">🧱 主要功能详解</h2>
<p>该文件（OpenDriveParser.cpp）的核心职责是：解析 OpenDRIVE 地图数据。其中最重要的函数是：</p>
<p>cpp</p>
<p>boost::optional<road::Map> OpenDriveParser::Load(const std::string &amp;opendrive);
 函数说明：OpenDriveParser::Load</p>
<h3 id="_39">函数原型</h3>
<p>cpp</p>
<p>boost::optional<road::Map> OpenDriveParser::Load(const std::string &amp;opendrive);</p>
<h3 id="_40">输入参数</h3>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>opendrive</td>
<td>const std::string &amp;</td>
<td>包含 OpenDRIVE 地图完整 XML 内容的字符串。可以是从 .xodr 文件读取的文本内容</td>
</tr>
</tbody>
</table>
<p>返回值
返回类型为 boost::optional<road::Map>：</p>
<p>如果解析成功：返回一个包含完整地图结构的 road::Map 对象；</p>
<p>如果解析失败（如格式错误、缺少必要字段）：返回空（boost::none）。</p>
<h3 id="_41">函数职责</h3>
<p>该函数的主要职责是将输入的 XML 字符串（符合 OpenDRIVE 标准）解析成 CARLA 中用于导航与仿真的地图结构 road::Map，其包含：</p>
<p>道路几何信息（曲线、直线、坐标）</p>
<p>车道结构（宽度、类型、连接关系）</p>
<p>交叉口信息（连接规则、优先级）</p>
<p>道路标志（红绿灯、限速标志、指示牌）</p>
<p>道路拓扑信息（如何从一个车道连接到另一个）</p>
<h3 id="_42">函数内部工作流程</h3>
<p>以下为该函数的典型处理步骤（在 OpenDriveParser.cpp 中实现）：</p>
<p>1.初始化 XML 解析器（pugixml）</p>
<p>将输入的字符串 opendrive 加载进 pugi::xml_document</p>
<p>2.检查 OpenDRIVE根元素是否存在</p>
<p>如果找不到，立即返回空值（无效的输入）</p>
<p>3.解析 header 元素</p>
<p>解析并构造 road::Map::Header，包含地图版本号、供应商信息、原点坐标、投影类型等</p>
<p>4.调用子模块进行结构化解析</p>
<p>该函数并不直接处理所有解析细节，而是通过调用多个专用子解析器模块实现解耦和职责分离。</p>
<h2 id="_43">🧰 调用的子解析器模块</h2>
<table>
<thead>
<tr>
<th>解析器名称</th>
<th>文件位置</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>GeometryParser</td>
<td>parser/GeometryParser.h</td>
<td>解析 <geometry> 段（包括直线、弧线、样条）为曲线段数据结构</td>
</tr>
<tr>
<td>LaneOffsetParser</td>
<td>parser/LaneOffsetParser.h</td>
<td>解析 <laneOffset> 信息，即道路车道中心线的横向偏移量变化</td>
</tr>
<tr>
<td>LaneWidthParser</td>
<td>parser/LaneWidthParser.h</td>
<td>解析 <width> 元素，获取车道宽度的多段变化</td>
</tr>
<tr>
<td>LaneParser</td>
<td>parser/LaneParser.h</td>
<td>解析 <lane>，包含车道类型、连接、宽度等</td>
</tr>
<tr>
<td>LaneSectionParser</td>
<td>parser/LaneSectionParser.h</td>
<td>解析 <laneSection>，构建各个车道组合成的横截面结构</td>
</tr>
<tr>
<td>RoadLinkParser</td>
<td>parser/RoadLinkParser.h</td>
<td>解析 <link> 信息，建立道路之间的连接</td>
</tr>
<tr>
<td>JunctionParser</td>
<td>parser/JunctionParser.h</td>
<td>解析 <junction> 交叉口结构，处理优先级、连接等</td>
</tr>
<tr>
<td>SignalParser</td>
<td>parser/SignalParser.h</td>
<td>解析 <signals>，包括限速牌、信号灯、路面标识</td>
</tr>
<tr>
<td>ControllerParser</td>
<td>parser/ControllerParser.h</td>
<td>解析 <controller>，关联信号与控制器</td>
</tr>
</tbody>
</table>
<p>每个解析器都实现了一个 static Parse(...) 方法，接收相应的 XML 节点，返回结构化数据。</p>
<h3 id="_44">成功返回示例</h3>
<p>cpp</p>
<p>auto result = OpenDriveParser::Load(xodr_data);
if (result) {
    std::cout &lt;&lt; "加载成功！道路数量：" &lt;&lt; result-&gt;GetRoadCount() &lt;&lt; std::endl;
}</p>
<h3 id="_45">错误处理机制</h3>
<p>1.解析失败不会抛出异常，而是返回 boost::none</p>
<p>2.用户应检查 optional 是否有值再继续访问</p>
<p>3.内部某些子解析器会打印出错误日志，有助于调试格式问题的 OpenDRIVE 文件</p>
<h3 id="_46">与其他模块协作</h3>
<table>
<thead>
<tr>
<th>模块</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>pugixml</td>
<td>XML DOM 解析</td>
</tr>
<tr>
<td>road::Map</td>
<td>存储解析后的地图数据</td>
</tr>
<tr>
<td>各种 *Parser 子模块</td>
<td>解析不同级别的 OpenDRIVE 结构</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="_47">🧩 依赖模块</h2>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;carla/opendrive/OpenDriveParser.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;carla/Logging.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;carla/opendrive/parser/*.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;carla/road/MapBuilder.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pugixml/pugixml.hpp&gt;</span>
</code></pre></div>
<ul>
<li>✅ 使用 <code>pugixml</code> 加载和解析 XML</li>
<li>✅ 使用各类 parser 对不同部分进行解析（道路、信号、控制器等）</li>
<li>✅ 使用 <code>MapBuilder</code> 构建最终地图对象</li>
</ul>
<hr />
<h2 id="opendriveparserload_1">🔍 函数解析：OpenDriveParser::Load</h2>
<div class="highlight"><pre><span></span><code><span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">road</span><span class="o">::</span><span class="n">Map</span><span class="o">&gt;</span><span class="w"> </span><span class="n">OpenDriveParser</span><span class="o">::</span><span class="n">Load</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">opendrive</span><span class="p">)</span>
</code></pre></div>
<h3 id="_48">函数流程：</h3>
<ol>
<li><strong>加载 XML 数据</strong>
   <div class="highlight"><pre><span></span><code><span class="n">pugi</span><span class="o">::</span><span class="n">xml_document</span><span class="w"> </span><span class="n">xml</span><span class="p">;</span>
<span class="n">pugi</span><span class="o">::</span><span class="n">xml_parse_result</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xml</span><span class="p">.</span><span class="n">load_string</span><span class="p">(</span><span class="n">opendrive</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
</code></pre></div></li>
<li>
<p>利用 pugixml 从字符串中读取 XML 文档</p>
</li>
<li>
<p><strong>错误处理</strong>
   <div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">parse_result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">log_error</span><span class="p">(</span><span class="s">&quot;unable to parse the OpenDRIVE XML string&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{};</span>
<span class="p">}</span>
</code></pre></div></p>
</li>
<li>
<p><strong>初始化构建器</strong>
   <div class="highlight"><pre><span></span><code><span class="n">carla</span><span class="o">::</span><span class="n">road</span><span class="o">::</span><span class="n">MapBuilder</span><span class="w"> </span><span class="n">map_builder</span><span class="p">;</span>
</code></pre></div></p>
</li>
<li>
<p><strong>解析各个部分（按顺序）</strong></p>
</li>
<li>地理参考（坐标系）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">GeoReferenceParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></li>
<li>道路（road）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">RoadParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></li>
<li>路口（junction）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">JunctionParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></li>
<li>几何数据（geometry）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">GeometryParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></li>
<li>车道（lane）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">LaneParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></li>
<li>属性配置（profile：如坡度/曲率）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">ProfilesParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></li>
<li>交通分组（公交/非机动车等）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">TrafficGroupParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></li>
<li>信号（交通灯、标志等）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">SignalParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></li>
<li>静态对象（建筑、栏杆等）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">ObjectParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></li>
<li>
<p>控制器（如红绿灯控制逻辑）
     <div class="highlight"><pre><span></span><code><span class="n">parser</span><span class="o">::</span><span class="n">ControllerParser</span><span class="o">::</span><span class="n">Parse</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="n">map_builder</span><span class="p">);</span>
</code></pre></div></p>
</li>
<li>
<p><strong>构建最终 Map</strong>
   <div class="highlight"><pre><span></span><code><span class="k">return</span><span class="w"> </span><span class="n">map_builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</code></pre></div></p>
</li>
</ol>
<hr />
<h2 id="_49">🗺️ 模块调用关系</h2>
<div class="highlight"><pre><span></span><code>OpenDriveParser::Load(string)
  ├── XML 加载（pugixml）
  ├── GeoReferenceParser
  ├── RoadParser
  ├── JunctionParser
  ├── GeometryParser
  ├── LaneParser
  ├── ProfilesParser
  ├── TrafficGroupParser
  ├── SignalParser
  ├── ObjectParser
  ├── ControllerParser
  └── MapBuilder::Build()
</code></pre></div>
<hr />
<h2 id="_50">⚙️ 类图概念（简化）</h2>
<div class="highlight"><pre><span></span><code><span class="n">OpenDriveParser</span>
<span class="w">  </span><span class="err">└──</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">Load</span><span class="p">(</span><span class="n">opendrive</span><span class="o">:</span><span class="w"> </span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">optional</span><span class="o">&lt;</span><span class="n">road</span><span class="o">::</span><span class="n">Map</span><span class="o">&gt;</span>
</code></pre></div>
<ul>
<li>所有逻辑集中在 <code>Load</code> 函数中，内部组合各解析器模块进行 XML 内容解析</li>
</ul>
<hr />
<h2 id="_51">✅ 特性小结</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>模块化</td>
<td>各解析功能分离为独立模块（parser）</td>
</tr>
<tr>
<td>错误安全</td>
<td>使用 <code>boost::optional</code> 表达失败</td>
</tr>
<tr>
<td>扩展性</td>
<td>新增解析器模块时易于集成</td>
</tr>
<tr>
<td>性能良好</td>
<td>基于轻量级 pugixml 实现</td>
</tr>
<tr>
<td>支持蓝图间接调用</td>
<td>被上层封装（如 Unreal 的 <code>UOpenDrive</code> 类）</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="_52">💡 使用场景</h2>
<ul>
<li>加载 <code>.xodr</code> 地图字符串到 CARLA 引擎中</li>
<li>在地图工具链中进行道路、交叉口、交通信号等解析</li>
<li>用于运行时生成或验证地图网络结构</li>
</ul>
<hr />
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/OpenHUTB/carla_doc" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="https://cdn.rawgit.com/knsv/mermaid/6.0.0/dist/mermaid.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script>
      <script src="../../js/umlconvert.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
