<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>CARLA 客户端文档目录 - 人车模拟器</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "CARLA \u5ba2\u6237\u7aef\u6587\u6863\u76ee\u5f55";
        var mkdocs_page_input_path = "modules/client.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> 人车模拟器
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">首页</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">人车模拟器</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">CARLA 客户端文档目录</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/OpenHUTB/doc/edit/master/docs/modules/client.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="carla">CARLA 客户端文档目录</h1>
<h2 id="_1">一、<a href="#概述">概述</a></h2>
<h2 id="_2">二、<a href="#主要类与功能">主要类与功能</a></h2>
<ul>
<li><a href="#21-client-类">2.1 Client 类</a></li>
<li><a href="#22-actor-类">2.2 Actor 类</a></li>
<li><a href="#23-clientsidesensor-类">2.3 ClientSideSensor 类</a></li>
<li><a href="#24-trafficmanager-类">2.4 TrafficManager 类</a></li>
<li><a href="#25-blueprintlibrary-与-actorblueprint-类">2.5 BlueprintLibrary 与 ActorBlueprint 类</a></li>
<li><a href="#26-sensor-类与传感器使用以摄像头为例">2.6 Sensor 类与传感器使用（以摄像头为例）</a></li>
<li><a href="#27-world-类">2.7 World 类</a></li>
</ul>
<h2 id="_3">三、<a href="#扩展模块">扩展模块</a></h2>
<ul>
<li><a href="#31-debughelper-模块carla-客户端调试可视化工具">3.1 DebugHelper 模块</a></li>
<li><a href="#32-filetransfer-模块carla-客户端的文件读写与缓存机制">3.2 FileTransfer 模块</a></li>
<li><a href="#33-junction-模块carla-道路交叉口junction建模与访问">3.3 Junction 模块</a></li>
<li><a href="#34-laneinvasion-模块carla-车道入侵lane-invasion检测与处理">3.4 LaneInvasion 模块</a></li>
<li><a href="#35-light-模块carla-中的交通灯与照明灯控制接口">3.5 Light 模块</a></li>
<li><a href="#36-vehicle-模块carla-车辆实体控制与状态管理">3.6 Vehicle 模块</a></li>
</ul>
<h2 id="_4">四、<a href="#类之间的调用关系">类之间的调用关系</a></h2>
<h2 id="_5">五、<a href="#总结">总结</a></h2>
<h2 id="_6">六、<a href="#参考链接">参考链接</a></h2>
<h1 id="_7"><strong>概述</strong></h1>
<p>CARLA 是一个开源的自动驾驶模拟平台，提供了丰富的 API 以支持仿真环境的控制、车辆的管理以及自动驾驶算法的验证。客户端部分的 API 主要通过 <code>Client</code> 类与模拟器进行交互，执行仿真控制、传感器管理、交通流管理等功能。该文档主要介绍 CARLA 客户端相关类的功能和使用方式。</p>
<h2 id="_8"><strong>主要类与功能</strong></h2>
<h3 id="1-client">1. <code>Client</code> 类</h3>
<p><code>Client</code> 类是与 CARLA 模拟器交互的核心类，提供了连接仿真器、加载世界、设置物理参数、控制传感器等功能。在 Carla 自动驾驶仿真平台中，Client 类是开发者与 Carla 服务器（服务端）交互的核心接口。它负责建立客户端与服务器之间的连接，并通过网络通信管理仿真世界中的实体（如车辆、传感器、行人等）。通过 Client 类，开发者可以灵活控制 Carla 仿真环境，实现从简单的车辆控制到复杂的多智能体协同仿真。</p>
<h4 id="_9">核心作用</h4>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>连接仿真器</td>
<td>建立客户端与Carla服务器的TCP/IP连接，支持指定IP地址和端口号</td>
</tr>
<tr>
<td>加载/切换世界</td>
<td>动态加载不同地图（如Town01-Town10），支持世界状态重置和场景热更新</td>
</tr>
<tr>
<td>时间同步控制</td>
<td>设置固定时间步长或可变时间步长，控制仿真时钟与真实时间的同步比例</td>
</tr>
<tr>
<td>物理参数配置</td>
<td>调整重力系数、空气密度等物理参数，模拟不同环境条件下的车辆动力学特性</td>
</tr>
<tr>
<td>交通管理器控制</td>
<td>启停交通流，设置行人/车辆密度，配置NPC行为模式（保守/激进驾驶等）</td>
</tr>
<tr>
<td>传感器管理</td>
<td>生成/销毁摄像头、LiDAR、雷达等传感器，配置传感器参数（分辨率、FOV等）</td>
</tr>
<tr>
<td>天气系统控制</td>
<td>动态调整降水、积水、雾霾、太阳角度等天气参数，支持天气渐变过渡效果</td>
</tr>
<tr>
<td>蓝图库访问</td>
<td>提供车辆、传感器、行人的蓝图模板库，支持自定义属性过滤和参数化生成</td>
</tr>
<tr>
<td>快照(Snapshot)获取</td>
<td>捕获当前帧的世界状态信息，包含所有实体的位置、速度和物理特性</td>
</tr>
<tr>
<td>录制与回放</td>
<td>支持场景录制（.log格式）和实时回放，可用于事故复现或测试用例自动化</td>
</tr>
</tbody>
</table>
<h4 id="_10">构造函数</h4>
<ul>
<li><code>Client(const std::string &amp;host, uint16_t port, size_t worker_threads = 0u)</code></li>
<li>构建一个与 CARLA 仿真器的客户端连接。</li>
<li><code>host</code>：模拟器所在主机的 IP 地址。</li>
<li><code>port</code>：与模拟器的连接端口。</li>
<li><code>worker_threads</code>：使用的异步工作线程数，默认为 0（使用所有可用线程）。</li>
</ul>
<h4 id="_11">核心方法</h4>
<ul>
<li>
<p><code>std::string GetClientVersion() const</code></p>
</li>
<li>
<p>获取当前客户端的版本。</p>
</li>
<li>
<p><code>std::string GetServerVersion() const</code></p>
</li>
<li>
<p>获取当前连接的模拟器的版本。</p>
</li>
<li>
<p><code>std::vector&lt;std::string&gt; GetAvailableMaps() const</code></p>
</li>
<li>
<p>获取所有可用的地图名称。</p>
</li>
<li>
<p><code>World LoadWorld(std::string map_name, bool reset_settings = true, rpc::MapLayer map_layers = rpc::MapLayer::All) const</code></p>
</li>
<li>
<p>加载指定的仿真地图。</p>
</li>
<li>
<p><code>World ReloadWorld(bool reset_settings = true) const</code></p>
</li>
<li>
<p>重新加载当前仿真世界。</p>
</li>
<li>
<p><code>void SetTimeout(time_duration timeout)</code></p>
</li>
<li>
<p>设置与模拟器的网络超时时间。</p>
</li>
<li>
<p><code>TrafficManager GetInstanceTM(uint16_t port = TM_DEFAULT_PORT) const</code></p>
</li>
<li>
<p>获取当前模拟器中的交通管理实例（TrafficManager）。</p>
</li>
<li>
<p><code>void StartRecorder(std::string name, bool additional_data = false)</code></p>
</li>
<li>
<p>启动仿真数据记录器。</p>
</li>
<li>
<p><code>void StopRecorder()</code></p>
</li>
<li>
<p>停止仿真数据记录器。</p>
</li>
<li>
<p><code>World GenerateOpenDriveWorld(std::string opendrive, const rpc::OpendriveGenerationParameters &amp;params, bool reset_settings = true) const</code></p>
</li>
<li>使用 OpenDrive 文件生成仿真世界。</li>
</ul>
<h3 id="2-actor">2. <code>Actor</code> 类</h3>
<p><code>Actor</code> 类代表仿真中的任何实体（例如：车辆、行人等）。通过该类，用户可以控制行为体的位置、速度、碰撞、物理状态等。</p>
<h4 id="_12">核心方法</h4>
<ul>
<li>
<p><code>geom::Location GetLocation() const</code></p>
</li>
<li>
<p>获取行为体的当前位置。</p>
</li>
<li>
<p><code>geom::Transform GetTransform() const</code></p>
</li>
<li>
<p>获取行为体的变换（位置与方向）。</p>
</li>
<li>
<p><code>void SetLocation(const geom::Location&amp; location)</code></p>
</li>
<li>
<p>设置行为体的位置。</p>
</li>
<li>
<p><code>void SetTransform(const geom::Transform&amp; transform)</code></p>
</li>
<li>
<p>设置行为体的变换（位置与方向）。</p>
</li>
<li>
<p><code>void AddImpulse(const geom::Vector3D&amp; impulse)</code></p>
</li>
<li>
<p>向行为体添加冲量。</p>
</li>
<li>
<p><code>void AddForce(const geom::Vector3D&amp; force)</code></p>
</li>
<li>
<p>向行为体施加力。</p>
</li>
<li>
<p><code>void SetSimulatePhysics(bool enabled = true)</code></p>
</li>
<li>
<p>启用或禁用行为体的物理模拟。</p>
</li>
<li>
<p><code>bool Destroy()</code></p>
</li>
<li>销毁行为体。</li>
</ul>
<h3 id="3-clientsidesensor">3. <code>ClientSideSensor</code> 类</h3>
<p><code>ClientSideSensor</code> 类继承自 <code>Sensor</code> 类，代表 CARLA 中的客户端传感器（如摄像头、激光雷达等）。</p>
<h4 id="_13">核心方法</h4>
<ul>
<li>
<p><code>void Enable()</code></p>
</li>
<li>
<p>启用传感器。</p>
</li>
<li>
<p><code>void Disable()</code></p>
</li>
<li>
<p>禁用传感器。</p>
</li>
<li>
<p><code>bool IsEnabled() const</code></p>
</li>
<li>检查传感器是否启用。</li>
</ul>
<h3 id="4-trafficmanager">4. 交通管理器（<code>TrafficManager</code>）</h3>
<p><code>TrafficManager</code> 类用于管理仿真中的交通流，控制交通行为，包括交通灯的状态、车辆的行驶路线、交通规则等。</p>
<h4 id="_14">核心方法</h4>
<ul>
<li>
<p><code>void SetGlobalDistanceToLeadingVehicle(float distance)</code></p>
</li>
<li>
<p>设置车辆与前车的最小安全距离。</p>
</li>
<li>
<p><code>void SetVehicleDistanceToLeadingVehicle(float distance)</code></p>
</li>
<li>
<p>设置单个车辆与前车的最小安全距离。</p>
</li>
<li>
<p><code>void SetSynchronousMode(bool enabled)</code></p>
</li>
<li>启用或禁用同步模式，在同步模式下仿真步进是由用户控制的。</li>
</ul>
<h3 id="5-blueprintlibrary-actorblueprint">5. <code>BlueprintLibrary</code> 与 <code>ActorBlueprint</code> 类</h3>
<p>在 CARLA 客户端中，<code>BlueprintLibrary</code> 类用于提供创建行为体（Actor）的模板集合，而 <code>ActorBlueprint</code> 则描述具体实体的构造配置参数。</p>
<h4 id="_15">主要功能</h4>
<ul>
<li>
<p><code>BlueprintLibrary</code></p>
</li>
<li>
<p>获取可创建的实体蓝图列表（如车辆、传感器等）</p>
</li>
<li>
<p>支持通过关键词过滤蓝图</p>
</li>
<li>
<p><code>ActorBlueprint</code></p>
</li>
<li>表示单个实体的构造参数（如车辆类型、颜色，传感器分辨率等）</li>
<li>可设置和查询各类属性值</li>
</ul>
<h4 id="_16">示例</h4>
<div class="highlight"><pre><span></span><code>auto blueprint_library = world.GetBlueprintLibrary();

// 选择一辆特斯拉车型的 blueprint
auto vehicle_blueprint = (*blueprint_library)-&gt;Find(&quot;vehicle.tesla.model3&quot;);

// 设置车辆颜色
vehicle_blueprint-&gt;SetAttribute(&quot;color&quot;, &quot;255,0,0&quot;);

// 从地图上获取一个出生点
auto spawn_points = world.GetMap()-&gt;GetRecommendedSpawnPoints();
auto transform = spawn_points[0];

// 生成车辆 Actor
auto vehicle_actor = world.SpawnActor(*vehicle_blueprint, transform);
</code></pre></div>
<h3 id="6-sensor">6. <code>Sensor</code> 类与传感器使用（以摄像头为例）</h3>
<p>CARLA 支持多种传感器类型，例如摄像头、激光雷达、碰撞传感器等，传感器均继承自 <code>ClientSideSensor</code> 类。</p>
<h4 id="_17">创建与附加传感器的步骤</h4>
<ul>
<li>
<p>从 BlueprintLibrary 获取传感器蓝图</p>
</li>
<li>
<p>设置传感器参数（如图像分辨率、视场角等）</p>
</li>
<li>
<p>附加到目标 Actor（如车辆）</p>
</li>
<li>
<p>注册数据回调处理函数</p>
</li>
</ul>
<h3 id="_18">示例（以摄像头为例）</h3>
<div class="highlight"><pre><span></span><code>auto camera_bp = blueprint_library-&gt;Find(&quot;sensor.camera.rgb&quot;);
camera_bp-&gt;SetAttribute(&quot;image_size_x&quot;, &quot;800&quot;);
camera_bp-&gt;SetAttribute(&quot;image_size_y&quot;, &quot;600&quot;);
camera_bp-&gt;SetAttribute(&quot;fov&quot;, &quot;90&quot;);

// 定义相对于车辆的位置（车顶前部）
Transform camera_transform(Location(1.5f, 0.0f, 2.4f));

// 创建摄像头并附加到车辆
auto camera = world.SpawnActor(*camera_bp, camera_transform, vehicle_actor);

// 注册数据处理回调
std::static_pointer_cast&lt;ClientSideSensor&gt;(camera)-&gt;Listen([](auto data) {
    auto image = std::static_pointer_cast&lt;sensor::data::Image&gt;(data);
    image-&gt;SaveToDisk(&quot;output/%06d.png&quot;, image-&gt;GetFrame());
});
</code></pre></div>
<h3 id="7-world">7. <code>World</code> 类</h3>
<p>World 类表示一个仿真世界实例，它封装了场景中的地图、实体、天气、环境参数等。通过 <code>Client::LoadWorld()</code> 可获得 <code>World</code> 对象。</p>
<h4 id="_19">常用方法</h4>
<ul>
<li>
<p><code>GetActors()</code>：获取当前世界中所有实体</p>
</li>
<li>
<p><code>GetBlueprintLibrary()</code>：获取实体蓝图列表</p>
</li>
<li>
<p><code>SpawnActor()</code>：创建新实体</p>
</li>
<li>
<p><code>Tick()</code>：推进世界一帧（同步模式）</p>
</li>
<li>
<p><code>SetWeather()</code>：设置天气（如雨、雾、阳光）</p>
</li>
<li>
<p><code>GetMap()</code>：获取当前地图信息</p>
</li>
</ul>
<h4 id="_20">示例（以设置天气为例）</h4>
<div class="highlight"><pre><span></span><code>carla::rpc::WeatherParameters weather;
weather.cloudiness = 80.0f;
weather.precipitation = 30.0f;
weather.sun_altitude_angle = 45.0f;
world.SetWeather(weather);
</code></pre></div>
<hr />
<h2 id="_21"><strong>扩展板块</strong></h2>
<h3 id="1debughelper-carla">1、DebugHelper 模块：CARLA 客户端调试可视化工具</h3>
<p><code>DebugHelper</code> 是 CARLA <code>client</code> 部分的重要组件之一，主要用于<strong>在仿真世界中可视化各种调试信息</strong>，帮助开发者直观地了解仿真环境中各类实体和交互的运行状态。</p>
<p>该模块基于 <code>rpc::DebugShape</code> 实现了多个图形绘制方法，包括点、线、箭头、边界框和文本等。所有形状通过调用统一的模板函数 <code>DrawShape</code> 实现绘制，绘图内容会被添加到当前模拟剧集中（<code>EpisodeProxy</code>）。</p>
<h4 id="_22">功能概览</h4>
<p><code>DebugHelper</code> 提供以下绘图接口，每个函数内部都调用 <code>DrawShape</code> 模板函数生成具体的 <code>rpc::DebugShape</code>：</p>
<ul>
<li><code>DrawPoint</code>：绘制普通点</li>
<li><code>DrawHUDPoint</code>：绘制 HUD 点（投影到 HUD 层的点）</li>
<li><code>DrawLine</code>：绘制线段</li>
<li><code>DrawHUDLine</code>：绘制 HUD 线段</li>
<li><code>DrawArrow</code>：绘制带箭头的线</li>
<li><code>DrawHUDArrow</code>：绘制 HUD 箭头</li>
<li><code>DrawBox</code>：绘制三维边界框</li>
<li><code>DrawHUDBox</code>：绘制 HUD 边界框</li>
<li><code>DrawString</code>：在空间中绘制文字信息</li>
</ul>
<p>所有方法均支持设置：</p>
<ul>
<li><strong>颜色（Color）</strong></li>
<li><strong>生命周期（life_time）</strong></li>
<li><strong>是否为持久绘图（persistent_lines）</strong></li>
</ul>
<h3 id="_23">内部实现结构</h3>
<p>所有绘图方法都通过调用如下统一模板函数实现绘制：</p>
<p><div class="highlight"><pre><span></span><code>template &lt;typename T&gt;
static void DrawShape(detail::EpisodeProxy &amp;episode,
                      const T &amp;primitive,
                      rpc::Color color,
                      float life_time,
                      bool persistent_lines) {
  const Shape shape{primitive, color, life_time, persistent_lines};
  episode.Lock()-&gt;DrawDebugShape(shape);
}
</code></pre></div>
该函数接收一个图形 primitive（如点、线、框等），并封装为 DebugShape 后添加到当前仿真剧集中。</p>
<h4 id="_24">使用场景</h4>
<ul>
<li>
<p>在开发过程中验证 AI 行为（例如绘制导航路线）</p>
</li>
<li>
<p>调试地图元素（如车道线、交通标志检测）</p>
</li>
<li>
<p>实时可视化传感器数据结果</p>
</li>
<li>
<p>在科研或演示过程中进行辅助说明</p>
</li>
</ul>
<h4 id="_25">小结</h4>
<p>DebugHelper 是 CARLA 提供的轻量级可视化调试接口，极大提升了开发效率。它通过统一封装和生命周期控制，使用户可以灵活地向仿真场景中添加临时的可视图形，方便排查问题、验证逻辑或演示系统能力。</p>
<h3 id="2filetransfer-carla">2、FileTransfer 模块：CARLA 客户端的文件读写与缓存机制</h3>
<p><code>FileTransfer</code> 是 CARLA 客户端中的静态类模块，专用于<strong>文件的本地读写、缓存管理以及路径设置</strong>等操作。其设计初衷是为了在客户端环境中缓存或传输所需的文件数据，如地图片段、传感器结果或其他模拟资源，减少不必要的重复下载或传输。</p>
<p>该模块主要由两个文件组成：</p>
<ul>
<li><code>FileTransfer.h</code>：定义了该类的接口及核心成员变量。</li>
<li><code>FileTransfer.cpp</code>：实现了各个接口的具体功能。</li>
</ul>
<hr />
<h4 id="_26">核心功能接口</h4>
<table>
<thead>
<tr>
<th>接口名</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SetFilesBaseFolder(path)</code></td>
<td>设置本地文件缓存基础目录（必须是非空路径），自动添加尾部斜杠</td>
</tr>
<tr>
<td><code>GetFilesBaseFolder()</code></td>
<td>获取当前设置的基础路径</td>
</tr>
<tr>
<td><code>FileExists(file)</code></td>
<td>检查指定文件是否存在于当前版本的缓存目录中</td>
</tr>
<tr>
<td><code>WriteFile(path, content)</code></td>
<td>将二进制内容写入指定路径文件中，并自动创建所需目录结构</td>
</tr>
<tr>
<td><code>ReadFile(path)</code></td>
<td>从指定路径读取二进制文件，返回字节向量</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="_27">文件路径结构与平台兼容性</h4>
<p>模块中根据操作系统自动设置默认的缓存根目录 <code>_filesBaseFolder</code>：</p>
<ul>
<li>Windows 系统：<code>%USERPROFILE%/carlaCache/</code></li>
<li>Linux / macOS：<code>$HOME/carlaCache/</code></li>
</ul>
<p>所有操作文件的路径会被扩展为如下格式：
&lt;基础路径&gt;/<CARLA版本>/&lt;目标文件&gt;</p>
<p>其中 <code>&lt;CARLA版本&gt;</code> 通过调用 <code>carla::version()</code> 获取。</p>
<h4 id="_28">路径验证与创建逻辑</h4>
<p>在 <code>WriteFile</code> 函数中，使用了 CARLA 内部的 <code>FileSystem::ValidateFilePath()</code> 方法来确保路径存在并合法，如不存在会自动创建相应目录。这一机制增强了程序的健壮性与用户的易用性。</p>
<h4 id="_29">示例：写入与读取缓存文件</h4>
<p><div class="highlight"><pre><span></span><code>std::vector&lt;uint8_t&gt; data = {0x01, 0x02, 0x03};
FileTransfer::WriteFile(&quot;sensor/lidar.bin&quot;, data);

std::vector&lt;uint8_t&gt; result = FileTransfer::ReadFile(&quot;sensor/lidar.bin&quot;);
</code></pre></div>
该段代码将一个小型字节向量写入缓存路径，并随后读取回来，展示了 FileTransfer 简洁易用的接口风格。</p>
<h4 id="_30">设计特点</h4>
<ul>
<li>
<p>所有函数为静态方法（类不能被实例化）</p>
</li>
<li>
<p>内部缓存路径根据系统平台自动设定</p>
</li>
<li>
<p>所有路径操作均以当前 CARLA 版本为中间层级，便于区分不同版本的数据</p>
</li>
<li>
<p>支持二进制文件的高效读写</p>
</li>
<li>
<p>利用 std::vector<uint8_t> 管理数据，兼容性好</p>
</li>
</ul>
<h4 id="_31">总结</h4>
<p><code>FileTransfer</code>模块提供了 CARLA 客户端中重要的本地文件操作机制，适合用于缓存地图、传感器数据、AI模型结果等静态资源。通过该模块可以显著提高数据复用效率、降低文件操作出错率，并为系统性能和用户体验带来明显提升。</p>
<h3 id="3junction-carla-junction">3、Junction 模块：CARLA 道路交叉口（Junction）建模与访问</h3>
<p><code>Junction</code> 是 CARLA 客户端地图模块中的一个关键类，用于<strong>表示道路网络中的交叉口区域</strong>。该类提供对交叉口 ID、边界范围和交叉区域内道路点（Waypoint）信息的访问能力，通常被用于路径规划、交通规则模拟与可视化渲染等功能中。</p>
<p>该模块由以下两个文件组成：</p>
<ul>
<li><code>Junction.h</code>：定义了类的结构与接口。</li>
<li><code>Junction.cpp</code>：实现了其功能逻辑。</li>
</ul>
<h4 id="_32">类结构与设计</h4>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_id</code></td>
<td>交叉口在道路拓扑中的唯一标识</td>
</tr>
<tr>
<td><code>_bounding_box</code></td>
<td>表示交叉口在世界坐标中的空间范围</td>
</tr>
<tr>
<td><code>_parent</code></td>
<td>指向所属 <code>Map</code> 的共享指针，便于访问地图全局信息</td>
</tr>
</tbody>
</table>
<p>此外，<code>Junction</code> 类继承了 <code>EnableSharedFromThis</code>，并被标记为 <code>NonCopyable</code>，以确保对象管理的正确性与唯一性。</p>
<h4 id="_33">构造函数与访问控制</h4>
<p>构造函数 <code>Junction(SharedPtr&lt;const Map&gt;, const road::Junction *)</code> 被设为 <code>private</code>，仅允许 <code>Map</code> 类作为友元进行构造。这种设计符合“只允许地图构建交叉口对象”的意图，防止外部模块随意构造非法交叉口。</p>
<hr />
<h3 id="_34">提供的接口函数</h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GetId()</code></td>
<td>返回当前交叉口的 ID</td>
</tr>
<tr>
<td><code>GetBoundingBox()</code></td>
<td>返回交叉口所覆盖的三维边界框（<code>geom::BoundingBox</code>）</td>
</tr>
<tr>
<td><code>GetWaypoints(type)</code></td>
<td>返回与该交叉口相关的所有 <code>Waypoint</code> 对，支持根据车道类型过滤，如 <code>Driving</code>、<code>Shoulder</code> 等</td>
</tr>
</tbody>
</table>
<p>其中 <code>GetWaypoints</code> 默认仅返回行驶车道（<code>Driving</code>）的相关路径点对，调用时可按需调整车道类型参数。</p>
<h4 id="_35">示例：获取交叉口路径点对</h4>
<div class="highlight"><pre><span></span><code>auto junction_list = map-&gt;GetJunctions();
for (auto&amp; junction : junction_list) {
    auto wp_pairs = junction-&gt;GetWaypoints(road::Lane::LaneType::Driving);
    for (auto&amp; pair : wp_pairs) {
        auto entry = pair.first;
        auto exit = pair.second;
        // 可用于路径规划或交通仿真
    }
}
</code></pre></div>
<h4 id="_36">应用场景</h4>
<ul>
<li>
<p>获取交叉口覆盖区域，用于渲染、碰撞检测或自动驾驶决策；</p>
</li>
<li>
<p>获取进入与离开交叉口的路径点对，实现行为规划（如左转、右转、直行）；</p>
</li>
<li>
<p>通过 Junction::GetId() 与道路拓扑结构联动，解析交通节点关系。</p>
</li>
</ul>
<h4 id="_37">总结</h4>
<p><code>Junction</code> 类为 CARLA 中交叉口建模提供了清晰、面向对象的封装方式。它作为 Map 类的组成部分，隐藏了底层拓扑数据的复杂性，同时提供了丰富的 API 支持，是交通仿真与路径分析不可或缺的模块。</p>
<h3 id="4laneinvasion-carla-lane-invasion">4、LaneInvasion 模块：CARLA 车道入侵（Lane Invasion）检测与处理</h3>
<p><code>LaneInvasion</code> 是 CARLA 传感器系统中的一个事件检测模块，用于<strong>监测车辆是否越过车道线</strong>。该模块广泛用于驾驶策略评估、车辆行为监控以及安全规则验证，是自动驾驶测试中的重要工具之一。</p>
<h4 id="_38">该模块的主要组成包括：</h4>
<ul>
<li><code>LaneInvasionSensor.h</code>：定义了传感器的基本结构与回调接口；</li>
<li><code>LaneInvasionSensor.cpp</code>：实现了车道线检测的逻辑；</li>
<li><code>LaneInvasionEvent.h / .cpp</code>：封装了每次触发的事件信息。</li>
</ul>
<hr />
<h4 id="_39">类结构与设计</h4>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_parent_actor</code></td>
<td>被绑定的车辆 Actor，用于检测其车道状态</td>
</tr>
<tr>
<td><code>_callback</code></td>
<td>用户注册的回调函数，在触发车道入侵时调用</td>
</tr>
<tr>
<td><code>_lane_markings</code></td>
<td>当前被侵入的车道线类型（如实线、虚线等）</td>
</tr>
</tbody>
</table>
<p>传感器作为 <code>Sensor</code> 的派生类，通过 CARLA 的 Actor 系统被附着到车辆上。每当车辆穿越车道标线时，该传感器便会生成一次事件，并触发回调。</p>
<h4 id="_40">提供的接口函数</h4>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Listen(callback)</code></td>
<td>注册回调函数以处理车道入侵事件</td>
</tr>
<tr>
<td><code>Stop()</code></td>
<td>停止传感器监听</td>
</tr>
<tr>
<td><code>GetActor()</code></td>
<td>返回绑定的车辆 Actor</td>
</tr>
<tr>
<td><code>GetLaneMarkings()</code></td>
<td>获取当前入侵事件中涉及的车道线类型列表</td>
</tr>
</tbody>
</table>
<p>其中，<code>Listen</code> 是最关键的接口，用户可通过传入 Lambda 函数或回调对象，自定义入侵响应逻辑。</p>
<hr />
<h4 id="_41">示例：注册车道入侵事件监听器</h4>
<div class="highlight"><pre><span></span><code>auto sensor = world.SpawnActor(sensor_bp, transform, vehicle);
auto lane_invasion_sensor = boost::static_pointer_cast&lt;carla::sensor::data::LaneInvasionEvent&gt;(sensor);

sensor-&gt;Listen([](auto data) {
    auto event = boost::static_pointer_cast&lt;carla::sensor::data::LaneInvasionEvent&gt;(data);
    for (auto mark : event-&gt;GetCrossedLaneMarkings()) {
        std::cout &lt;&lt; &quot;Lane invasion detected: &quot; &lt;&lt; mark.TypeToString() &lt;&lt; std::endl;
    }
});
</code></pre></div>
<h4 id="_42">应用场景</h4>
<ul>
<li>
<p>驾驶员违规行为监控：识别是否压线行驶，评估驾驶行为合规性；</p>
</li>
<li>
<p>路径偏移检测：在路径规划中判断车辆是否偏离既定路线；</p>
</li>
<li>
<p>规则执行引擎支持：结合交通规则仿真，在违反道路线规则时进行惩罚或报警；</p>
</li>
<li>
<p>系统调试与可视化：在自动驾驶开发中用于调试控制策略，结合可视化界面标注压线轨迹。</p>
</li>
</ul>
<h4 id="laneinvasionevent">事件结构（LaneInvasionEvent）</h4>
<p>每次入侵会生成一个 <code>LaneInvasionEvent</code> 对象，包含以下信息：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>crossed_lane_markings</code></td>
<td><code>std::vector&lt;LaneMarking&gt;</code></td>
<td>被穿越的车道线集合</td>
</tr>
<tr>
<td><code>actor</code></td>
<td><code>Actor</code></td>
<td>触发事件的车辆</td>
</tr>
<tr>
<td><code>timestamp</code></td>
<td><code>Time</code></td>
<td>事件发生时间戳</td>
</tr>
</tbody>
</table>
<h4 id="_43">总结</h4>
<p><code>LaneInvasion</code> 模块为 CARLA 中提供了高效、可扩展的车道线检测机制，是自动驾驶测试流程中的重要一环。通过该模块，开发者可方便地监控车辆是否遵循车道规范，并可将入侵事件集成至评估、报警或控制逻辑中，显著提升仿真测试的准确性与现实性。</p>
<h3 id="5light-carla">5、Light 模块：CARLA 中的交通灯与照明灯控制接口</h3>
<p><code>Light</code> 模块是 CARLA 客户端中用于操作和管理灯光对象（包括交通灯、街道灯、车灯等）的类。它通过封装 <code>LightManager</code> 的控制接口，允许用户<strong>读取和设置灯光属性、状态、分组以及开关控制</strong>，在交通仿真与可视化系统中扮演关键角色。</p>
<p>该模块主要由以下文件组成：</p>
<ul>
<li><code>Light.h</code>：声明 <code>Light</code> 类的接口；</li>
<li><code>Light.cpp</code>：实现灯光状态的读取和设置功能；</li>
<li>依赖 <code>LightManager</code> 实现实际的灯光控制。</li>
</ul>
<h4 id="_44">类结构与设计</h4>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_id</code></td>
<td>当前灯光的唯一标识符</td>
</tr>
<tr>
<td><code>_light_manager</code></td>
<td>指向 <code>LightManager</code> 的弱引用指针，确保灯光操作的上下文一致性</td>
</tr>
</tbody>
</table>
<p>所有灯光状态操作均通过 <code>_light_manager</code> 执行，确保集中管理和同步执行。</p>
<h4 id="_45">提供的接口函数</h4>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GetColor()</code></td>
<td>获取当前灯光颜色</td>
</tr>
<tr>
<td><code>GetIntensity()</code></td>
<td>获取当前灯光亮度（强度）</td>
</tr>
<tr>
<td><code>GetLightGroup()</code></td>
<td>获取灯光所属分组</td>
</tr>
<tr>
<td><code>GetLightState()</code></td>
<td>获取灯光完整状态（如颜色、开关、组别等）</td>
</tr>
<tr>
<td><code>IsOn()</code> / <code>IsOff()</code></td>
<td>判断灯光是否已开启或关闭</td>
</tr>
<tr>
<td><code>SetColor(Color)</code></td>
<td>设置灯光颜色</td>
</tr>
<tr>
<td><code>SetIntensity(float)</code></td>
<td>设置灯光亮度</td>
</tr>
<tr>
<td><code>SetLightGroup(group)</code></td>
<td>设置灯光所属分组</td>
</tr>
<tr>
<td><code>SetLightState(state)</code></td>
<td>设置完整灯光状态</td>
</tr>
<tr>
<td><code>TurnOn()</code> / <code>TurnOff()</code></td>
<td>控制灯光开关</td>
</tr>
</tbody>
</table>
<h4 id="_46">示例：设置灯光颜色与状态</h4>
<div class="highlight"><pre><span></span><code>auto light = some_actor.GetLight();

// 设置灯光颜色为红色
light.SetColor(carla::Color(255, 0, 0));

// 设置强度为5.0
light.SetIntensity(5.0f);

// 设置状态为开启状态并指定组别
carla::rpc::LightState state;
state.active = true;
state.intensity = 5.0f;
state.color = carla::Color(255, 255, 0);
state.group = carla::rpc::LightState::LightGroup::Street;

light.SetLightState(state);
</code></pre></div>
<h4 id="_47">应用场景</h4>
<ul>
<li>交通灯仿真控制：控制红绿灯的开关状态与颜色变换；</li>
<li>街道照明模拟：控制夜间场景下街灯的亮度与颜色；</li>
<li>视觉感知测试：模拟不同灯光环境用于测试自动驾驶感知算法；</li>
<li>动态灯光效果渲染：在交互式仿真场景中创建逼真的灯光效果变化。</li>
</ul>
<h4 id="_48">模块特性与设计优势</h4>
<ul>
<li>所有接口均通过 LightManager 管理，集中控制所有灯光对象；</li>
<li>利用 weak_ptr 提高资源管理效率，避免循环引用；</li>
<li>支持细粒度的灯光操作，如单独控制颜色、强度、分组等；</li>
<li>可作为传感器、视觉系统或控制模块的辅助工具。</li>
</ul>
<h4 id="_49">总结</h4>
<p><code>Light</code>模块为 CARLA 中所有可控灯光对象提供了统一、灵活的控制接口。它结合 <code>LightManager</code>实现了强大的灯光仿真能力，
为真实感可视化和智能交通仿真提供关键支持。该模块对提升自动驾驶仿真环境的真实性和交互性具有重要意义。</p>
<h3 id="6vehicle-carla">6、Vehicle 模块：CARLA 车辆实体控制与状态管理</h3>
<p><code>Vehicle</code> 是 CARLA 模拟器中用于<strong>表示和操作模拟场景中的车辆 Actor</strong> 的基本类。该类接口完善，支持车辆的控制操作、自动驾驶切换、物理参数调用以及交通灯交互，是自动驾驶仿真中的核心组件之一。</p>
<p>该模块包括两部分文件：</p>
<ul>
<li><code>Vehicle.h</code>：定义车辆类的基本结构和操作接口。</li>
<li><code>Vehicle.cpp</code>：实现了车辆控制逻辑和状态查询功能。</li>
</ul>
<h4 id="_50">类设计与主要成员</h4>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_control</code></td>
<td>存储最后一次应用的车辆控制指令</td>
</tr>
<tr>
<td><code>_is_control_sticky</code></td>
<td>表示是否使用“粘性控制”（即无需重复上传一样的指令）</td>
</tr>
</tbody>
</table>
<p><code>Vehicle</code> 类继承自 <code>Actor</code>，并使用多类型符合 CARLA 控制器标准。</p>
<h4 id="_51">公共接口函数</h4>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SetAutopilot(bool, tm_port)</code></td>
<td>设置是否使用自动驾驶 (与 TrafficManager 联动)</td>
</tr>
<tr>
<td><code>ApplyControl()</code></td>
<td>应用基础车辆控制指令 (加速、转向、刹车)</td>
</tr>
<tr>
<td><code>ApplyAckermannControl()</code></td>
<td>应用 Ackermann 转向控制</td>
</tr>
<tr>
<td><code>GetControl()</code></td>
<td>获取当前车辆控制指令</td>
</tr>
<tr>
<td><code>ApplyPhysicsControl()</code></td>
<td>设置车辆物理参数 (重量、碳体积等)</td>
</tr>
<tr>
<td><code>GetTelemetryData()</code></td>
<td>获取车辆遥测数据 (位置、速度等)</td>
</tr>
<tr>
<td><code>OpenDoor()</code> / <code>CloseDoor()</code></td>
<td>操作车门打开或关闭</td>
</tr>
<tr>
<td><code>SetLightState()</code> / <code>GetLightState()</code></td>
<td>设置和查询车灯状态</td>
</tr>
<tr>
<td><code>SetWheelSteerDirection()</code> / <code>GetWheelSteerAngle()</code></td>
<td>设置/获取车轮转向角</td>
</tr>
<tr>
<td><code>EnableCarSim()</code> / <code>UseCarSimRoad()</code></td>
<td>使用 CarSim 车辆模型和道路</td>
</tr>
<tr>
<td><code>EnableChronoPhysics()</code> / <code>RestorePhysXPhysics()</code></td>
<td>切换车辆物理引擎 (Chrono 或 PhysX)</td>
</tr>
<tr>
<td><code>IsAtTrafficLight()</code> / <code>GetTrafficLight()</code></td>
<td>判断是否被交通灯影响，并获取当前交通灯对象</td>
</tr>
<tr>
<td><code>GetSpeedLimit()</code></td>
<td>获取当前车辆速度限制</td>
</tr>
<tr>
<td><code>GetFailureState()</code></td>
<td>获取车辆故障状态</td>
</tr>
</tbody>
</table>
<h4 id="_52">示例：启用自动驾驶</h4>
<div class="highlight"><pre><span></span><code>// 车辆初始化
carla::client::Vehicle vehicle = ...;

// 启用自动驾驶
vehicle.SetAutopilot(true);
</code></pre></div>
<h4 id="_53">应用场景</h4>
<ul>
<li>自动驾驶模拟控制：接入 TrafficManager 实现汽车流量自动控制</li>
<li>车辆系统调用分析：通过接口获取操作、物理和状态数据</li>
<li>高级路径控制实验：配合 Ackermann 控制器进行路径跳转与车轮方向控制</li>
</ul>
<h4 id="_54">总结</h4>
<p><code>Vehicle</code> 模块是 CARLA 中表示和操作车辆的核心类。它包括了驾驶、控制、物理反应和交通环境交互等方面，
是完成实时交通模拟与自动驾驶系统组装的基石。</p>
<hr />
<h2 id="_55"><strong>类之间的调用关系</strong></h2>
<h3 id="carla_1">以下是 CARLA 客户端部分类之间的调用关系图，展示了各个类如何交互以及它们之间的依赖关系。</h3>
<p><img alt="类关系" src="https://github.com/LangJing23/nuanxin_volunteer/blob/master/lei.png" /></p>
<h5 id="_56">调用关系说明</h5>
<p>Client 类与其他类的交互：</p>
<blockquote>
<p>Client 类是与模拟器交互的主要接口，它通过方法如 LoadWorld()、GetAvailableMaps()、StartRecorder() 等来控制仿真世界。</p>
<p>Client 类使用 World 对象来表示仿真世界并操作其中的行为体（Actor 类）。</p>
<p>Actor 类与 Client 类的关系：</p>
<p>Actor 类表示仿真中的个体实体（如车辆、行人等），Client 类通过 Actor 对象控制仿真中的行为体（例如获取位置、速度，设置物理属性等）。</p>
<p>Actor 类也与传感器和交通管理相关联，可以通过 ClientSideSensor 和 TrafficManager 与交通流和传感器交互。</p>
<p>TrafficManager 类与 Client 类的关系：</p>
<p>TrafficManager 管理仿真中的交通流，Client 类通过 TrafficManager 提供的接口（如 SetSynchronousMode()）来控制仿真中的交通规则、车辆行为等。</p>
</blockquote>
<p>ClientSideSensor 类与 Actor 类的关系：</p>
<blockquote>
<p>ClientSideSensor 类用于模拟仿真中的传感器，能够附加到 Actor 上，例如摄像头、激光雷达等。</p>
<p>传感器可以用来获取 Actor 周围的环境数据（例如图像、点云等），以支持自动驾驶算法的训练与验证。</p>
</blockquote>
<p>World 类与其他类的关系：</p>
<blockquote>
<p>World 类表示仿真中的一个世界，它与 Client 和 Actor 类紧密关联。World 提供对仿真环境的访问，可以控制仿真世界中的所有行为体和传感器。</p>
<p>World 还负责管理交通流、物理环境、天气等仿真环境因素。</p>
</blockquote>
<h2 id="_57">总结</h2>
<p>CARLA 客户端部分提供了与仿真环境交互的丰富 API，支持开发者控制仿真世界中的各种元素，包括行为体（Actor）、传感器（ClientSideSensor）和交通流（TrafficManager）等。通过 Client 类，开发者能够加载地图、获取世界状态、管理传感器、操作物理环境等。类之间的交互使得开发者能够在仿真环境中进行精确的控制和验证。</p>
<p>参考文档：<a href="https://openhutb.github.io/carla_cpp/dir_64d7bb605f27024d49af86070bd3f0b6.html">点击此处跳转</a></p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/OpenHUTB/doc" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="https://cdn.rawgit.com/knsv/mermaid/6.0.0/dist/mermaid.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script>
      <script src="../../js/umlconvert.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
