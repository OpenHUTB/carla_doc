<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>概述 - 人车模拟器</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u6982\u8ff0";
        var mkdocs_page_input_path = "modules/client.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> 人车模拟器
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">首页</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">人车模拟器</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">概述</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/OpenHUTB/carla_doc/edit/master/docs/modules/client.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1"><strong>概述</strong></h1>
<p>CARLA 是一个开源的自动驾驶模拟平台，提供了丰富的 API 以支持仿真环境的控制、车辆的管理以及自动驾驶算法的验证。客户端部分的 API 主要通过 <code>Client</code> 类与模拟器进行交互，执行仿真控制、传感器管理、交通流管理等功能。该文档主要介绍 CARLA 客户端相关类的功能和使用方式。</p>
<h2 id="_2"><strong>主要类与功能</strong></h2>
<h3 id="1-client">1. <code>Client</code> 类</h3>
<p><code>Client</code> 类是与 CARLA 模拟器交互的核心类，提供了连接仿真器、加载世界、设置物理参数、控制传感器等功能。</p>
<h4 id="_3">构造函数</h4>
<ul>
<li><code>Client(const std::string &amp;host, uint16_t port, size_t worker_threads = 0u)</code></li>
<li>构建一个与 CARLA 仿真器的客户端连接。</li>
<li><code>host</code>：模拟器所在主机的 IP 地址。</li>
<li><code>port</code>：与模拟器的连接端口。</li>
<li><code>worker_threads</code>：使用的异步工作线程数，默认为 0（使用所有可用线程）。</li>
</ul>
<h4 id="_4">核心方法</h4>
<ul>
<li>
<p><code>std::string GetClientVersion() const</code></p>
</li>
<li>
<p>获取当前客户端的版本。</p>
</li>
<li>
<p><code>std::string GetServerVersion() const</code></p>
</li>
<li>
<p>获取当前连接的模拟器的版本。</p>
</li>
<li>
<p><code>std::vector&lt;std::string&gt; GetAvailableMaps() const</code></p>
</li>
<li>
<p>获取所有可用的地图名称。</p>
</li>
<li>
<p><code>World LoadWorld(std::string map_name, bool reset_settings = true, rpc::MapLayer map_layers = rpc::MapLayer::All) const</code></p>
</li>
<li>
<p>加载指定的仿真地图。</p>
</li>
<li>
<p><code>World ReloadWorld(bool reset_settings = true) const</code></p>
</li>
<li>
<p>重新加载当前仿真世界。</p>
</li>
<li>
<p><code>void SetTimeout(time_duration timeout)</code></p>
</li>
<li>
<p>设置与模拟器的网络超时时间。</p>
</li>
<li>
<p><code>TrafficManager GetInstanceTM(uint16_t port = TM_DEFAULT_PORT) const</code></p>
</li>
<li>
<p>获取当前模拟器中的交通管理实例（TrafficManager）。</p>
</li>
<li>
<p><code>void StartRecorder(std::string name, bool additional_data = false)</code></p>
</li>
<li>
<p>启动仿真数据记录器。</p>
</li>
<li>
<p><code>void StopRecorder()</code></p>
</li>
<li>
<p>停止仿真数据记录器。</p>
</li>
<li>
<p><code>World GenerateOpenDriveWorld(std::string opendrive, const rpc::OpendriveGenerationParameters &amp;params, bool reset_settings = true) const</code></p>
</li>
<li>使用 OpenDrive 文件生成仿真世界。</li>
</ul>
<h3 id="2-actor">2. <code>Actor</code> 类</h3>
<p><code>Actor</code> 类代表仿真中的任何实体（例如：车辆、行人等）。通过该类，用户可以控制行为体的位置、速度、碰撞、物理状态等。</p>
<h4 id="_5">核心方法</h4>
<ul>
<li>
<p><code>geom::Location GetLocation() const</code></p>
</li>
<li>
<p>获取行为体的当前位置。</p>
</li>
<li>
<p><code>geom::Transform GetTransform() const</code></p>
</li>
<li>
<p>获取行为体的变换（位置与方向）。</p>
</li>
<li>
<p><code>void SetLocation(const geom::Location&amp; location)</code></p>
</li>
<li>
<p>设置行为体的位置。</p>
</li>
<li>
<p><code>void SetTransform(const geom::Transform&amp; transform)</code></p>
</li>
<li>
<p>设置行为体的变换（位置与方向）。</p>
</li>
<li>
<p><code>void AddImpulse(const geom::Vector3D&amp; impulse)</code></p>
</li>
<li>
<p>向行为体添加冲量。</p>
</li>
<li>
<p><code>void AddForce(const geom::Vector3D&amp; force)</code></p>
</li>
<li>
<p>向行为体施加力。</p>
</li>
<li>
<p><code>void SetSimulatePhysics(bool enabled = true)</code></p>
</li>
<li>
<p>启用或禁用行为体的物理模拟。</p>
</li>
<li>
<p><code>bool Destroy()</code></p>
</li>
<li>销毁行为体。</li>
</ul>
<h3 id="3-clientsidesensor">3. <code>ClientSideSensor</code> 类</h3>
<p><code>ClientSideSensor</code> 类继承自 <code>Sensor</code> 类，代表 CARLA 中的客户端传感器（如摄像头、激光雷达等）。</p>
<h4 id="_6">核心方法</h4>
<ul>
<li>
<p><code>void Enable()</code></p>
</li>
<li>
<p>启用传感器。</p>
</li>
<li>
<p><code>void Disable()</code></p>
</li>
<li>
<p>禁用传感器。</p>
</li>
<li>
<p><code>bool IsEnabled() const</code></p>
</li>
<li>检查传感器是否启用。</li>
</ul>
<h3 id="4-trafficmanager">4. 交通管理器（<code>TrafficManager</code>）</h3>
<p><code>TrafficManager</code> 类用于管理仿真中的交通流，控制交通行为，包括交通灯的状态、车辆的行驶路线、交通规则等。</p>
<h4 id="_7">核心方法</h4>
<ul>
<li>
<p><code>void SetGlobalDistanceToLeadingVehicle(float distance)</code></p>
</li>
<li>
<p>设置车辆与前车的最小安全距离。</p>
</li>
<li>
<p><code>void SetVehicleDistanceToLeadingVehicle(float distance)</code></p>
</li>
<li>
<p>设置单个车辆与前车的最小安全距离。</p>
</li>
<li>
<p><code>void SetSynchronousMode(bool enabled)</code></p>
</li>
<li>启用或禁用同步模式，在同步模式下仿真步进是由用户控制的。</li>
</ul>
<h3 id="5-blueprintlibrary-actorblueprint">5. <code>BlueprintLibrary</code> 与 <code>ActorBlueprint</code> 类</h3>
<p>在 CARLA 客户端中，<code>BlueprintLibrary</code> 类用于提供创建行为体（Actor）的模板集合，而 <code>ActorBlueprint</code> 则描述具体实体的构造配置参数。</p>
<h4 id="_8">主要功能</h4>
<ul>
<li>
<p><code>BlueprintLibrary</code></p>
</li>
<li>
<p>获取可创建的实体蓝图列表（如车辆、传感器等）</p>
</li>
<li>
<p>支持通过关键词过滤蓝图</p>
</li>
<li>
<p><code>ActorBlueprint</code></p>
</li>
<li>表示单个实体的构造参数（如车辆类型、颜色，传感器分辨率等）</li>
<li>可设置和查询各类属性值</li>
</ul>
<h4 id="_9">示例</h4>
<div class="highlight"><pre><span></span><code>auto blueprint_library = world.GetBlueprintLibrary();

// 选择一辆特斯拉车型的 blueprint
auto vehicle_blueprint = (*blueprint_library)-&gt;Find(&quot;vehicle.tesla.model3&quot;);

// 设置车辆颜色
vehicle_blueprint-&gt;SetAttribute(&quot;color&quot;, &quot;255,0,0&quot;);

// 从地图上获取一个出生点
auto spawn_points = world.GetMap()-&gt;GetRecommendedSpawnPoints();
auto transform = spawn_points[0];

// 生成车辆 Actor
auto vehicle_actor = world.SpawnActor(*vehicle_blueprint, transform);
</code></pre></div>
<h3 id="6-sensor">6. <code>Sensor</code> 类与传感器使用（以摄像头为例）</h3>
<p>CARLA 支持多种传感器类型，例如摄像头、激光雷达、碰撞传感器等，传感器均继承自 <code>ClientSideSensor</code> 类。</p>
<h4 id="_10">创建与附加传感器的步骤</h4>
<ul>
<li>
<p>从 BlueprintLibrary 获取传感器蓝图</p>
</li>
<li>
<p>设置传感器参数（如图像分辨率、视场角等）</p>
</li>
<li>
<p>附加到目标 Actor（如车辆）</p>
</li>
<li>
<p>注册数据回调处理函数</p>
</li>
</ul>
<h3 id="_11">示例（以摄像头为例）</h3>
<div class="highlight"><pre><span></span><code>auto camera_bp = blueprint_library-&gt;Find(&quot;sensor.camera.rgb&quot;);
camera_bp-&gt;SetAttribute(&quot;image_size_x&quot;, &quot;800&quot;);
camera_bp-&gt;SetAttribute(&quot;image_size_y&quot;, &quot;600&quot;);
camera_bp-&gt;SetAttribute(&quot;fov&quot;, &quot;90&quot;);

// 定义相对于车辆的位置（车顶前部）
Transform camera_transform(Location(1.5f, 0.0f, 2.4f));

// 创建摄像头并附加到车辆
auto camera = world.SpawnActor(*camera_bp, camera_transform, vehicle_actor);

// 注册数据处理回调
std::static_pointer_cast&lt;ClientSideSensor&gt;(camera)-&gt;Listen([](auto data) {
    auto image = std::static_pointer_cast&lt;sensor::data::Image&gt;(data);
    image-&gt;SaveToDisk(&quot;output/%06d.png&quot;, image-&gt;GetFrame());
});
</code></pre></div>
<h3 id="7-world">7. <code>World</code> 类</h3>
<p>World 类表示一个仿真世界实例，它封装了场景中的地图、实体、天气、环境参数等。通过 <code>Client::LoadWorld()</code> 可获得 <code>World</code> 对象。</p>
<h4 id="_12">常用方法</h4>
<ul>
<li>
<p><code>GetActors()</code>：获取当前世界中所有实体</p>
</li>
<li>
<p><code>GetBlueprintLibrary()</code>：获取实体蓝图列表</p>
</li>
<li>
<p><code>SpawnActor()</code>：创建新实体</p>
</li>
<li>
<p><code>Tick()</code>：推进世界一帧（同步模式）</p>
</li>
<li>
<p><code>SetWeather()</code>：设置天气（如雨、雾、阳光）</p>
</li>
<li>
<p><code>GetMap()</code>：获取当前地图信息</p>
</li>
</ul>
<h4 id="_13">示例（以设置天气为例）</h4>
<div class="highlight"><pre><span></span><code>carla::rpc::WeatherParameters weather;
weather.cloudiness = 80.0f;
weather.precipitation = 30.0f;
weather.sun_altitude_angle = 45.0f;
world.SetWeather(weather);
</code></pre></div>
<hr />
<h2 id="_14"><strong>扩展板块</strong></h2>
<h3 id="1debughelper-carla">1、DebugHelper 模块：CARLA 客户端调试可视化工具</h3>
<p><code>DebugHelper</code> 是 CARLA <code>client</code> 部分的重要组件之一，主要用于<strong>在仿真世界中可视化各种调试信息</strong>，帮助开发者直观地了解仿真环境中各类实体和交互的运行状态。</p>
<p>该模块基于 <code>rpc::DebugShape</code> 实现了多个图形绘制方法，包括点、线、箭头、边界框和文本等。所有形状通过调用统一的模板函数 <code>DrawShape</code> 实现绘制，绘图内容会被添加到当前模拟剧集中（<code>EpisodeProxy</code>）。</p>
<h4 id="_15">功能概览</h4>
<p><code>DebugHelper</code> 提供以下绘图接口，每个函数内部都调用 <code>DrawShape</code> 模板函数生成具体的 <code>rpc::DebugShape</code>：</p>
<ul>
<li><code>DrawPoint</code>：绘制普通点</li>
<li><code>DrawHUDPoint</code>：绘制 HUD 点（投影到 HUD 层的点）</li>
<li><code>DrawLine</code>：绘制线段</li>
<li><code>DrawHUDLine</code>：绘制 HUD 线段</li>
<li><code>DrawArrow</code>：绘制带箭头的线</li>
<li><code>DrawHUDArrow</code>：绘制 HUD 箭头</li>
<li><code>DrawBox</code>：绘制三维边界框</li>
<li><code>DrawHUDBox</code>：绘制 HUD 边界框</li>
<li><code>DrawString</code>：在空间中绘制文字信息</li>
</ul>
<p>所有方法均支持设置：</p>
<ul>
<li><strong>颜色（Color）</strong></li>
<li><strong>生命周期（life_time）</strong></li>
<li><strong>是否为持久绘图（persistent_lines）</strong></li>
</ul>
<h3 id="_16">内部实现结构</h3>
<p>所有绘图方法都通过调用如下统一模板函数实现绘制：</p>
<p><div class="highlight"><pre><span></span><code>template &lt;typename T&gt;
static void DrawShape(detail::EpisodeProxy &amp;episode,
                      const T &amp;primitive,
                      rpc::Color color,
                      float life_time,
                      bool persistent_lines) {
  const Shape shape{primitive, color, life_time, persistent_lines};
  episode.Lock()-&gt;DrawDebugShape(shape);
}
</code></pre></div>
该函数接收一个图形 primitive（如点、线、框等），并封装为 DebugShape 后添加到当前仿真剧集中。</p>
<h4 id="_17">使用场景</h4>
<ul>
<li>
<p>在开发过程中验证 AI 行为（例如绘制导航路线）</p>
</li>
<li>
<p>调试地图元素（如车道线、交通标志检测）</p>
</li>
<li>
<p>实时可视化传感器数据结果</p>
</li>
<li>
<p>在科研或演示过程中进行辅助说明</p>
</li>
</ul>
<h4 id="_18">小结</h4>
<p>DebugHelper 是 CARLA 提供的轻量级可视化调试接口，极大提升了开发效率。它通过统一封装和生命周期控制，使用户可以灵活地向仿真场景中添加临时的可视图形，方便排查问题、验证逻辑或演示系统能力。</p>
<h3 id="2filetransfer-carla">2、FileTransfer 模块：CARLA 客户端的文件读写与缓存机制</h3>
<p><code>FileTransfer</code> 是 CARLA 客户端中的静态类模块，专用于<strong>文件的本地读写、缓存管理以及路径设置</strong>等操作。其设计初衷是为了在客户端环境中缓存或传输所需的文件数据，如地图片段、传感器结果或其他模拟资源，减少不必要的重复下载或传输。</p>
<p>该模块主要由两个文件组成：</p>
<ul>
<li><code>FileTransfer.h</code>：定义了该类的接口及核心成员变量。</li>
<li><code>FileTransfer.cpp</code>：实现了各个接口的具体功能。</li>
</ul>
<hr />
<h4 id="_19">核心功能接口</h4>
<table>
<thead>
<tr>
<th>接口名</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SetFilesBaseFolder(path)</code></td>
<td>设置本地文件缓存基础目录（必须是非空路径），自动添加尾部斜杠</td>
</tr>
<tr>
<td><code>GetFilesBaseFolder()</code></td>
<td>获取当前设置的基础路径</td>
</tr>
<tr>
<td><code>FileExists(file)</code></td>
<td>检查指定文件是否存在于当前版本的缓存目录中</td>
</tr>
<tr>
<td><code>WriteFile(path, content)</code></td>
<td>将二进制内容写入指定路径文件中，并自动创建所需目录结构</td>
</tr>
<tr>
<td><code>ReadFile(path)</code></td>
<td>从指定路径读取二进制文件，返回字节向量</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="_20">文件路径结构与平台兼容性</h4>
<p>模块中根据操作系统自动设置默认的缓存根目录 <code>_filesBaseFolder</code>：</p>
<ul>
<li>Windows 系统：<code>%USERPROFILE%/carlaCache/</code></li>
<li>Linux / macOS：<code>$HOME/carlaCache/</code></li>
</ul>
<p>所有操作文件的路径会被扩展为如下格式：
&lt;基础路径&gt;/<CARLA版本>/&lt;目标文件&gt;</p>
<p>其中 <code>&lt;CARLA版本&gt;</code> 通过调用 <code>carla::version()</code> 获取。</p>
<h4 id="_21">路径验证与创建逻辑</h4>
<p>在 <code>WriteFile</code> 函数中，使用了 CARLA 内部的 <code>FileSystem::ValidateFilePath()</code> 方法来确保路径存在并合法，如不存在会自动创建相应目录。这一机制增强了程序的健壮性与用户的易用性。</p>
<h4 id="_22">示例：写入与读取缓存文件</h4>
<p><div class="highlight"><pre><span></span><code>std::vector&lt;uint8_t&gt; data = {0x01, 0x02, 0x03};
FileTransfer::WriteFile(&quot;sensor/lidar.bin&quot;, data);

std::vector&lt;uint8_t&gt; result = FileTransfer::ReadFile(&quot;sensor/lidar.bin&quot;);
</code></pre></div>
该段代码将一个小型字节向量写入缓存路径，并随后读取回来，展示了 FileTransfer 简洁易用的接口风格。</p>
<h4 id="_23">设计特点</h4>
<ul>
<li>
<p>所有函数为静态方法（类不能被实例化）</p>
</li>
<li>
<p>内部缓存路径根据系统平台自动设定</p>
</li>
<li>
<p>所有路径操作均以当前 CARLA 版本为中间层级，便于区分不同版本的数据</p>
</li>
<li>
<p>支持二进制文件的高效读写</p>
</li>
<li>
<p>利用 std::vector<uint8_t> 管理数据，兼容性好</p>
</li>
</ul>
<h4 id="_24">总结</h4>
<p><code>FileTransfer</code>模块提供了 CARLA 客户端中重要的本地文件操作机制，适合用于缓存地图、传感器数据、AI模型结果等静态资源。通过该模块可以显著提高数据复用效率、降低文件操作出错率，并为系统性能和用户体验带来明显提升。</p>
<h3 id="3junction-carla-junction">3、Junction 模块：CARLA 道路交叉口（Junction）建模与访问</h3>
<p><code>Junction</code> 是 CARLA 客户端地图模块中的一个关键类，用于<strong>表示道路网络中的交叉口区域</strong>。该类提供对交叉口 ID、边界范围和交叉区域内道路点（Waypoint）信息的访问能力，通常被用于路径规划、交通规则模拟与可视化渲染等功能中。</p>
<p>该模块由以下两个文件组成：</p>
<ul>
<li><code>Junction.h</code>：定义了类的结构与接口。</li>
<li><code>Junction.cpp</code>：实现了其功能逻辑。</li>
</ul>
<h4 id="_25">类结构与设计</h4>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_id</code></td>
<td>交叉口在道路拓扑中的唯一标识</td>
</tr>
<tr>
<td><code>_bounding_box</code></td>
<td>表示交叉口在世界坐标中的空间范围</td>
</tr>
<tr>
<td><code>_parent</code></td>
<td>指向所属 <code>Map</code> 的共享指针，便于访问地图全局信息</td>
</tr>
</tbody>
</table>
<p>此外，<code>Junction</code> 类继承了 <code>EnableSharedFromThis</code>，并被标记为 <code>NonCopyable</code>，以确保对象管理的正确性与唯一性。</p>
<h4 id="_26">构造函数与访问控制</h4>
<p>构造函数 <code>Junction(SharedPtr&lt;const Map&gt;, const road::Junction *)</code> 被设为 <code>private</code>，仅允许 <code>Map</code> 类作为友元进行构造。这种设计符合“只允许地图构建交叉口对象”的意图，防止外部模块随意构造非法交叉口。</p>
<hr />
<h3 id="_27">提供的接口函数</h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GetId()</code></td>
<td>返回当前交叉口的 ID</td>
</tr>
<tr>
<td><code>GetBoundingBox()</code></td>
<td>返回交叉口所覆盖的三维边界框（<code>geom::BoundingBox</code>）</td>
</tr>
<tr>
<td><code>GetWaypoints(type)</code></td>
<td>返回与该交叉口相关的所有 <code>Waypoint</code> 对，支持根据车道类型过滤，如 <code>Driving</code>、<code>Shoulder</code> 等</td>
</tr>
</tbody>
</table>
<p>其中 <code>GetWaypoints</code> 默认仅返回行驶车道（<code>Driving</code>）的相关路径点对，调用时可按需调整车道类型参数。</p>
<h4 id="_28">示例：获取交叉口路径点对</h4>
<div class="highlight"><pre><span></span><code>auto junction_list = map-&gt;GetJunctions();
for (auto&amp; junction : junction_list) {
    auto wp_pairs = junction-&gt;GetWaypoints(road::Lane::LaneType::Driving);
    for (auto&amp; pair : wp_pairs) {
        auto entry = pair.first;
        auto exit = pair.second;
        // 可用于路径规划或交通仿真
    }
}
</code></pre></div>
<h4 id="_29">应用场景</h4>
<ul>
<li>
<p>获取交叉口覆盖区域，用于渲染、碰撞检测或自动驾驶决策；</p>
</li>
<li>
<p>获取进入与离开交叉口的路径点对，实现行为规划（如左转、右转、直行）；</p>
</li>
<li>
<p>通过 Junction::GetId() 与道路拓扑结构联动，解析交通节点关系。</p>
</li>
</ul>
<h4 id="_30">总结</h4>
<p><code>Junction</code> 类为 CARLA 中交叉口建模提供了清晰、面向对象的封装方式。它作为 Map 类的组成部分，隐藏了底层拓扑数据的复杂性，同时提供了丰富的 API 支持，是交通仿真与路径分析不可或缺的模块。</p>
<h3 id="4laneinvasion-carla-lane-invasion">4、LaneInvasion 模块：CARLA 车道入侵（Lane Invasion）检测与处理</h3>
<p><code>LaneInvasion</code> 是 CARLA 传感器系统中的一个事件检测模块，用于<strong>监测车辆是否越过车道线</strong>。该模块广泛用于驾驶策略评估、车辆行为监控以及安全规则验证，是自动驾驶测试中的重要工具之一。</p>
<h4 id="_31">该模块的主要组成包括：</h4>
<ul>
<li><code>LaneInvasionSensor.h</code>：定义了传感器的基本结构与回调接口；</li>
<li><code>LaneInvasionSensor.cpp</code>：实现了车道线检测的逻辑；</li>
<li><code>LaneInvasionEvent.h / .cpp</code>：封装了每次触发的事件信息。</li>
</ul>
<hr />
<h4 id="_32">类结构与设计</h4>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_parent_actor</code></td>
<td>被绑定的车辆 Actor，用于检测其车道状态</td>
</tr>
<tr>
<td><code>_callback</code></td>
<td>用户注册的回调函数，在触发车道入侵时调用</td>
</tr>
<tr>
<td><code>_lane_markings</code></td>
<td>当前被侵入的车道线类型（如实线、虚线等）</td>
</tr>
</tbody>
</table>
<p>传感器作为 <code>Sensor</code> 的派生类，通过 CARLA 的 Actor 系统被附着到车辆上。每当车辆穿越车道标线时，该传感器便会生成一次事件，并触发回调。</p>
<h4 id="_33">提供的接口函数</h4>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Listen(callback)</code></td>
<td>注册回调函数以处理车道入侵事件</td>
</tr>
<tr>
<td><code>Stop()</code></td>
<td>停止传感器监听</td>
</tr>
<tr>
<td><code>GetActor()</code></td>
<td>返回绑定的车辆 Actor</td>
</tr>
<tr>
<td><code>GetLaneMarkings()</code></td>
<td>获取当前入侵事件中涉及的车道线类型列表</td>
</tr>
</tbody>
</table>
<p>其中，<code>Listen</code> 是最关键的接口，用户可通过传入 Lambda 函数或回调对象，自定义入侵响应逻辑。</p>
<hr />
<h4 id="_34">示例：注册车道入侵事件监听器</h4>
<div class="highlight"><pre><span></span><code>auto sensor = world.SpawnActor(sensor_bp, transform, vehicle);
auto lane_invasion_sensor = boost::static_pointer_cast&lt;carla::sensor::data::LaneInvasionEvent&gt;(sensor);

sensor-&gt;Listen([](auto data) {
    auto event = boost::static_pointer_cast&lt;carla::sensor::data::LaneInvasionEvent&gt;(data);
    for (auto mark : event-&gt;GetCrossedLaneMarkings()) {
        std::cout &lt;&lt; &quot;Lane invasion detected: &quot; &lt;&lt; mark.TypeToString() &lt;&lt; std::endl;
    }
});
</code></pre></div>
<h4 id="_35">应用场景</h4>
<ul>
<li>
<p>驾驶员违规行为监控：识别是否压线行驶，评估驾驶行为合规性；</p>
</li>
<li>
<p>路径偏移检测：在路径规划中判断车辆是否偏离既定路线；</p>
</li>
<li>
<p>规则执行引擎支持：结合交通规则仿真，在违反道路线规则时进行惩罚或报警；</p>
</li>
<li>
<p>系统调试与可视化：在自动驾驶开发中用于调试控制策略，结合可视化界面标注压线轨迹。</p>
</li>
</ul>
<h4 id="laneinvasionevent">事件结构（LaneInvasionEvent）</h4>
<p>每次入侵会生成一个 <code>LaneInvasionEvent</code> 对象，包含以下信息：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>crossed_lane_markings</code></td>
<td><code>std::vector&lt;LaneMarking&gt;</code></td>
<td>被穿越的车道线集合</td>
</tr>
<tr>
<td><code>actor</code></td>
<td><code>Actor</code></td>
<td>触发事件的车辆</td>
</tr>
<tr>
<td><code>timestamp</code></td>
<td><code>Time</code></td>
<td>事件发生时间戳</td>
</tr>
</tbody>
</table>
<h4 id="_36">总结</h4>
<p><code>LaneInvasion</code> 模块为 CARLA 中提供了高效、可扩展的车道线检测机制，是自动驾驶测试流程中的重要一环。通过该模块，开发者可方便地监控车辆是否遵循车道规范，并可将入侵事件集成至评估、报警或控制逻辑中，显著提升仿真测试的准确性与现实性。</p>
<hr />
<h2 id="_37"><strong>类之间的调用关系</strong></h2>
<h3 id="carla">以下是 CARLA 客户端部分类之间的调用关系图，展示了各个类如何交互以及它们之间的依赖关系。</h3>
<p><img alt="类关系" src="https://github.com/LangJing23/nuanxin_volunteer/blob/master/lei.png" /></p>
<h5 id="_38">调用关系说明</h5>
<p>Client 类与其他类的交互：</p>
<blockquote>
<p>Client 类是与模拟器交互的主要接口，它通过方法如 LoadWorld()、GetAvailableMaps()、StartRecorder() 等来控制仿真世界。</p>
<p>Client 类使用 World 对象来表示仿真世界并操作其中的行为体（Actor 类）。</p>
<p>Actor 类与 Client 类的关系：</p>
<p>Actor 类表示仿真中的个体实体（如车辆、行人等），Client 类通过 Actor 对象控制仿真中的行为体（例如获取位置、速度，设置物理属性等）。</p>
<p>Actor 类也与传感器和交通管理相关联，可以通过 ClientSideSensor 和 TrafficManager 与交通流和传感器交互。</p>
<p>TrafficManager 类与 Client 类的关系：</p>
<p>TrafficManager 管理仿真中的交通流，Client 类通过 TrafficManager 提供的接口（如 SetSynchronousMode()）来控制仿真中的交通规则、车辆行为等。</p>
</blockquote>
<p>ClientSideSensor 类与 Actor 类的关系：</p>
<blockquote>
<p>ClientSideSensor 类用于模拟仿真中的传感器，能够附加到 Actor 上，例如摄像头、激光雷达等。</p>
<p>传感器可以用来获取 Actor 周围的环境数据（例如图像、点云等），以支持自动驾驶算法的训练与验证。</p>
</blockquote>
<p>World 类与其他类的关系：</p>
<blockquote>
<p>World 类表示仿真中的一个世界，它与 Client 和 Actor 类紧密关联。World 提供对仿真环境的访问，可以控制仿真世界中的所有行为体和传感器。</p>
<p>World 还负责管理交通流、物理环境、天气等仿真环境因素。</p>
</blockquote>
<h2 id="_39">总结</h2>
<p>CARLA 客户端部分提供了与仿真环境交互的丰富 API，支持开发者控制仿真世界中的各种元素，包括行为体（Actor）、传感器（ClientSideSensor）和交通流（TrafficManager）等。通过 Client 类，开发者能够加载地图、获取世界状态、管理传感器、操作物理环境等。类之间的交互使得开发者能够在仿真环境中进行精确的控制和验证。</p>
<p>参考文档：<a href="https://openhutb.github.io/carla_cpp/dir_64d7bb605f27024d49af86070bd3f0b6.html">点击此处跳转</a></p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/OpenHUTB/carla_doc" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="https://cdn.rawgit.com/knsv/mermaid/6.0.0/dist/mermaid.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script>
      <script src="../../js/umlconvert.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
