<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>第二、参与者和蓝图 - 代理仿真文档</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u7b2c\u4e8c\u3001\u53c2\u4e0e\u8005\u548c\u84dd\u56fe";
        var mkdocs_page_input_path = "core_actors.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> 代理仿真文档
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">首页</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">代理仿真文档</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">第二、参与者和蓝图</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/OpenHUTB/carla_doc/edit/master/docs/core_actors.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1">第二、参与者和蓝图</h1>
<p>Carla 中的参与者是在模拟中执行动作的元素，他们可以影响其他参与者。Carla 的参与者包括车辆和行人，也包括传感器、交通标志、红绿灯和观看者。对如何操作它们有充分的了解是至关重要的。 </p>
<p>本节将介绍生成、销毁、类型以及如何管理它们。然而，可能性几乎是无穷无尽的。实验、查看本文档中的 <strong>教程</strong>，并在 <a href="https://github.com/carla-simulator/carla/discussions/">Carla 论坛</a> 中分享疑虑和想法。</p>
<ul>
<li><a href="#blueprints"><strong>蓝图</strong></a>  <ul>
<li><a href="#managing-the-blueprint-library">管理蓝图库</a>  </li>
</ul>
</li>
<li><a href="#actor-life-cycle"><strong>参与者生命周期</strong></a>  <ul>
<li><a href="#spawning">生成</a>  </li>
<li><a href="#handling">处理</a>  </li>
<li><a href="#destruction">销毁</a>  </li>
</ul>
</li>
<li><a href="#types-of-actors"><strong>参与者类型</strong></a>  <ul>
<li><a href="#sensors">传感器</a>  </li>
<li><a href="#spectator">观察者</a>  </li>
<li><a href="#traffic-signs-and-traffic-lights">交通标志和交通灯</a>  </li>
<li><a href="#vehicles">车辆</a>  </li>
<li><a href="#walkers">行人</a>  </li>
</ul>
</li>
</ul>
<hr />
<h2 id="_2">蓝图 <span id="blueprints"></span></h2>
<p>这些布局允许用户将新的参与者平滑地结合到模拟中。它们已经是带有动画和一系列属性的模型。其中一些是可修改的，而另一些则不是。这些属性包括车辆颜色、激光雷达传感器中的通道数量、行人的速度等等。</p>
<p><a href="../bp_library/">蓝图库</a> 列出了可用的蓝图及其属性。车辆和行人蓝图具有一个生成属性，用于指示它们是新的（第 2 代）资产还是旧的（第 1 代）资产。</p>
<h3 id="_3">管理蓝图库 <span id="managing-the-blueprint-library"></span></h3>
<p><a href="../python_api/#carla.BlueprintLibrary">carla.BlueprintLibrary</a> 类包含一系列 <a href="../python_api/#carla.ActorBlueprint">carla.ActorBlueprint</a> 元素。它是能够提供对它访问的世界对象。</p>
<pre><code class="language-py">blueprint_library = world.get_blueprint_library()
</code></pre>
<p>蓝图有一个 ID 来识别它们和由此产生的参与者。可以读取库来找到某个 ID，随机选择蓝图，或者使用 <a href="https://tldp.org/LDP/GNU-Linux-Tools-Summary/html/x11655.htm">通配符模式</a> 过滤结果。</p>
<pre><code class="language-py"># 找一个指定的蓝图
collision_sensor_bp = blueprint_library.find('sensor.other.collision')
# 随机选择一个车辆蓝图
vehicle_bp = random.choice(blueprint_library.filter('vehicle.*.*'))
</code></pre>
<p>除此之外，每个 <a href="../python_api/#carla.ActorBlueprint">carla.ActorBlueprint</a> 能获取 <em>get</em> 和改变 <em>set</em> 一些列参与者属性 <a href="../python_api/#carla.ActorAttribute">carla.ActorAttribute</a> 。</p>
<pre><code class="language-py">is_bike = [vehicle.get_attribute('number_of_wheels') == 2]
if(is_bike)
    vehicle.set_attribute('color', '255,0,0')
</code></pre>
<div class="admonition 笔记">
<p class="admonition-title">笔记</p>
<p>某些属性无法修改。在<a href="../bp_library/">蓝图库</a>中查看。</p>
</div>
<p>属性有一个参与者属性类型 <a href="../python_api/#carla.ActorAttributeType">carla.ActorAttributeType</a> 变量。它从枚举列表中声明其类型。此外，可修改的属性还附带一个 <strong>推荐值列表</strong> 。</p>
<pre><code class="language-py">for attr in blueprint:
    if attr.is_modifiable:
        blueprint.set_attribute(attr.id, random.choice(attr.recommended_values))
</code></pre>
<div class="admonition 笔记">
<p class="admonition-title">笔记</p>
<p>用户可以创建他们自己的车辆。查看 <strong>教程（资产）</strong> 以了解相关信息。贡献者可以 <a href="../tuto_D_contribute_assets/">将他们的新内容添加到 Carla</a> 。</p>
</div>
<hr />
<h2 id="_4">参与者生命周期   <span id="actor-life-cycle"></span></h2>
<div class="admonition 重要">
<p class="admonition-title">重要</p>
<p>本节提到了关于参与者的不同方法。Python API 提供 <strong><a href="../python_api/#command.SpawnActor">commands</a></strong> ，以便在一个框架中应用一批最常见的命令。 </p>
</div>
<h3 id="_5">生成 <span id="spawning"></span></h3>
<p><strong>世界对象负责生成参与者并跟踪这些参与者。</strong> 生成只需要一张蓝图和一个 <a href="../python_api/#carla.Transform">carla.Transform</a> 说明参与者的位置和旋转。 </p>
<p>世界有两个不同的方法生成参与者。 </p>
<ul>
<li><a href="../python_api/#carla.World.spawn_actor"><code>spawn_actor()</code></a> 如果生成失败抛出一个异常。</li>
<li><a href="../python_api/#carla.World.try_spawn_actor"><code>try_spawn_actor()</code></a> 如果生成失败返回 <code>None</code>。</li>
</ul>
<pre><code class="language-py">transform = Transform(Location(x=230, y=195, z=40), Rotation(yaw=180))
actor = world.spawn_actor(blueprint, transform)
</code></pre>
<div class="admonition 重要">
<p class="admonition-title">重要</p>
<p>Carla 使用 <a href="https://carla.readthedocs.io/en/latest/python_api/#carlarotation">虚幻引擎坐标系统</a> 。记住： <a href="https://carla.readthedocs.io/en/latest/python_api/#carlarotation"><code>carla.Rotation</code></a> 构造函数定义为“俯仰、偏航、翻滚” <code>(pitch, yaw, roll)</code>，与虚幻编辑器的“翻滚、俯仰、偏航” <code>(roll, pitch, yaw)</code> 不同。</p>
</div>
<p>如果在指定位置发生冲突，将不会生成参与者。无论这种情况发生在静态对象还是其他参与者身上。可以尝试避免这些不希望的生成碰撞。</p>
<ul>
<li><strong>对于车辆</strong>。 <code>map.get_spawn_points()</code> 返回推荐生成点的列表。</li>
</ul>
<pre><code class="language-py">spawn_points = world.get_map().get_spawn_points()
</code></pre>
<ul>
<li><strong>对于行人</strong>。 <code>world.get_random_location()</code>返回人行道上的随机点。同样的方法也用于为行人设置目标位置。  </li>
</ul>
<pre><code class="language-py">spawn_point = carla.Transform()
spawn_point.location = world.get_random_location_from_navigation()
</code></pre>
<p>一个参与者在生成时可以附加到另一个参与者上。参与者跟随他们所依附的父级。这对于传感器特别有用。该附件可以是刚性的（适合检索精确数据），也可以根据其父级的情况进行轻松移动。它由辅助类 <a href="../python_api/#carla.AttachmentType">carla.AttachmentType</a> 定义。</p>
<p>下一个示例将相机刚性地连接到车辆上，因此它们的相对位置保持固定。</p>
<pre><code class="language-py">camera = world.spawn_actor(camera_bp, relative_transform, attach_to=my_vehicle, carla.AttachmentType.Rigid)
</code></pre>
<div class="admonition 重要">
<p class="admonition-title">重要</p>
<p>当生成附加的参与者时，提供的变换必须相对于父级参与者。</p>
</div>
<p>一旦生成，世界对象就会将参与者添加到列表中。这可以很容易地搜索或迭代。 </p>
<pre><code class="language-py">actor_list = world.get_actors()
# 根据 id 找参与者
actor = actor_list.find(id)
# 打印世界上所有限速标志的位置。
for speed_sign in actor_list.filter('traffic.speed_limit.*'):
    print(speed_sign.get_location())
</code></pre>
<h3 id="_6">处理 <span id="handling"></span></h3>
<p><a href="../python_api/#carla.Actor">carla.Actor</a> 主要由  <em>get()</em> 和 <em>set()</em> 方法组成，用于管理地图周围的参与者。</p>
<pre><code class="language-py">print(actor.get_acceleration())
print(actor.get_velocity())

location = actor.get_location()
location.z += 10.0
actor.set_location(location)
</code></pre>
<p>可以禁用参与者的物理特性以将其冻结在适当的位置。</p>
<pre><code class="language-py">actor.set_simulate_physics(False)
</code></pre>
<p>除此之外，参与者还有他们的蓝图提供的标签。这些对于语义分割传感器最有用。</p>
<div class="admonition 笔记">
<p class="admonition-title">笔记</p>
<p>大多数方法是异步向模拟器发送请求。模拟器每次更新解析它们的时间有限。使用 <em>set()</em> 方法淹没模拟器将积累明显的延迟。</p>
</div>
<h3 id="_7">销毁 <span id="destruction"></span></h3>
<p>当 Python 脚本完成时，不回销毁参与者。他们必须明确地销毁自己。</p>
<pre><code class="language-py">destroyed_sucessfully = actor.destroy() # 如果成功返回 True 
</code></pre>
<div class="admonition 重要">
<p class="admonition-title">重要</p>
<p>销毁参与者会阻塞模拟器，直到该过程完成。</p>
</div>
<hr />
<h2 id="_8">参与者类型  <span id="types-of-actors"></span></h2>
<h3 id="_9">传感器 <span id="sensors"></span></h3>
<p>传感器是产生数据流的参与者。他们有自己的部分，<a href="../core_sensors/">第四部分. 传感器和数据</a>。现在，我们只看一下常见的传感器生成周期。</p>
<p>此示例生成一个相机传感器，将其连接到车辆，并告诉相机将生成的图像保存到磁盘。</p>
<pre><code class="language-py">camera_bp = blueprint_library.find('sensor.camera.rgb')
camera = world.spawn_actor(camera_bp, relative_transform, attach_to=my_vehicle)
camera.listen(lambda image: image.save_to_disk('output/%06d.png' % image.frame))
</code></pre>
<ul>
<li>传感器也有蓝图。设置属性至关重要。 </li>
<li>大多数传感器将安装在车辆上以收集周围环境的信息。</li>
<li>传感器 <strong>监听</strong> 数据。收到数据后，它们会调用用 <strong><a href="https://docs.python.org/3/reference/expressions.html">Lambda 表达式</a></strong> 描述的函数<small>(提供的链接中的 6.14)</small>。 </li>
</ul>
<h3 id="_10">观察者 <span id="spectator"></span></h3>
<p>由虚幻引擎放置以提供游戏内的视角。它可用于移动模拟器窗口的视角。以下示例将移动观众参与者，将视角指向所需的车辆。</p>
<pre><code class="language-py">spectator = world.get_spectator()
transform = vehicle.get_transform()
spectator.set_transform(carla.Transform(transform.location + carla.Location(z=50),
carla.Rotation(pitch=-90)))
</code></pre>
<h3 id="_11">交通标志和交通灯 <span id="traffic-signs-and-traffic-lights"></span></h3>
<p>到目前为止，Carela 中只有停靠点、让行路线和交通信号灯被视为参与者。其余的 OpenDRIVE 标志可通过 API 作为地标（<a href="../python_api/#carla.Landmark"><strong>carla.Landmark</strong></a>）进行访问。他们的信息可以使用这些实例访问，但他们在模拟中并不作为参与者存在。在接下来的 <strong>第 3 部分 地图和导航</strong> 中将更详细地解释地标。 </p>
<p>当模拟开始、停止、让行和交通灯时，会使用 OpenDRIVE 文件中的信息自动生成。<strong>这些都无法在蓝图库中找到</strong>，因此无法生成。</p>
<div class="admonition 笔记">
<p class="admonition-title">笔记</p>
<p>OpenDRIVE 文件中的 Carela 地图没有交通标志或信号灯。这些是由开发人员手动放置的。 </p>
</div>
<p><a href="../python_api/#carla.TrafficSign"><strong>交通标志</strong></a> 未在路线图本身中定义，如下页所述。相反，他们有一个 <a href="../python_api/#carla.BoundingBox">carla.BoundingBox</a> 来影响其中的车辆。 </p>
<pre><code class="language-py"># 获得影响车辆的交通灯
if vehicle_actor.is_at_traffic_light():
    traffic_light = vehicle_actor.get_traffic_light()
</code></pre>
<p>路口设有<a href="../python_api/#carla.TrafficLight"><strong>交通灯</strong></a>。与任何参与者一样，他们有自己独特的 ID，但对于岔路口也有一个组（<code>group</code>） ID 。</p>
<p>同一组中的交通灯遵循一个循环。第一个设置为绿色，而其余的则保持红色。活跃的灯会持续几秒钟呈绿色、黄色和红色，因此有一段时间所有灯都是红色的。然后，下一个红绿灯开始循环，前一个红绿灯与其余红绿灯一起冻结。</p>
<p>可以使用 API 设置交通灯的状态。每个状态花费的秒数也是如此。可能的状态用 <a href="../python_api/#carla.TrafficLightState">carla.TrafficLightState</a> 描述为一系列枚举值。</p>
<pre><code class="language-py"># 交通灯从红变绿
if traffic_light.get_state() == carla.TrafficLightState.Red:
    traffic_light.set_state(carla.TrafficLightState.Green)
    traffic_light.set_set_green_time(4.0)
</code></pre>
<div class="admonition 笔记">
<p class="admonition-title">笔记</p>
<p>只有当信号灯为红色时，车辆才会意识到交通灯。</p>
</div>
<h3 id="_12">车辆 <span id="vehicles"></span></h3>
<p><a href="../python_api/#carla.Vehicle"><strong>carla.Vehicle</strong></a> 是一种特殊类型的参与者。它采用了模拟轮式车辆物理特性的特殊内部组件。这是通过应用四种不同的控件来实现的：</p>
<ul>
<li><strong><a href="../python_api/#carla.VehicleControl">carla.VehicleControl</a></strong> 提供油门、转向、刹车等驾驶命令的输入。</li>
</ul>
<pre><code class="language-py">vehicle.apply_control(carla.VehicleControl(throttle=1.0, steer=-1.0))
</code></pre>
<ul>
<li>
<p><strong><a href="../python_api/#carla.VehiclePhysicsControl">carla.VehiclePhysicsControl</a></strong> 定义车辆的物理属性并包含另外两个控制器：</p>
<ul>
<li><a href="../python_api/#carla.GearPhysicsControl">carla.GearPhysicsControl</a> 控制档位。</li>
<li><a href="../python_api/#carla.WheelPhysicsControl">carla.WheelPhysicsControl</a> 提供对每个轮子的特定控制。</li>
</ul>
</li>
</ul>
<pre><code class="language-py">vehicle.apply_physics_control(carla.VehiclePhysicsControl(max_rpm = 5000.0, center_of_mass = carla.Vector3D(0.0, 0.0, 0.0), torque_curve=[[0,400],[5000,400]]))
</code></pre>
<p>车辆有一个 <a href="../python_api/#carla.BoundingBox">carla.BoundingBox</a> 封装它们。该边界框允许将物理原理应用于车辆并检测碰撞。</p>
<pre><code class="language-py">box = vehicle.bounding_box
print(box.location)         # 相对车辆的位置
print(box.extent)           # XYZ half-box extents in meters.
</code></pre>
<p>通过启用 <a href="https://carla.readthedocs.io/en/latest/python_api/#carla.VehiclePhysicsControl.use_sweep_wheel_collision">扫轮碰撞参数</a> 可以改善车轮的物理特性。默认的轮子物理系统对每个轮子使用从轴到地板的单射线投射，但是当启用扫轮碰撞时，将检查轮子的整个体积是否发生碰撞。它可以这样启用：</p>
<pre><code class="language-py">physics_control = vehicle.get_physics_control()
physics_control.use_sweep_wheel_collision = True
vehicle.apply_physics_control(physics_control)
</code></pre>
<p>车辆还包括其独有的其他功能：</p>
<ul>
<li><strong>自动驾驶模式</strong> 会将车辆订阅到 <a href="../adv_traffic_manager/">交通管理器</a> 以模拟真实的城市状况。该模块是硬编码的，不是基于机器学习的。</li>
</ul>
<pre><code class="language-py">vehicle.set_autopilot(True)
</code></pre>
<ul>
<li><strong>车灯</strong> 必须由用户打开和关闭。每辆车都有一组在<a href="../python_api/#carla.VehicleLightState"><strong>carla.VehicleLightState</strong></a> 中列出的灯。并非所有车辆都集成了车灯。截至撰写本文时，配备集成车灯的车辆如下：<ul>
<li><strong>自行车：</strong> 所有自行车都有前后位置灯。</li>
<li><strong>摩托车：</strong> 雅马哈和哈雷戴维森型号。</li>
<li><strong>汽车：</strong> 奥迪 TT、雪佛兰 Impala、道奇警车、道奇 Charger、奥迪 e-tron、林肯 2017 年和 2020 年、野马、特斯拉 Model 3、特斯拉 Cybertruck、大众 T2 和梅赛德斯 C 级。</li>
</ul>
</li>
</ul>
<p>可以使用 <a href="../python_api/#carla.Vehicle.get_light_state">carla.Vehicle.get_light_state</a> 和 <a href="#python_api.md#carla.Vehicle.set_light_state">carla.Vehicle.set_light_state</a> 方法随时检索和更新车辆的灯光。它们使用二进制运算来自定义灯光设置。</p>
<pre><code class="language-py"># 打开位置灯
current_lights = carla.VehicleLightState.NONE
current_lights |= carla.VehicleLightState.Position
vehicle.set_light_state(current_lights)
</code></pre>
<h3 id="_13">行人 <span id="walkers"></span></h3>
<p><a href="../python_api/#carla.Walker"><strong>carla.Walker</strong></a> 的工作方式与车辆类似。对它们的控制由控制器提供。</p>
<ul>
<li><a href="../python_api/#carla.WalkerControl"><strong>carla.WalkerControl</strong></a> 以一定的方向和速度移动行人。它还允许他们跳跃。</li>
<li><a href="../python_api/#carla.WalkerBoneControl"><strong>carla.WalkerBoneControl</strong></a> 提供对三维骨架的控制。<a href="../tuto_G_control_walker_skeletons/">本教程</a> 解释了如何控制它。</li>
</ul>
<p>行人可以由人工智能控制。他们没有自动驾驶模式。<a href="../python_api/#carla.WalkerAIController"><strong>carla.WalkerAIController</strong></a> 参与者在它所附加的参与者周围移动。</p>
<pre><code class="language-py">walker_controller_bp = world.get_blueprint_library().find('controller.ai.walker')
world.SpawnActor(walker_controller_bp, carla.Transform(), parent_walker)
</code></pre>
<div class="admonition 笔记">
<p class="admonition-title">笔记</p>
<p>人工智能控制器是无形的，没有物理特性。它不会出现在现场。此外，位置 <code>(0,0,0)</code> 相对于其父级的位置不会导致碰撞。  </p>
</div>
<p><strong>每个人工智能控制器都需要初始化、目标和可选的速度</strong>。停止控制器的工作方式相同。</p>
<pre><code class="language-py">ai_controller.start()
ai_controller.go_to_location(world.get_random_location_from_navigation())
ai_controller.set_max_speed(1 + random.random())  # 在 1 米每秒 到 2 米每秒之间（默认是 1.4 米每秒）
...
ai_controller.stop()
</code></pre>
<p>当行人到达目标位置时，他们会自动步行到另一个随机点。如果无法到达目标点，行人将前往距离当前位置最近的点。</p>
<p><a href="../python_api/#carla.Client.apply_batch_sync">carla.Client</a> 中的一个片段使用批次生成大量行人并让它们四处游荡。</p>
<div class="admonition 重要">
<p class="admonition-title">重要</p>
<p><strong>要销毁人工智能行人</strong>，请停止人工智能控制器并销毁参与者和控制器。</p>
</div>
<hr />
<p>关于 Carla 中的参与者，这就是一个总结。下一步将仔细研究 Carla 的地图、道路和交通。</p>
<p>继续阅读以了解更多信息，或访问论坛发布在阅读过程中想到的任何疑问或建议。</p>
<div text-align: center>
<div class="build-buttons">
<p>
<a href="https://github.com/carla-simulator/carla/discussions/" target="_blank" class="btn btn-neutral" title="CARLA forum">
Carla 论坛</a>
</p>
</div>
<div class="build-buttons">
<p>
<a href="../core_map" target="_blank" class="btn btn-neutral" title="3rd. Maps and navigation">
3rd. 地图和导航</a>
</p>
</div>
</div>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/OpenHUTB/carla_doc" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../extra.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
